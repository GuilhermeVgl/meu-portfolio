/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/logrocket";
exports.ids = ["vendor-chunks/logrocket"];
exports.modules = {

/***/ "(ssr)/./node_modules/logrocket/dist/build.umd.js":
/*!**************************************************!*\
  !*** ./node_modules/logrocket/dist/build.umd.js ***!
  \**************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse { var i, a; }\n})(this, function() {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./packages/@logrocket/arson/src/index.js\":\n/*!************************************************!*\\\n  !*** ./packages/@logrocket/arson/src/index.js ***!\n  \\************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_710__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_710__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.encode = encode;\nexports.decode = decode;\nvar _typeof2 = _interopRequireDefault(__nested_webpack_require_710__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n/* eslint-disable */\n\nvar UNDEFINED_INDEX = -1;\nvar ARRAY_HOLE_INDEX = -2;\nvar NAN_INDEX = -3;\nvar POS_INF_INDEX = -4;\nvar NEG_INF_INDEX = -5;\nvar customTypes = Object.create(null);\nvar registerType = function registerType(typeName, handlers) {\n  function check(methodName) {\n    if (typeof handlers[methodName] !== \"function\") {\n      throw new Error(\"second argument to ARSON.registerType(\" + JSON.stringify(typeName) + \", ...) \" + \"must be an object with a \" + methodName + \" method\");\n    }\n  }\n  check(\"deconstruct\");\n  check(\"reconstruct\");\n  customTypes[typeName] = handlers;\n};\nvar toString = Object.prototype.toString;\nvar dateTag = \"[object Date]\";\nvar regExpTag = \"[object RegExp]\";\nvar setTag = \"[object Set]\";\nvar mapTag = \"[object Map]\";\ntypeof Buffer === \"function\" && typeof Buffer.isBuffer === \"function\" && registerType(\"Buffer\", {\n  deconstruct: function deconstruct(buf) {\n    return Buffer.isBuffer(buf) && [buf.toString(\"base64\"), \"base64\"];\n  },\n  // The reconstruct function will be called twice: once with no\n  // arguments, which allows it to return a placeholder object reference;\n  // and once with one argument, a copy of the array returned by the\n  // deconstruct function. For immutable types like Buffer, Date, and\n  // RegExp, the reconstruct function should return a falsy value when it\n  // receives no arguments, since there is no way to create an empty\n  // Buffer or Date and later fill in its contents.  For container types\n  // like Map and Set, the reconstruct function must return an empty\n  // instance of the container when it receives no arguments, so that we\n  // can fill in that empty container later. This two-phased strategy is\n  // essential for decoding containers that contain themselves.\n  reconstruct: function reconstruct(args) {\n    return args && Buffer.from(args[0], args[1]);\n  }\n});\nregisterType(\"Date\", {\n  deconstruct: function deconstruct(date) {\n    return toString.call(date) === dateTag && [date.toJSON()];\n  },\n  reconstruct: function reconstruct(args) {\n    return args && new Date(args[0]);\n  }\n});\nregisterType(\"RegExp\", {\n  deconstruct: function deconstruct(exp) {\n    if (toString.call(exp) === regExpTag) {\n      var args = [exp.source];\n      var flags = \"\";\n      if (exp.ignoreCase) flags += \"i\";\n      if (exp.multiline) flags += \"m\";\n      if (exp.global) flags += \"g\";\n      if (flags) {\n        args.push(flags);\n      }\n      return args;\n    }\n  },\n  reconstruct: function reconstruct(args) {\n    return args && new RegExp(args[0], args[1]);\n  }\n});\ntypeof Set === \"function\" && typeof Array.from === \"function\" && registerType(\"Set\", {\n  deconstruct: function deconstruct(set) {\n    if (toString.call(set) === setTag) {\n      return Array.from(set);\n    }\n  },\n  reconstruct: function reconstruct(values) {\n    if (values) {\n      values.forEach(this.add, this);\n    } else {\n      return new Set();\n    }\n  }\n});\ntypeof Map === \"function\" && typeof Array.from === \"function\" && registerType(\"Map\", {\n  deconstruct: function deconstruct(map) {\n    if (toString.call(map) === mapTag) {\n      return Array.from(map);\n    }\n  },\n  reconstruct: function reconstruct(entries) {\n    if (entries) {\n      entries.forEach(function (entry) {\n        this.set(entry[0], entry[1]);\n      }, this);\n    } else {\n      return new Map();\n    }\n  }\n});\nfunction encode(value) {\n  return JSON.stringify(toTable(value));\n}\nfunction toTable(value) {\n  var values = [];\n  var indexMap = typeof Map === \"function\" && new Map();\n  function getIndex(value) {\n    switch ((0, _typeof2.default)(value)) {\n      case \"undefined\":\n        return UNDEFINED_INDEX;\n      case \"number\":\n        if (isNaN(value)) {\n          return NAN_INDEX;\n        }\n        if (!isFinite(value)) {\n          return value < 0 ? NEG_INF_INDEX : POS_INF_INDEX;\n        }\n\n      // fall through...\n    }\n\n    var index;\n    if (indexMap) {\n      // If we have Map, use it instead of values.indexOf to accelerate\n      // object lookups.\n      index = indexMap.get(value);\n      if (typeof index === \"undefined\") {\n        index = values.push(value) - 1;\n        indexMap.set(value, index);\n      }\n    } else {\n      index = values.indexOf(value);\n      if (index < 0) {\n        index = values.push(value) - 1;\n      }\n    }\n    return index;\n  }\n  function copy(value) {\n    var result = value;\n    if (value && (0, _typeof2.default)(value) === \"object\") {\n      var keys = Object.keys(value);\n      if (isPlainObject(value)) {\n        result = {};\n      } else if (Array.isArray(value)) {\n        result = Array(value.length);\n        var len = value.length;\n        if (len > keys.length) {\n          // The array has holes, so make sure we fill them with the\n          // ARRAY_HOLE_INDEX constant.\n          for (var i = 0; i < len; ++i) {\n            result[i] = ARRAY_HOLE_INDEX;\n          }\n        }\n      } else {\n        for (var typeName in customTypes) {\n          // If value is not a plain Object, but something exotic like a\n          // Date or a RegExp, serialize it as an array with typeName as\n          // its first element. These arrays can be distinguished from\n          // normal arrays, because all other non-empty arrays will be\n          // serialized with a numeric value as their first element.\n          var args = customTypes[typeName].deconstruct(value);\n          if (args) {\n            for (var i = 0; i < args.length; ++i) {\n              args[i] = getIndex(args[i]);\n            }\n            args.unshift(typeName);\n            return args;\n          }\n        }\n        return {}.toString.call(value);\n      }\n      keys.forEach(function (key) {\n        result[key] = getIndex(value[key]);\n      });\n    }\n    return result;\n  }\n\n  // Assigns the root value to values[0].\n  var index0 = getIndex(value);\n  if (index0 < 0) {\n    // If value is something special that gets a negative index, then we\n    // don't need to build a table at all, and we can simply return that\n    // negative index as a complete serialization. This avoids ambiguity\n    // about indexes versus primitive literal values.\n    return index0;\n  }\n\n  // Note that this for loop cannot be a forEach loop, because\n  // values.length is expected to change during iteration.\n  for (var table = [], v = 0; v < values.length; ++v) {\n    table[v] = copy(values[v]);\n  }\n  return table;\n}\nfunction isPlainObject(value) {\n  var isObject = value && (0, _typeof2.default)(value) === \"object\";\n  if (isObject) {\n    var proto = Object.getPrototypeOf ? Object.getPrototypeOf(value) : value.__proto__;\n    return proto === Object.prototype;\n  }\n  return false;\n}\nfunction decode(encoding) {\n  return fromTable(JSON.parse(encoding));\n}\nfunction fromTable(table) {\n  if (typeof table === \"number\" && table < 0) {\n    return getValueWithoutCache(table);\n  }\n  var getValueCache = new Array(table.length);\n  function getValue(index) {\n    return index in getValueCache ? getValueCache[index] : getValueCache[index] = getValueWithoutCache(index);\n  }\n  function getValueWithoutCache(index) {\n    if (index < 0) {\n      if (index === UNDEFINED_INDEX) {\n        return;\n      }\n      if (index === ARRAY_HOLE_INDEX) {\n        // Never reached because handled specially below.\n        return;\n      }\n      if (index === NAN_INDEX) {\n        return NaN;\n      }\n      if (index === POS_INF_INDEX) {\n        return Infinity;\n      }\n      if (index === NEG_INF_INDEX) {\n        return -Infinity;\n      }\n      throw new Error(\"invalid ARSON index: \" + index);\n    }\n    var entry = table[index];\n    if (entry && (0, _typeof2.default)(entry) === \"object\") {\n      if (Array.isArray(entry)) {\n        var elem0 = entry[0];\n        if (typeof elem0 === \"string\" && elem0 in customTypes) {\n          var rec = customTypes[elem0].reconstruct;\n          var empty = rec();\n          if (empty) {\n            // If the reconstruct handler returns an object, treat it as\n            // an empty instance of the desired type, and schedule it to\n            // be filled in later. This two-stage process allows exotic\n            // container objects to contain themselves.\n            containers.push({\n              reconstruct: rec,\n              empty: empty,\n              argIndexes: entry.slice(1)\n            });\n          }\n\n          // If the reconstruct handler returned a falsy value, then we\n          // assume none of its arguments refer to exotic containers, so\n          // we can reconstruct the object immediately. Examples: Buffer,\n          // Date, RegExp.\n          return table[index] = empty || rec(entry.slice(1).map(getValue));\n        }\n      }\n\n      // Here entry is already the correct array or object reference for\n      // this index, but its values are still indexes that will need to be\n      // resolved later.\n      objects.push(entry);\n    }\n    return entry;\n  }\n  var containers = [];\n  var objects = [];\n\n  // First pass: make sure all exotic objects are deserialized fist, and\n  // keep track of all plain object entries for later.\n  table.forEach(function (entry, i) {\n    getValue(i);\n  });\n\n  // Second pass: now that we have final object references for all exotic\n  // objects, we can safely resolve argument indexes for the empty ones.\n  containers.forEach(function (c) {\n    c.args = c.argIndexes.map(getValue);\n  });\n\n  // Third pass: resolve value indexes for ordinary arrays and objects.\n  objects.forEach(function (obj) {\n    Object.keys(obj).forEach(function (key) {\n      var index = obj[key];\n      if (typeof index !== \"number\") {\n        // Leave non-numeric indexes untouched.\n        return;\n      }\n      if (index < 0) {\n        if (index === ARRAY_HOLE_INDEX) {\n          // Array holes have to be handled specially here, since getValue\n          // does not have a reference to obj.\n          delete obj[key];\n          return;\n        }\n\n        // This recursion is guaranteed not to add more objects, because\n        // we know the index is negative.\n        obj[key] = getValue(index);\n      } else {\n        // Non-negative indexes refer to normal table values.\n        obj[key] = table[index];\n      }\n    });\n  });\n\n  // Fourth pass: all possible object references have been established, so\n  // we can finally initialize the empty container objects.\n  containers.forEach(function (c) {\n    c.reconstruct.call(c.empty, c.args);\n  });\n  return table[0];\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/console/src/index.js\":\n/*!**************************************************!*\\\n  !*** ./packages/@logrocket/console/src/index.js ***!\n  \\**************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_11808__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_11808__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _registerConsole = _interopRequireDefault(__nested_webpack_require_11808__(/*! ./registerConsole */ \"./packages/@logrocket/console/src/registerConsole.js\"));\nvar _default = _registerConsole.default;\nexports[\"default\"] = _default;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/console/src/registerConsole.js\":\n/*!************************************************************!*\\\n  !*** ./packages/@logrocket/console/src/registerConsole.js ***!\n  \\************************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_12654__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_12654__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = registerConsole;\nvar _typeof2 = _interopRequireDefault(__nested_webpack_require_12654__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\nvar _enhanceFunc = _interopRequireDefault(__nested_webpack_require_12654__(/*! @logrocket/utils/src/enhanceFunc */ \"./packages/@logrocket/utils/src/enhanceFunc.js\"));\nvar _exceptions = __nested_webpack_require_12654__(/*! @logrocket/exceptions */ \"./packages/@logrocket/exceptions/src/index.js\");\n// eslint-disable-line no-restricted-imports\n\nfunction registerConsole(logger) {\n  var unsubFunctions = [];\n  var methods = ['log', 'warn', 'info', 'error', 'debug'];\n  methods.forEach(function (method) {\n    unsubFunctions.push((0, _enhanceFunc.default)(console, method, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      logger.addEvent('lr.core.LogEvent', function () {\n        var consoleOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var isEnabled = consoleOptions.isEnabled;\n        if ((0, _typeof2.default)(isEnabled) === 'object' && isEnabled[method] === false || isEnabled === false) {\n          return null;\n        }\n        if (method === 'error' && consoleOptions.shouldAggregateConsoleErrors) {\n          _exceptions.Capture.captureMessage(logger, args[0], args, {}, true);\n        }\n        return {\n          logLevel: method.toUpperCase(),\n          args: args\n        };\n      });\n    }));\n  });\n  return function () {\n    unsubFunctions.forEach(function (unsubFunction) {\n      return unsubFunction();\n    });\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/exceptions/src/Capture.js\":\n/*!*******************************************************!*\\\n  !*** ./packages/@logrocket/exceptions/src/Capture.js ***!\n  \\*******************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_14879__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_14879__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.captureMessage = captureMessage;\nexports.captureException = captureException;\nvar _utils = __nested_webpack_require_14879__(/*! @logrocket/utils */ \"./packages/@logrocket/utils/src/index.ts\");\nvar _TraceKit = _interopRequireDefault(__nested_webpack_require_14879__(/*! @logrocket/utils/src/TraceKit */ \"./packages/@logrocket/utils/src/TraceKit.js\"));\nvar _stackTraceFromError = _interopRequireDefault(__nested_webpack_require_14879__(/*! ./stackTraceFromError */ \"./packages/@logrocket/exceptions/src/stackTraceFromError.js\"));\n// eslint-disable-line no-restricted-imports\n\nfunction captureMessage(logger, message, messageArgs) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var isConsole = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var data = {\n    exceptionType: isConsole ? 'CONSOLE' : 'MESSAGE',\n    message: message,\n    messageArgs: messageArgs,\n    browserHref: window.location ? window.location.href : ''\n  };\n  (0, _utils.scrubException)(data, options);\n  logger.addEvent('lr.core.Exception', function () {\n    return data;\n  });\n}\nfunction captureException(logger, exception) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var preppedTrace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var trace = preppedTrace || _TraceKit.default.computeStackTrace(exception);\n  var data = {\n    exceptionType: 'WINDOW',\n    errorType: trace.name,\n    message: trace.message,\n    browserHref: window.location ? window.location.href : ''\n  };\n  (0, _utils.scrubException)(data, options);\n  var addEventOptions = {\n    _stackTrace: (0, _stackTraceFromError.default)(trace)\n  };\n  logger.addEvent('lr.core.Exception', function () {\n    return data;\n  }, addEventOptions);\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/exceptions/src/index.js\":\n/*!*****************************************************!*\\\n  !*** ./packages/@logrocket/exceptions/src/index.js ***!\n  \\*****************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_17239__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_17239__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _typeof = __nested_webpack_require_17239__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"registerExceptions\", ({\n  enumerable: true,\n  get: function get() {\n    return _registerExceptions.default;\n  }\n}));\nexports.Capture = void 0;\nvar _registerExceptions = _interopRequireDefault(__nested_webpack_require_17239__(/*! ./registerExceptions */ \"./packages/@logrocket/exceptions/src/registerExceptions.js\"));\nvar Capture = _interopRequireWildcard(__nested_webpack_require_17239__(/*! ./Capture */ \"./packages/@logrocket/exceptions/src/Capture.js\"));\nexports.Capture = Capture;\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/exceptions/src/raven/raven.js\":\n/*!***********************************************************!*\\\n  !*** ./packages/@logrocket/exceptions/src/raven/raven.js ***!\n  \\***********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_19588__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_19588__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _classCallCheck2 = _interopRequireDefault(__nested_webpack_require_19588__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\nvar _createClass2 = _interopRequireDefault(__nested_webpack_require_19588__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\nvar _TraceKit = _interopRequireDefault(__nested_webpack_require_19588__(/*! @logrocket/utils/src/TraceKit */ \"./packages/@logrocket/utils/src/TraceKit.js\"));\n/* eslint-disable */\n\n/*\nSome contents of this file were originaly from raven-js, BSD-2 Clause\n\nCopyright (c) 2018 Sentry (https://sentry.io) and individual contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar objectPrototype = Object.prototype;\nfunction isUndefined(what) {\n  return what === void 0;\n}\nfunction isFunction(what) {\n  return typeof what === 'function';\n}\nfunction each(obj, callback) {\n  var i, j;\n  if (isUndefined(obj.length)) {\n    for (i in obj) {\n      if (hasKey(obj, i)) {\n        callback.call(null, i, obj[i]);\n      }\n    }\n  } else {\n    j = obj.length;\n    if (j) {\n      for (i = 0; i < j; i++) {\n        callback.call(null, i, obj[i]);\n      }\n    }\n  }\n}\n\n/**\n * hasKey, a better form of hasOwnProperty\n * Example: hasKey(MainHostObject, property) === true/false\n *\n * @param {Object} host object to check property\n * @param {string} key to check\n */\nfunction hasKey(object, key) {\n  return objectPrototype.hasOwnProperty.call(object, key);\n}\n\n/**\n * Polyfill a method\n * @param obj object e.g. `document`\n * @param name method name present on object e.g. `addEventListener`\n * @param replacement replacement function\n * @param track {optional} record instrumentation to an array\n */\nfunction fill(obj, name, replacement, track) {\n  var orig = obj[name];\n  obj[name] = replacement(orig);\n  if (track) {\n    track.push([obj, name, orig]);\n  }\n}\nvar _window = typeof window !== 'undefined' ? window : typeof __nested_webpack_require_19588__.g !== 'undefined' ? __nested_webpack_require_19588__.g : typeof self !== 'undefined' ? self : {};\nvar _document = _window.document;\nvar Handler = /*#__PURE__*/function () {\n  function Handler(_ref) {\n    var captureException = _ref.captureException;\n    (0, _classCallCheck2.default)(this, Handler);\n    this._errorHandler = this._errorHandler.bind(this);\n    this._ignoreOnError = 0;\n    this._wrappedBuiltIns = [];\n    this.captureException = captureException;\n    _TraceKit.default.report.subscribe(this._errorHandler);\n    this._instrumentTryCatch();\n  }\n  (0, _createClass2.default)(Handler, [{\n    key: \"uninstall\",\n    value: function uninstall() {\n      _TraceKit.default.report.unsubscribe(this._errorHandler);\n\n      // restore any wrapped builtins\n      var builtin;\n      while (this._wrappedBuiltIns.length) {\n        builtin = this._wrappedBuiltIns.shift();\n        var obj = builtin[0],\n          name = builtin[1],\n          orig = builtin[2];\n        obj[name] = orig;\n      }\n    }\n  }, {\n    key: \"_errorHandler\",\n    value: function _errorHandler(report) {\n      if (!this._ignoreOnError) {\n        this.captureException(report);\n      }\n    }\n  }, {\n    key: \"_ignoreNextOnError\",\n    value: function _ignoreNextOnError() {\n      var _this = this;\n      this._ignoreOnError += 1;\n      setTimeout(function () {\n        // onerror should trigger before setTimeout\n        _this._ignoreOnError -= 1;\n      });\n    }\n\n    /*\n     * Wrap code within a context so Handler can capture errors\n     * reliably across domains that is executed immediately.\n     *\n     * @param {object} options A specific set of options for this context [optional]\n     * @param {function} func The callback to be immediately executed within the context\n     * @param {array} args An array of arguments to be called with the callback [optional]\n     */\n  }, {\n    key: \"context\",\n    value: function context(options, func, args) {\n      if (isFunction(options)) {\n        args = func || [];\n        func = options;\n        options = undefined;\n      }\n      return this.wrap(options, func).apply(this, args);\n    }\n  }, {\n    key: \"wrap\",\n    value:\n    /*\n     * Wrap code within a context and returns back a new function to be executed\n     *\n     * @param {object} options A specific set of options for this context [optional]\n     * @param {function} func The function to be wrapped in a new context\n     * @param {function} func A function to call before the try/catch wrapper [optional, private]\n     * @return {function} The newly wrapped functions with a context\n     */\n    function wrap(options, func, _before) {\n      var self = this;\n      // 1 argument has been passed, and it's not a function\n      // so just return it\n      if (isUndefined(func) && !isFunction(options)) {\n        return options;\n      }\n\n      // options is optional\n      if (isFunction(options)) {\n        func = options;\n        options = undefined;\n      }\n\n      // At this point, we've passed along 2 arguments, and the second one\n      // is not a function either, so we'll just return the second argument.\n      if (!isFunction(func)) {\n        return func;\n      }\n\n      // We don't wanna wrap it twice!\n      try {\n        if (func.__lr__) {\n          return func;\n        }\n\n        // If this has already been wrapped in the past, return that\n        if (func.__lr_wrapper__) {\n          return func.__lr_wrapper__;\n        }\n\n        // If func is not extensible, return the function as-is to prevent TypeErrors\n        // when trying to add new props & to assure immutable funcs aren't changed\n        if (!Object.isExtensible(func)) {\n          return func;\n        }\n      } catch (e) {\n        // Just accessing custom props in some Selenium environments\n        // can cause a \"Permission denied\" exception (see lr-js#495).\n        // Bail on wrapping and return the function as-is (defers to window.onerror).\n        return func;\n      }\n      function wrapped() {\n        var args = [],\n          i = arguments.length,\n          deep = !options || options && options.deep !== false;\n        if (_before && isFunction(_before)) {\n          _before.apply(this, arguments);\n        }\n\n        // Recursively wrap all of a function's arguments that are\n        // functions themselves.\n        while (i--) {\n          args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];\n        }\n        try {\n          // Attempt to invoke user-land function. This is part of the LogRocket SDK.\n          // If you're seeing this frame in a stack trace, it means that LogRocket caught\n          // an unhandled error thrown by your application code, reported it, then bubbled\n          // it up. This is expected behavior and is not a bug with LogRocket.\n          return func.apply(this, args);\n        } catch (e) {\n          self._ignoreNextOnError();\n          self.captureException(_TraceKit.default.computeStackTrace(e), options);\n          throw e;\n        }\n      }\n\n      // copy over properties of the old function\n      for (var property in func) {\n        if (hasKey(func, property)) {\n          wrapped[property] = func[property];\n        }\n      }\n      wrapped.prototype = func.prototype;\n      func.__lr_wrapper__ = wrapped;\n      // Signal that this function has been wrapped already\n      // for both debugging and to prevent it to being wrapped twice\n      wrapped.__lr__ = true;\n      wrapped.__inner__ = func;\n      return wrapped;\n    }\n  }, {\n    key: \"_instrumentTryCatch\",\n    value:\n    /**\n     * Install any queued plugins\n     */\n    function _instrumentTryCatch() {\n      var self = this;\n      var wrappedBuiltIns = self._wrappedBuiltIns;\n      function wrapTimeFn(orig) {\n        return function (fn, t) {\n          // preserve arity\n          // Make a copy of the arguments to prevent deoptimization\n          // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n          var args = new Array(arguments.length);\n          for (var i = 0; i < args.length; ++i) {\n            args[i] = arguments[i];\n          }\n          var originalCallback = args[0];\n          if (isFunction(originalCallback)) {\n            args[0] = self.wrap(originalCallback);\n          }\n\n          // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it\n          // also supports only two arguments and doesn't care what this is, so we\n          // can just call the original function directly.\n          if (orig.apply) {\n            return orig.apply(this, args);\n          } else {\n            return orig(args[0], args[1]);\n          }\n        };\n      }\n      function wrapEventTarget(global) {\n        var proto = _window[global] && _window[global].prototype;\n        if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {\n          fill(proto, 'addEventListener', function (orig) {\n            return function (evtName, fn, capture, secure) {\n              // preserve arity\n              try {\n                if (fn && fn.handleEvent) {\n                  fn.handleEvent = self.wrap(fn.handleEvent);\n                }\n              } catch (err) {\n                // can sometimes get 'Permission denied to access property \"handle Event'\n              }\n\n              // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`\n              // so that we don't have more than one wrapper function\n              var before;\n              return orig.call(this, evtName, self.wrap(fn, undefined, before), capture, secure);\n            };\n          }, wrappedBuiltIns);\n          fill(proto, 'removeEventListener', function (orig) {\n            return function (evt, fn, capture, secure) {\n              try {\n                fn = fn && (fn.__lr_wrapper__ ? fn.__lr_wrapper__ : fn);\n              } catch (e) {\n                // ignore, accessing __lr_wrapper__ will throw in some Selenium environments\n              }\n              return orig.call(this, evt, fn, capture, secure);\n            };\n          }, wrappedBuiltIns);\n        }\n      }\n      fill(_window, 'setTimeout', wrapTimeFn, wrappedBuiltIns);\n      fill(_window, 'setInterval', wrapTimeFn, wrappedBuiltIns);\n      if (_window.requestAnimationFrame) {\n        fill(_window, 'requestAnimationFrame', function (orig) {\n          return function (cb) {\n            return orig(self.wrap(cb));\n          };\n        }, wrappedBuiltIns);\n      }\n\n      // event targets borrowed from bugsnag-js:\n      // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666\n      var eventTargets = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];\n      for (var i = 0; i < eventTargets.length; i++) {\n        wrapEventTarget(eventTargets[i]);\n      }\n      var $ = _window.jQuery || _window.$;\n      if ($ && $.fn && $.fn.ready) {\n        fill($.fn, 'ready', function (orig) {\n          return function (fn) {\n            return orig.call(this, self.wrap(fn));\n          };\n        }, wrappedBuiltIns);\n      }\n    }\n  }]);\n  return Handler;\n}();\nexports[\"default\"] = Handler;\n;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/exceptions/src/registerExceptions.js\":\n/*!******************************************************************!*\\\n  !*** ./packages/@logrocket/exceptions/src/registerExceptions.js ***!\n  \\******************************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_32875__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_32875__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _typeof = __nested_webpack_require_32875__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = registerCore;\nvar _raven = _interopRequireDefault(__nested_webpack_require_32875__(/*! ./raven/raven */ \"./packages/@logrocket/exceptions/src/raven/raven.js\"));\nvar Capture = _interopRequireWildcard(__nested_webpack_require_32875__(/*! ./Capture */ \"./packages/@logrocket/exceptions/src/Capture.js\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction registerCore(logger) {\n  var raven = new _raven.default({\n    captureException: function captureException(errorReport) {\n      Capture.captureException(logger, null, null, errorReport);\n    }\n  });\n  var rejectionHandler = function rejectionHandler(evt) {\n    // http://2ality.com/2016/04/unhandled-rejections.html\n    logger.addEvent('lr.core.Exception', function () {\n      return {\n        exceptionType: 'UNHANDLED_REJECTION',\n        message: evt.reason || 'Unhandled Promise rejection'\n      };\n    });\n  };\n  window.addEventListener('unhandledrejection', rejectionHandler);\n  return function () {\n    window.removeEventListener('unhandledrejection', rejectionHandler);\n    raven.uninstall();\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/exceptions/src/stackTraceFromError.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/exceptions/src/stackTraceFromError.js ***!\n  \\*******************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = stackTraceFromError;\nfunction stackTraceFromError(errorReport) {\n  function makeNotNull(val) {\n    return val === null ? undefined : val;\n  }\n  return errorReport.stack ? errorReport.stack.map(function (frame) {\n    return {\n      lineNumber: makeNotNull(frame.line),\n      columnNumber: makeNotNull(frame.column),\n      fileName: makeNotNull(frame.url),\n      functionName: makeNotNull(frame.func)\n    };\n  }) : undefined;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/network/src/fetchIntercept.js\":\n/*!***********************************************************!*\\\n  !*** ./packages/@logrocket/network/src/fetchIntercept.js ***!\n  \\***********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_36627__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_36627__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(__nested_webpack_require_36627__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\nvar _registerXHR = __nested_webpack_require_36627__(/*! ./registerXHR */ \"./packages/@logrocket/network/src/registerXHR.js\");\nvar interceptors = [];\nfunction makeInterceptor(fetch, fetchId) {\n  var reversedInterceptors = interceptors.reduce(function (array, interceptor) {\n    return [interceptor].concat(array);\n  }, []);\n  // if a browser supports fetch, it supports promise\n  // eslint-disable-next-line compat/compat\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n  var promise = Promise.resolve(args);\n\n  // Register request interceptors\n  reversedInterceptors.forEach(function (_ref) {\n    var request = _ref.request,\n      requestError = _ref.requestError;\n    if (request || requestError) {\n      promise = promise.then(function (args) {\n        return request.apply(void 0, [fetchId].concat((0, _toConsumableArray2.default)(args)));\n      }, function (args) {\n        return requestError.apply(void 0, [fetchId].concat((0, _toConsumableArray2.default)(args)));\n      });\n    }\n  });\n  promise = promise.then(function (args) {\n    (0, _registerXHR.setActive)(false);\n    var res;\n    var err;\n    try {\n      res = fetch.apply(void 0, (0, _toConsumableArray2.default)(args));\n    } catch (_err) {\n      err = _err;\n    }\n    (0, _registerXHR.setActive)(true);\n    if (err) {\n      throw err;\n    }\n    return res;\n  });\n  reversedInterceptors.forEach(function (_ref2) {\n    var response = _ref2.response,\n      responseError = _ref2.responseError;\n    if (response || responseError) {\n      promise = promise.then(function (res) {\n        return response(fetchId, res);\n      }, function (err) {\n        return responseError && responseError(fetchId, err);\n      });\n    }\n  });\n  return promise;\n}\nfunction attach(env) {\n  if (!env.fetch || !env.Promise) {\n    // Make sure fetch is available in the given environment. If it's not, then\n    // default to using XHR intercept.\n    return;\n  }\n  var isPolyfill = env.fetch.polyfill;\n\n  // eslint-disable-next-line no-param-reassign\n  env.fetch = function (fetch) {\n    var fetchId = 0;\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return makeInterceptor.apply(void 0, [fetch, fetchId++].concat(args));\n    };\n  }(env.fetch);\n\n  // Forward the polyfill properly from fetch (set by github/whatwg-fetch).\n  if (isPolyfill) {\n    // eslint-disable-next-line no-param-reassign\n    env.fetch.polyfill = isPolyfill;\n  }\n}\n\n// TODO: React Native\n//   attach(global);\n\nvar didAttach = false;\nvar _default = {\n  register: function register(interceptor) {\n    if (!didAttach) {\n      didAttach = true;\n      attach(window);\n    }\n    interceptors.push(interceptor);\n    return function () {\n      var index = interceptors.indexOf(interceptor);\n      if (index >= 0) {\n        interceptors.splice(index, 1);\n      }\n    };\n  },\n  clear: function clear() {\n    interceptors = [];\n  }\n};\nexports[\"default\"] = _default;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/network/src/index.js\":\n/*!**************************************************!*\\\n  !*** ./packages/@logrocket/network/src/index.js ***!\n  \\**************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_40486__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_40486__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = registerNetwork;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_40486__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _typeof2 = _interopRequireDefault(__nested_webpack_require_40486__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\nvar _registerFetch = _interopRequireDefault(__nested_webpack_require_40486__(/*! ./registerFetch */ \"./packages/@logrocket/network/src/registerFetch.js\"));\nvar _registerIonic = __nested_webpack_require_40486__(/*! ./registerIonic */ \"./packages/@logrocket/network/src/registerIonic.ts\");\nvar _registerNetworkInformation = _interopRequireDefault(__nested_webpack_require_40486__(/*! ./registerNetworkInformation */ \"./packages/@logrocket/network/src/registerNetworkInformation.js\"));\nvar _registerXHR = _interopRequireDefault(__nested_webpack_require_40486__(/*! ./registerXHR */ \"./packages/@logrocket/network/src/registerXHR.js\"));\nvar _mapValues = _interopRequireDefault(__nested_webpack_require_40486__(/*! @logrocket/utils/src/mapValues */ \"./packages/@logrocket/utils/src/mapValues.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// eslint-disable-line no-restricted-imports\n\nfunction registerNetwork(logger) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    isReactNative: false\n  };\n  var isReactNative = config.isReactNative,\n    shouldAugmentNPS = config.shouldAugmentNPS,\n    shouldParseXHRBlob = config.shouldParseXHRBlob;\n  var ignoredNetwork = {};\n\n  // truncate if > 4MB in size\n  var truncate = function truncate(data) {\n    var limit = 1024 * 1000 * 4;\n    var str = data;\n    if ((0, _typeof2.default)(data) === 'object' && data != null) {\n      var proto = Object.getPrototypeOf(data);\n      if (proto === Object.prototype || proto === null) {\n        // plain object - jsonify for the size check\n        str = JSON.stringify(data);\n      }\n    }\n    if (str && str.length && str.length > limit && typeof str === 'string') {\n      var beginning = str.substring(0, 1000);\n      return \"\".concat(beginning, \" ... LogRocket truncating to first 1000 characters.\\n      Keep data under 4MB to prevent truncation. https://docs.logrocket.com/reference/network\");\n    }\n    return data;\n  };\n  var addRequest = function addRequest(reqId, request) {\n    var method = request.method;\n    logger.addEvent('lr.network.RequestEvent', function () {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$isEnabled = _ref.isEnabled,\n        isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled,\n        _ref$requestSanitizer = _ref.requestSanitizer,\n        requestSanitizer = _ref$requestSanitizer === void 0 ? function (f) {\n          return f;\n        } : _ref$requestSanitizer;\n      if (!isEnabled) {\n        return null;\n      }\n      var sanitized = null;\n      try {\n        // only try catch user defined functions\n        sanitized = requestSanitizer(_objectSpread(_objectSpread({}, request), {}, {\n          reqId: reqId\n        }));\n      } catch (err) {\n        console.error(err);\n      }\n      if (sanitized) {\n        var url = sanitized.url;\n        if (typeof document !== 'undefined' && typeof document.createElement === 'function') {\n          // Writing and then reading from an a tag turns a relative\n          // url into an absolute one.\n          var a = document.createElement('a');\n          a.href = sanitized.url;\n          url = a.href;\n        }\n        return {\n          reqId: reqId,\n          // default\n          url: url,\n          // sanitized\n          headers: (0, _mapValues.default)(sanitized.headers, function (headerValue) {\n            // sanitized\n            return \"\".concat(headerValue);\n          }),\n          body: truncate(sanitized.body),\n          // sanitized\n          method: method,\n          // default\n          referrer: sanitized.referrer || undefined,\n          // sanitized\n          mode: sanitized.mode || undefined,\n          // sanitized\n          credentials: sanitized.credentials || undefined // sanitized\n        };\n      }\n\n      ignoredNetwork[reqId] = true;\n      return null;\n    });\n  };\n  var addResponse = function addResponse(reqId, response) {\n    var method = response.method,\n      status = response.status;\n    logger.addEvent('lr.network.ResponseEvent', function () {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$isEnabled = _ref2.isEnabled,\n        isEnabled = _ref2$isEnabled === void 0 ? true : _ref2$isEnabled,\n        _ref2$responseSanitiz = _ref2.responseSanitizer,\n        responseSanitizer = _ref2$responseSanitiz === void 0 ? function (f) {\n          return f;\n        } : _ref2$responseSanitiz;\n      if (!isEnabled) {\n        return null;\n      } else if (ignoredNetwork[reqId]) {\n        delete ignoredNetwork[reqId];\n        return null;\n      }\n      var sanitized = null;\n      try {\n        // only try catch user defined functions\n        sanitized = responseSanitizer(_objectSpread(_objectSpread({}, response), {}, {\n          reqId: reqId\n        }));\n      } catch (err) {\n        console.error(err);\n        // fall through to redacted log\n      }\n\n      if (sanitized) {\n        return {\n          reqId: reqId,\n          // default\n          status: sanitized.status,\n          // sanitized\n          headers: (0, _mapValues.default)(sanitized.headers, function (headerValue) {\n            // sanitized\n            return \"\".concat(headerValue);\n          }),\n          body: truncate(sanitized.body),\n          // sanitized\n          method: method // default\n        };\n      }\n\n      return {\n        reqId: reqId,\n        // default\n        status: status,\n        // default\n        headers: {},\n        // redacted\n        body: null,\n        // redacted\n        method: method // default\n      };\n    });\n  };\n\n  var isIgnored = function isIgnored(reqId) {\n    return logger.isDisabled || ignoredNetwork[reqId] === true;\n  };\n  var unsubFetch = (0, _registerFetch.default)({\n    addRequest: addRequest,\n    addResponse: addResponse,\n    isIgnored: isIgnored\n  });\n  var unsubXHR = (0, _registerXHR.default)({\n    addRequest: addRequest,\n    addResponse: addResponse,\n    isIgnored: isIgnored,\n    logger: logger,\n    shouldAugmentNPS: shouldAugmentNPS,\n    shouldParseXHRBlob: shouldParseXHRBlob\n  });\n  var unsubIonic = (0, _registerIonic.registerIonic)({\n    addRequest: addRequest,\n    addResponse: addResponse,\n    isIgnored: isIgnored\n  });\n  var unsubNetworkInformation = isReactNative ? function () {} : (0, _registerNetworkInformation.default)(logger);\n  return function () {\n    unsubNetworkInformation();\n    unsubFetch();\n    unsubXHR();\n    unsubIonic();\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/network/src/registerFetch.js\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/network/src/registerFetch.js ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_48638__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_48638__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = registerFetch;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_48638__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _mapValues = _interopRequireDefault(__nested_webpack_require_48638__(/*! @logrocket/utils/src/mapValues */ \"./packages/@logrocket/utils/src/mapValues.js\"));\nvar _fetchIntercept = _interopRequireDefault(__nested_webpack_require_48638__(/*! ./fetchIntercept */ \"./packages/@logrocket/network/src/fetchIntercept.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction makeObjectFromHeaders(headers) {\n  // If using real fetch, we must stringify the Headers object.\n  if (headers == null || typeof headers.forEach !== 'function') {\n    return headers;\n  }\n  var result = {};\n  headers.forEach(function (value, key) {\n    if (result[key]) {\n      result[key] = \"\".concat(result[key], \",\").concat(value);\n    } else {\n      result[key] = \"\".concat(value);\n    }\n  });\n  return result;\n}\n\n// XHR specification is unclear of what types to allow in value so using toString method for now\nvar stringifyHeaders = function stringifyHeaders(headers) {\n  return (0, _mapValues.default)(makeObjectFromHeaders(headers), function (value) {\n    return \"\".concat(value);\n  });\n};\nfunction pluckFetchFields() {\n  var arg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    url: arg.url,\n    headers: stringifyHeaders(arg.headers),\n    method: arg.method && arg.method.toUpperCase(),\n    referrer: arg.referrer || undefined,\n    mode: arg.mode || undefined,\n    credentials: arg.credentials || undefined\n  };\n}\nfunction registerFetch(_ref) {\n  var addRequest = _ref.addRequest,\n    addResponse = _ref.addResponse,\n    isIgnored = _ref.isIgnored;\n  var LOGROCKET_FETCH_LABEL = 'fetch-';\n  var fetchMethodMap = {};\n  var unregister = _fetchIntercept.default.register({\n    request: function request(fetchId) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      var p;\n      if (typeof Request !== 'undefined' && args[0] instanceof Request) {\n        var clonedText;\n\n        // Request.clone() and Request.text() may throw in Safari (e.g., when\n        // request body contains FormData)\n        try {\n          clonedText = args[0].clone().text();\n        } catch (err) {\n          // if a browser supports fetch, it supports promise\n          // eslint-disable-next-line compat/compat\n          clonedText = Promise.resolve(\"LogRocket fetch error: \".concat(err.message));\n        }\n        p = clonedText.then(function (body) {\n          return _objectSpread(_objectSpread({}, pluckFetchFields(args[0])), {}, {\n            body: body\n          });\n        }, function (err) {\n          return _objectSpread(_objectSpread({}, pluckFetchFields(args[0])), {}, {\n            body: \"LogRocket fetch error: \".concat(err.message)\n          });\n        });\n      } else {\n        // if a browser supports fetch, it supports promise\n        // eslint-disable-next-line compat/compat\n        p = Promise.resolve(_objectSpread(_objectSpread({}, pluckFetchFields(args[1])), {}, {\n          url: \"\".concat(args[0]),\n          body: (args[1] || {}).body\n        }));\n      }\n      return p.then(function (req) {\n        fetchMethodMap[fetchId] = req.method;\n        addRequest(\"\".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), req);\n        return args;\n      });\n    },\n    requestError: function requestError(fetchId, error) {\n      // if a browser supports fetch, it supports promise\n      // eslint-disable-next-line compat/compat\n      return Promise.reject(error);\n    },\n    response: function response(fetchId, _response) {\n      var responseClone;\n      var responseTextPromise;\n      if (isIgnored(\"\".concat(LOGROCKET_FETCH_LABEL).concat(fetchId))) {\n        // Don't even try to read ignored requests\n        return _response;\n      }\n      try {\n        // TODO: enhance function on original response and future clones for:\n        // text(), json(), blob(), formdata(), arraybuffer()\n        responseClone = _response.clone();\n      } catch (err) {\n        // safari has a bug where cloning can fail\n        var responseHash = {\n          url: _response.url,\n          status: _response.status,\n          headers: stringifyHeaders(_response.headers),\n          body: \"LogRocket fetch error: \".concat(err.message),\n          method: fetchMethodMap[fetchId]\n        };\n        delete fetchMethodMap[fetchId];\n        addResponse(\"\".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), responseHash);\n        return _response;\n      }\n      try {\n        if (window.TextDecoder && responseClone.body) {\n          // use a reader to manually read the response body rather than calling response.text()\n          // response.text() was timing out for some responses, in some cases because Apollo sends\n          //   an abort signal or because the stream wasn't getting terminated cleanly\n          // using a reader allows us to capture what we can from response bodies before the\n          //   response receives an abort signal\n          var reader = responseClone.body.getReader();\n          // response bodies always decode with UTF-8\n          // https://developer.mozilla.org/en-US/docs/Web/API/Response/text\n          var utf8Decoder = new window.TextDecoder('utf-8');\n          var bodyContents = '';\n          responseTextPromise = reader.read().then(function readResponseBody(_ref2) {\n            var done = _ref2.done,\n              value = _ref2.value;\n            if (done) {\n              return bodyContents;\n            }\n            var chunk = value ? utf8Decoder.decode(value, {\n              stream: true\n            }) : '';\n            bodyContents += chunk;\n            return reader.read().then(readResponseBody);\n          });\n        } else {\n          // TextDecoder doesn't have support across all browsers that LR supports, so if there's\n          //  no TextDecoder, fall back to the old approach\n          responseTextPromise = responseClone.text();\n        }\n      } catch (error) {\n        // eslint-disable-next-line compat/compat\n        responseTextPromise = Promise.resolve(\"LogRocket error reading body: \".concat(error.message));\n      }\n      responseTextPromise.catch(function (error) {\n        // don't drop request & log to console when the request is aborted,\n        // as it may have already completed\n        // https://github.com/LogRocket/logrocket/issues/34\n        if (error.name === 'AbortError' && error instanceof DOMException) {\n          return;\n        }\n        return \"LogRocket error reading body: \".concat(error.message);\n      }).then(function (data) {\n        var responseHash = {\n          url: _response.url,\n          status: _response.status,\n          headers: stringifyHeaders(_response.headers),\n          body: data,\n          method: fetchMethodMap[fetchId]\n        };\n        delete fetchMethodMap[fetchId];\n        addResponse(\"\".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), responseHash);\n      });\n      return _response;\n    },\n    responseError: function responseError(fetchId, error) {\n      var response = {\n        url: undefined,\n        status: 0,\n        headers: {},\n        body: \"\".concat(error)\n      };\n      addResponse(\"\".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), response);\n      // if a browser supports fetch, it supports promise\n      // eslint-disable-next-line compat/compat\n      return Promise.reject(error);\n    }\n  });\n  return unregister;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/network/src/registerIonic.ts\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/network/src/registerIonic.ts ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_57609__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_57609__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.mergeHeaders = mergeHeaders;\nexports.serializeQueryParams = serializeQueryParams;\nexports.appendQueryParamsString = appendQueryParamsString;\nexports.processData = processData;\nexports.registerIonic = registerIonic;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_57609__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _typeof2 = _interopRequireDefault(__nested_webpack_require_57609__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\nvar _toConsumableArray2 = _interopRequireDefault(__nested_webpack_require_57609__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\nvar _protectFunc = _interopRequireDefault(__nested_webpack_require_57609__(/*! @logrocket/utils/src/protectFunc */ \"./packages/@logrocket/utils/src/protectFunc.js\"));\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar VALID_HTTP_METHODS = new Set(['get', 'put', 'post', 'patch', 'head', 'delete', 'options', 'upload', 'download']);\nvar VALID_SERIALIZERS = new Set(['urlencoded', 'json', 'utf8']);\nvar UNSUPPORTED_SERIALIZERS = new Set(['raw', 'multipart']);\nvar LOGROCKET_IONIC_LABEL = 'ionic-';\nvar UNSUPPORTED_PLATFORMS = new Set(['desktop', 'mobileweb', 'pwa']);\nvar FORM_DATA = new Set(['FormData']);\nvar EMPTY_SET = new Set();\nvar STRING_SET = new Set(['string']);\nvar STRING_ARRAY_SET = new Set(['string', 'array']);\nvar ALLOWED_DATA_TYPES = {\n  utf8: STRING_SET,\n  urlencoded: new Set(['object']),\n  json: new Set(['array', 'object']),\n  raw: new Set(['Uint8Array', 'ArrayBuffer']),\n  default: EMPTY_SET\n};\n\n// Used in intercepting Ionic pugin requests found here https://www.npmjs.com/package/@ionic-native/http\n// based on https://github.com/silkimen/cordova-plugin-advanced-http/blob/master/www/public-interface.js\n\nfunction checkForValidStringValue(list, value, fieldName) {\n  if (typeof value !== 'string') {\n    throw new Error(\"\".concat(fieldName, \" must be one of: \").concat((0, _toConsumableArray2.default)(list).join(', ')));\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  value = value.trim().toLowerCase();\n  if (!list.has(value)) {\n    throw new Error(\"\".concat(fieldName, \" must be one of: \").concat((0, _toConsumableArray2.default)(list).join(', ')));\n  }\n  return value;\n}\nfunction checkKeyValuePairObject(obj, allowedChildren, onInvalidValueMessage) {\n  if ((0, _typeof2.default)(obj) !== 'object') {\n    throw new Error(onInvalidValueMessage);\n  }\n  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    if (!allowedChildren.has((0, _typeof2.default)(obj[key]))) {\n      throw new Error(onInvalidValueMessage);\n    }\n  }\n  return obj;\n}\nfunction getMatchingHostHeaders(url, ionicHttp) {\n  var _URL = new URL(url),\n    host = _URL.host;\n  return ionicHttp.getHeaders(host) || null;\n}\nfunction mergeHeaders(defaultHeaders, headers) {\n  return _objectSpread(_objectSpread({}, defaultHeaders), headers);\n}\nfunction getMergedHeaders(url, requestHeaders, ionicHttp) {\n  // get global headers via public method\n  var globalHeaders = ionicHttp.getHeaders('*') || {};\n  var hostHeaders = getMatchingHostHeaders(url, ionicHttp) || {};\n  return mergeHeaders(mergeHeaders(globalHeaders, hostHeaders), requestHeaders);\n}\nfunction serializeValue(value, encode) {\n  if (encode) {\n    return encodeURIComponent(value);\n  } else {\n    return value;\n  }\n}\nfunction serializeIdentifier(parentKey, key, encode) {\n  if (!parentKey.length) {\n    return encode ? encodeURIComponent(key) : key;\n  }\n  if (encode) {\n    return \"\".concat(encodeURIComponent(parentKey), \"[\").concat(encodeURIComponent(key), \"]\");\n  } else {\n    return \"\".concat(parentKey, \"[\").concat(key, \"]\");\n  }\n}\nfunction serializeArray(parentKey, array, encode) {\n  var parts = [];\n  var _iterator = _createForOfIteratorHelper(array),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var e = _step.value;\n      if (Array.isArray(e)) {\n        parts.push(serializeArray(\"\".concat(parentKey, \"[]\"), e, encode));\n        continue;\n      } else if ((0, _typeof2.default)(e) === 'object') {\n        /* This replicates what appears to be a bug in the Ionic code in order to capture everything identically\n           parts.push(serializeObject(`${parentKey}[]${array[i]}`, encode));\n           https://github.com/silkimen/cordova-plugin-advanced-http/blob/master/www/url-util.js#L73\n        */\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        parts.push(serializeObject(\"\".concat(parentKey, \"[]\").concat(e), encode, undefined));\n        continue;\n      }\n      parts.push(\"\".concat(serializeIdentifier(parentKey, '', encode), \"=\").concat(serializeValue(e, encode)));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return parts.join('&');\n}\nfunction serializeObject(parentKey, object, encode) {\n  var parts = [];\n  for (var key in object) {\n    if (!object.hasOwnProperty(key)) {\n      continue;\n    }\n    var identifier = parentKey.length ? \"\".concat(parentKey, \"[\").concat(key, \"]\") : key;\n    if (Array.isArray(object[key])) {\n      parts.push(serializeArray(identifier, object[key], encode));\n      continue;\n    } else if ((0, _typeof2.default)(object[key]) === 'object' && object[key] !== null) {\n      parts.push(serializeObject(identifier, object[key], encode));\n      continue;\n    }\n    parts.push(\"\".concat(serializeIdentifier(parentKey, key, encode), \"=\").concat(serializeValue(object[key], encode)));\n  }\n  return parts.join('&');\n}\nfunction serializeQueryParams(params, encode) {\n  return serializeObject('', params, encode);\n}\nfunction appendQueryParamsString(url, params) {\n  if (!url.length || !params.length) {\n    return url;\n  }\n  var _URL2 = new URL(url),\n    host = _URL2.host,\n    pathname = _URL2.pathname,\n    search = _URL2.search,\n    hash = _URL2.hash,\n    protocol = _URL2.protocol;\n  return \"\".concat(protocol, \"//\").concat(host).concat(pathname).concat(search.length ? \"\".concat(search, \"&\").concat(params) : \"?\".concat(params)).concat(hash);\n}\nfunction getAllowedDataTypes(dataSerializer) {\n  return ALLOWED_DATA_TYPES[dataSerializer] || ALLOWED_DATA_TYPES.default;\n}\nfunction getAllowedInstanceTypes(dataSerializer) {\n  return dataSerializer === 'multipart' ? FORM_DATA : EMPTY_SET;\n}\nfunction processData(data, dataSerializer) {\n  var currentDataType = (0, _typeof2.default)(data);\n  var allowedDataTypes = getAllowedDataTypes(dataSerializer);\n  var allowedInstanceTypes = getAllowedInstanceTypes(dataSerializer);\n  if (allowedInstanceTypes.size > 0) {\n    var isCorrectInstanceType = false;\n    allowedInstanceTypes.forEach(function (type) {\n      if (__nested_webpack_require_57609__.g[type] && data instanceof __nested_webpack_require_57609__.g[type]) {\n        isCorrectInstanceType = true;\n      }\n    });\n    if (!isCorrectInstanceType) {\n      throw new Error(\"INSTANCE_TYPE_MISMATCH_DATA \".concat((0, _toConsumableArray2.default)(allowedInstanceTypes).join(', ')));\n    }\n  }\n  if (allowedInstanceTypes.size === 0 && !allowedDataTypes.has(currentDataType)) {\n    throw new Error(\"TYPE_MISMATCH_DATA \".concat((0, _toConsumableArray2.default)(allowedDataTypes).join(', ')));\n  }\n  switch (dataSerializer) {\n    case 'utf8':\n      // already a string\n      return data;\n    default:\n      // object of some sort (urlencoded or json)\n      return JSON.stringify(data, undefined, 2);\n  }\n}\nfunction handleMissingOptions(options, ionicHttp) {\n  // eslint-disable-next-line no-param-reassign\n  options = options || {};\n  var serializer;\n  var data = options.data;\n  try {\n    // need to check special case if data type is not handled by LR but otherwise valid\n    serializer = checkForValidStringValue(VALID_SERIALIZERS, options.serializer || ionicHttp.getDataSerializer(), 'serializer / data payload type');\n  } catch (_unused) {\n    // if this fails it's of entirely invalid type, let it fail\n    serializer = checkForValidStringValue(UNSUPPORTED_SERIALIZERS, options.serializer || ionicHttp.getDataSerializer(), 'serializer / data payload type');\n    // is of a valid but unsupported to LR type, set data to empty\n    data = {};\n  }\n  return {\n    data: data,\n    filePath: options.filePath,\n    followRedirect: options.followRedirect,\n    headers: checkKeyValuePairObject(options.headers || {}, STRING_SET, 'Invalid header type, must be string'),\n    method: checkForValidStringValue(VALID_HTTP_METHODS, options.method || VALID_HTTP_METHODS[0], 'method'),\n    name: options.name,\n    params: checkKeyValuePairObject(options.params || {}, STRING_ARRAY_SET, 'Invalid param, must be of type string or array'),\n    responseType: options.responseType,\n    serializer: serializer,\n    connectTimeout: options.connectTimeout,\n    readTimeout: options.readTimeout,\n    timeout: options.timeout\n  };\n}\nvar ionicIdCounter = 0;\nfunction registerIonic(_ref) {\n  var _cordova, _cordova$plugin, _window$ionic;\n  var addRequest = _ref.addRequest,\n    addResponse = _ref.addResponse,\n    isIgnored = _ref.isIgnored;\n  var ionicHttp = (_cordova = window.cordova) === null || _cordova === void 0 ? void 0 : (_cordova$plugin = _cordova.plugin) === null || _cordova$plugin === void 0 ? void 0 : _cordova$plugin.http;\n  var ionicMap = {};\n  var unsubscribedFromIonic = false;\n  if (typeof ionicHttp === 'undefined') {\n    // Plugin does not exist! Empty uninstall hook.\n    return function () {};\n  }\n  var platforms = (_window$ionic = window.ionic) === null || _window$ionic === void 0 ? void 0 : _window$ionic.platforms;\n  if (typeof platforms !== 'undefined' && typeof platforms.some === 'function' && platforms.some(function (e) {\n    return UNSUPPORTED_PLATFORMS.has(e);\n  })) {\n    // We appear to be running in a web browser, do not hook and let XHR wrap instead.\n    return function () {};\n  }\n  var originalSendRequest = ionicHttp.sendRequest;\n  var handleResponse = (0, _protectFunc.default)(function (response, isSuccess, ionicReqId) {\n    if (!isIgnored(\"\".concat(LOGROCKET_IONIC_LABEL).concat(ionicReqId))) {\n      try {\n        var responseHash = {\n          url: response.url || '',\n          status: response.status < 600 && response.status >= 100 ? response.status : 0,\n          headers: response.headers || {},\n          body: isSuccess ? response.data : response.error,\n          method: ionicMap[ionicReqId].toUpperCase()\n        };\n        addResponse(\"\".concat(LOGROCKET_IONIC_LABEL).concat(ionicReqId), responseHash);\n      } catch (err) {\n        var _responseHash = {\n          url: response.url || '',\n          status: response.status < 600 && response.status >= 100 ? response.status : 0,\n          headers: response.headers || {},\n          body: \"LogRocket fetch error: \".concat(err.message),\n          method: ionicMap[ionicReqId].toUpperCase()\n        };\n        addResponse(\"\".concat(LOGROCKET_IONIC_LABEL).concat(ionicReqId), _responseHash);\n      }\n    } // Otherwise, don't even try to read ignored / unsubscribed requests\n  });\n\n  ionicHttp.sendRequest = function (url, options, success, failure) {\n    var currentId = ++ionicIdCounter;\n    var ourSuccessHandler = function ourSuccessHandler(response) {\n      if (!unsubscribedFromIonic) {\n        handleResponse(response, true, currentId);\n        delete ionicMap[currentId];\n      }\n      success(response);\n    };\n    var ourFailureHandler = function ourFailureHandler(response) {\n      if (!unsubscribedFromIonic) {\n        handleResponse(response, false, currentId);\n        delete ionicMap[currentId];\n      }\n      failure(response);\n    };\n    if (!unsubscribedFromIonic) {\n      try {\n        // will throw just like identical ionic code if input is invalid\n        var modifiedOptions = handleMissingOptions(options, ionicHttp);\n        var modifiedUrl = appendQueryParamsString(url, serializeObject('', modifiedOptions.params, true));\n        // need to minic behavior of Ionic API by adding global headers\n        var mergedHeaders = getMergedHeaders(url, modifiedOptions.headers, ionicHttp);\n\n        // ionic APIs default to get method\n        var method = modifiedOptions.method || 'get';\n        ionicMap[currentId] = method;\n        var requestHash = {\n          url: modifiedUrl,\n          method: method.toUpperCase(),\n          headers: mergedHeaders || {},\n          // only applicable on post, put or patch methods\n          body: processData(modifiedOptions.data || {}, modifiedOptions.serializer)\n        };\n        addRequest(\"\".concat(LOGROCKET_IONIC_LABEL).concat(currentId), requestHash);\n      } catch (err) {\n        var _requestHash = {\n          url: url,\n          method: (options.method || 'get').toUpperCase(),\n          headers: {},\n          body: \"LogRocket fetch error: \".concat(err.message)\n        };\n        addRequest(\"\".concat(LOGROCKET_IONIC_LABEL).concat(currentId), _requestHash);\n      }\n    }\n    return originalSendRequest(url, options, ourSuccessHandler, ourFailureHandler);\n  };\n  return function () {\n    unsubscribedFromIonic = true;\n    ionicHttp.sendRequest = originalSendRequest;\n    ionicMap = {};\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/network/src/registerNetworkInformation.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/network/src/registerNetworkInformation.js ***!\n  \\***********************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = registerNetworkInformation;\nvar EFFECTIVE_TYPE_VALS = {\n  'slow-2g': 'SLOW2G',\n  '2g': 'TWOG',\n  '3g': 'THREEG',\n  '4g': 'FOURG'\n};\nfunction registerNetworkInformation(logger) {\n  var lastStatus = undefined;\n  function sendNetworkInformation() {\n    var newStatus = {\n      online: window.navigator.onLine,\n      effectiveType: 'UNKOWN'\n    };\n    if (!window.navigator.onLine) {\n      newStatus.effectiveType = 'NONE';\n    } else if (window.navigator.connection && window.navigator.connection.effectiveType) {\n      newStatus.effectiveType = EFFECTIVE_TYPE_VALS[window.navigator.connection.effectiveType] || 'UNKNOWN';\n    }\n    if (lastStatus && newStatus.online === lastStatus.online && newStatus.effectiveType === lastStatus.effectiveType) {\n      return;\n    }\n    lastStatus = newStatus;\n    logger.addEvent('lr.network.NetworkStatusEvent', function () {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$isEnabled = _ref.isEnabled,\n        isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled;\n      if (!isEnabled) {\n        return null;\n      }\n      return newStatus;\n    });\n  }\n  setTimeout(sendNetworkInformation);\n  if (window.navigator.connection && typeof window.navigator.connection.addEventListener === 'function') {\n    window.navigator.connection.addEventListener('change', sendNetworkInformation);\n  }\n  window.addEventListener('online', sendNetworkInformation);\n  window.addEventListener('offline', sendNetworkInformation);\n  return function () {\n    window.removeEventListener('offline', sendNetworkInformation);\n    window.removeEventListener('online', sendNetworkInformation);\n    if (window.navigator.connection && typeof window.navigator.connection.removeEventListener === 'function') {\n      window.navigator.connection.removeEventListener('change', sendNetworkInformation);\n    }\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/network/src/registerXHR.js\":\n/*!********************************************************!*\\\n  !*** ./packages/@logrocket/network/src/registerXHR.js ***!\n  \\********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_76053__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_76053__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.setActive = setActive;\nexports[\"default\"] = registerXHR;\nvar _mapValues = _interopRequireDefault(__nested_webpack_require_76053__(/*! @logrocket/utils/src/mapValues */ \"./packages/@logrocket/utils/src/mapValues.js\"));\nvar _enhanceFunc = _interopRequireDefault(__nested_webpack_require_76053__(/*! @logrocket/utils/src/enhanceFunc */ \"./packages/@logrocket/utils/src/enhanceFunc.js\"));\nvar _startsWith = _interopRequireDefault(__nested_webpack_require_76053__(/*! @logrocket/utils/src/startsWith */ \"./packages/@logrocket/utils/src/startsWith.js\"));\nvar _nps = __nested_webpack_require_76053__(/*! @logrocket/utils/src/constants/nps */ \"./packages/@logrocket/utils/src/constants/nps.js\");\n// eslint-disable-line no-restricted-imports\n// eslint-disable-line no-restricted-imports\n// eslint-disable-line no-restricted-imports\n\nvar isActive = true;\nfunction setActive(shouldBeActive) {\n  isActive = shouldBeActive;\n}\nvar currentXHRId = 0;\nfunction registerXHR(_ref) {\n  var addRequest = _ref.addRequest,\n    addResponse = _ref.addResponse,\n    isIgnored = _ref.isIgnored,\n    logger = _ref.logger,\n    _ref$shouldAugmentNPS = _ref.shouldAugmentNPS,\n    shouldAugmentNPS = _ref$shouldAugmentNPS === void 0 ? true : _ref$shouldAugmentNPS,\n    _ref$shouldParseXHRBl = _ref.shouldParseXHRBlob,\n    shouldParseXHRBlob = _ref$shouldParseXHRBl === void 0 ? false : _ref$shouldParseXHRBl;\n  var _XHR = XMLHttpRequest;\n  var xhrMap = new WeakMap();\n  var unsubscribedFromXhr = false;\n  var LOGROCKET_XHR_LABEL = 'xhr-';\n  window._lrXMLHttpRequest = XMLHttpRequest;\n\n  // eslint-disable-next-line no-native-reassign\n  XMLHttpRequest = function XMLHttpRequest(mozAnon, mozSystem) {\n    var xhrObject = new _XHR(mozAnon, mozSystem);\n    if (!isActive) {\n      return xhrObject;\n    }\n    xhrMap.set(xhrObject, {\n      xhrId: ++currentXHRId,\n      headers: {}\n    });\n    var openOriginal = xhrObject.open;\n    function openShim() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      try {\n        var url = args[1];\n        if (window.URL && typeof window.URL === 'function' && url.search(_nps.WOOTRIC_RESPONSES_REGEX) === 0) {\n          var logrocketSessionURL = new window.URL(logger.recordingURL);\n          logrocketSessionURL.searchParams.set('nps', 'wootric');\n          var urlObj = new window.URL(url);\n          var responseText = urlObj.searchParams.get('response[text]');\n          var feedback = responseText ? \"\".concat(responseText, \"\\n\\n\") : '';\n          urlObj.searchParams.set('response[text]', \"\".concat(feedback, \"<\").concat(logrocketSessionURL.href, \"|View LogRocket session>\"));\n          args[1] = urlObj.href; // eslint-disable-line no-param-reassign\n        }\n      } catch (e) {/* do nothing */}\n      return openOriginal.apply(this, args);\n    }\n    var sendOriginal = xhrObject.send;\n    function sendShim() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      try {\n        var currentXHR = xhrMap.get(xhrObject);\n        if (window.URL && typeof window.URL === 'function' && currentXHR && currentXHR.url && currentXHR.url.search(_nps.DELIGHTED_RESPONSES_REGEX) === 0 && args.length && args[0].indexOf(_nps.DELIGHTED_FEEDBACK_PREFIX) !== -1) {\n          var recordingURL = new window.URL(logger.recordingURL);\n          recordingURL.searchParams.set('nps', 'delighted');\n          var logrocketSessionURL = encodeURIComponent(recordingURL.href);\n          var data = args[0].split('&').map(function (dataString) {\n            if ((0, _startsWith.default)(dataString, _nps.DELIGHTED_FEEDBACK_PREFIX)) {\n              var isEmpty = dataString === _nps.DELIGHTED_FEEDBACK_PREFIX;\n              return \"\".concat(dataString).concat(isEmpty ? '' : '\\n\\n', \"<\").concat(logrocketSessionURL, \"|View LogRocket session>\");\n            }\n            return dataString;\n          }).join('&');\n          args[0] = data; // eslint-disable-line no-param-reassign\n        }\n      } catch (e) {/* do nothing */}\n      return sendOriginal.apply(this, args);\n    }\n    if (shouldAugmentNPS) {\n      xhrObject.open = openShim;\n      xhrObject.send = sendShim;\n    }\n\n    // ..., 'open', (method, url, async, username, password) => {\n    (0, _enhanceFunc.default)(xhrObject, 'open', function (method, url) {\n      if (unsubscribedFromXhr) {\n        return;\n      }\n      var currentXHR = xhrMap.get(xhrObject);\n      currentXHR.method = method;\n      currentXHR.url = url;\n    });\n    (0, _enhanceFunc.default)(xhrObject, 'send', function (data) {\n      if (unsubscribedFromXhr) {\n        return;\n      }\n      var currentXHR = xhrMap.get(xhrObject);\n      if (!currentXHR) {\n        return;\n      }\n      var request = {\n        url: currentXHR.url,\n        method: currentXHR.method && currentXHR.method.toUpperCase(),\n        headers: (0, _mapValues.default)(currentXHR.headers || {}, function (headerValues) {\n          return headerValues.join(', ');\n        }),\n        body: data\n      };\n      addRequest(\"\".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), request);\n    });\n    (0, _enhanceFunc.default)(xhrObject, 'setRequestHeader', function (header, value) {\n      if (unsubscribedFromXhr) {\n        return;\n      }\n      var currentXHR = xhrMap.get(xhrObject);\n      if (!currentXHR) {\n        return;\n      }\n      currentXHR.headers = currentXHR.headers || {};\n      currentXHR.headers[header] = currentXHR.headers[header] || [];\n      currentXHR.headers[header].push(value);\n    });\n    var xhrListeners = {\n      readystatechange: function readystatechange() {\n        if (unsubscribedFromXhr) {\n          return;\n        }\n        if (xhrObject.readyState === 4) {\n          var currentXHR = xhrMap.get(xhrObject);\n          if (!currentXHR) {\n            return;\n          }\n\n          // Do not read ignored requests at all.\n          if (isIgnored(\"\".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId))) {\n            return;\n          }\n          var headerString = xhrObject.getAllResponseHeaders() || '';\n          var headers = headerString.split(/[\\r\\n]+/).reduce(function (previous, current) {\n            var next = previous;\n            var headerParts = current.split(': ');\n            if (headerParts.length > 0) {\n              var key = headerParts.shift(); // first index of the array\n              var value = headerParts.join(': '); // rest of the array repaired\n              if (previous[key]) {\n                next[key] += \", \".concat(value);\n              } else {\n                next[key] = value;\n              }\n            }\n            return next;\n          }, {});\n          var body;\n\n          // IE 11 sometimes throws when trying to access large responses\n          try {\n            switch (xhrObject.responseType) {\n              case 'json':\n                body = logger._shouldCloneResponse ? JSON.parse(JSON.stringify(xhrObject.response)) : xhrObject.response;\n                break;\n              case 'arraybuffer':\n              case 'blob':\n                {\n                  body = xhrObject.response;\n                  break;\n                }\n              case 'document':\n                {\n                  body = xhrObject.responseXML;\n                  break;\n                }\n              case 'text':\n              case '':\n                {\n                  body = xhrObject.responseText;\n                  break;\n                }\n              default:\n                {\n                  body = '';\n                }\n            }\n          } catch (err) {\n            body = 'LogRocket: Error accessing response.';\n          }\n          var response = {\n            url: currentXHR.url,\n            status: xhrObject.status,\n            headers: headers,\n            body: body,\n            method: (currentXHR.method || '').toUpperCase()\n          };\n          if (shouldParseXHRBlob && response.body instanceof Blob) {\n            var blobReader = new FileReader();\n            blobReader.readAsText(response.body);\n            blobReader.onload = function () {\n              try {\n                response.body = JSON.parse(blobReader.result);\n              } catch (_unused) {} // eslint-disable-line no-empty\n              addResponse(\"\".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), response);\n            };\n          } else {\n            addResponse(\"\".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), response);\n          }\n        }\n      }\n      // // Unused Event Listeners\n      // loadstart: () => {},\n      // progress: () => {},\n      // abort: () => {},\n      // error: () => {},\n      // load: () => {},\n      // timeout: () => {},\n      // loadend: () => {},\n    };\n\n    Object.keys(xhrListeners).forEach(function (key) {\n      xhrObject.addEventListener(key, xhrListeners[key]);\n    });\n    return xhrObject;\n  };\n\n  // this allows \"instanceof XMLHttpRequest\" to work\n  XMLHttpRequest.prototype = _XHR.prototype;\n\n  // Persist the static variables.\n  ['UNSENT', 'OPENED', 'HEADERS_RECEIVED', 'LOADING', 'DONE'].forEach(function (variable) {\n    XMLHttpRequest[variable] = _XHR[variable];\n  });\n  return function () {\n    unsubscribedFromXhr = true;\n    // eslint-disable-next-line no-native-reassign\n    XMLHttpRequest = _XHR;\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/now/src/index.js\":\n/*!**********************************************!*\\\n  !*** ./packages/@logrocket/now/src/index.js ***!\n  \\**********************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n/* eslint-disable compat/compat */\nvar dateNow = Date.now.bind(Date);\nvar loadTime = dateNow();\nvar _default = typeof performance !== 'undefined' && performance.now ? performance.now.bind(performance) : function () {\n  return dateNow() - loadTime;\n};\nexports[\"default\"] = _default;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/redux/src/createEnhancer.js\":\n/*!*********************************************************!*\\\n  !*** ./packages/@logrocket/redux/src/createEnhancer.js ***!\n  \\*********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_86608__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_86608__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = createEnhancer;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_86608__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _now = _interopRequireDefault(__nested_webpack_require_86608__(/*! @logrocket/now */ \"./packages/@logrocket/now/src/index.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar storeIdCounter = 0;\nfunction createEnhancer(logger) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$stateSanitizer = _ref.stateSanitizer,\n    stateSanitizer = _ref$stateSanitizer === void 0 ? function (f) {\n      return f;\n    } : _ref$stateSanitizer,\n    _ref$actionSanitizer = _ref.actionSanitizer,\n    actionSanitizer = _ref$actionSanitizer === void 0 ? function (f) {\n      return f;\n    } : _ref$actionSanitizer;\n  // an enhancer is a function that returns a Store\n  return function (createStore) {\n    return function (reducer, initialState, enhancer) {\n      var store = createStore(reducer, initialState, enhancer);\n      var originalDispatch = store.dispatch;\n      var storeId = storeIdCounter++;\n      logger.addEvent('lr.redux.InitialState', function () {\n        var sanitizedState;\n        try {\n          // only try catch user defined functions\n          sanitizedState = stateSanitizer(store.getState());\n        } catch (err) {\n          console.error(err.toString());\n        }\n        return {\n          state: sanitizedState,\n          storeId: storeId\n        };\n      });\n      var dispatch = function dispatch(action) {\n        var start = (0, _now.default)();\n        var err;\n        var res;\n        try {\n          res = originalDispatch(action);\n        } catch (_err) {\n          err = _err;\n        } finally {\n          var duration = (0, _now.default)() - start;\n          logger.addEvent('lr.redux.ReduxAction', function () {\n            var sanitizedState = null;\n            var sanitizedAction = null;\n            try {\n              // only try catch user defined functions\n              sanitizedState = stateSanitizer(store.getState());\n              sanitizedAction = actionSanitizer(action);\n            } catch (err) {\n              console.error(err.toString());\n            }\n            if (sanitizedState && sanitizedAction) {\n              return {\n                storeId: storeId,\n                action: sanitizedAction,\n                duration: duration,\n                stateDelta: sanitizedState\n              };\n            }\n            return null;\n          });\n        }\n        if (err) {\n          throw err;\n        }\n        return res;\n      };\n      return _objectSpread(_objectSpread({}, store), {}, {\n        dispatch: dispatch\n      });\n    };\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/redux/src/createMiddleware.js\":\n/*!***********************************************************!*\\\n  !*** ./packages/@logrocket/redux/src/createMiddleware.js ***!\n  \\***********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_90764__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_90764__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = createMiddleware;\nvar _now = _interopRequireDefault(__nested_webpack_require_90764__(/*! @logrocket/now */ \"./packages/@logrocket/now/src/index.js\"));\nvar storeIdCounter = 0;\nfunction createMiddleware(logger) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$stateSanitizer = _ref.stateSanitizer,\n    stateSanitizer = _ref$stateSanitizer === void 0 ? function (f) {\n      return f;\n    } : _ref$stateSanitizer,\n    _ref$actionSanitizer = _ref.actionSanitizer,\n    actionSanitizer = _ref$actionSanitizer === void 0 ? function (f) {\n      return f;\n    } : _ref$actionSanitizer;\n  return function (store) {\n    var storeId = storeIdCounter++;\n    logger.addEvent('lr.redux.InitialState', function () {\n      var sanitizedState;\n      try {\n        // only try catch user defined functions\n        sanitizedState = stateSanitizer(store.getState());\n      } catch (err) {\n        console.error(err.toString());\n      }\n      return {\n        state: sanitizedState,\n        storeId: storeId\n      };\n    });\n    return function (next) {\n      return function (action) {\n        var start = (0, _now.default)();\n        var err;\n        var res;\n        try {\n          res = next(action);\n        } catch (_err) {\n          err = _err;\n        } finally {\n          var duration = (0, _now.default)() - start;\n          logger.addEvent('lr.redux.ReduxAction', function () {\n            var sanitizedState = null;\n            var sanitizedAction = null;\n            try {\n              // only try catch user defined functions\n              sanitizedState = stateSanitizer(store.getState());\n              sanitizedAction = actionSanitizer(action);\n            } catch (err) {\n              console.error(err.toString());\n            }\n            if (sanitizedState && sanitizedAction) {\n              return {\n                storeId: storeId,\n                action: sanitizedAction,\n                duration: duration,\n                stateDelta: sanitizedState\n              };\n            }\n            return null;\n          });\n        }\n        if (err) {\n          throw err;\n        }\n        return res;\n      };\n    };\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/redux/src/index.js\":\n/*!************************************************!*\\\n  !*** ./packages/@logrocket/redux/src/index.js ***!\n  \\************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_93499__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_93499__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"createEnhancer\", ({\n  enumerable: true,\n  get: function get() {\n    return _createEnhancer.default;\n  }\n}));\nObject.defineProperty(exports, \"createMiddleware\", ({\n  enumerable: true,\n  get: function get() {\n    return _createMiddleware.default;\n  }\n}));\nvar _createEnhancer = _interopRequireDefault(__nested_webpack_require_93499__(/*! ./createEnhancer */ \"./packages/@logrocket/redux/src/createEnhancer.js\"));\nvar _createMiddleware = _interopRequireDefault(__nested_webpack_require_93499__(/*! ./createMiddleware */ \"./packages/@logrocket/redux/src/createMiddleware.js\"));\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/TraceKit.js\":\n/*!***************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/TraceKit.js ***!\n  \\***************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_94639__) {\n\n\"use strict\";\n/* eslint-disable */\n\n\n\n/*\n TraceKit - Cross browser stack traces - github.com/occ/TraceKit\n\n This was originally forked from github.com/occ/TraceKit, but has since been\n largely re-written and is now maintained as part of raven-js.  Tests for\n this are in test/vendor.\n\n MIT license\n*/\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar TraceKit = {\n  collectWindowErrors: true,\n  debug: false\n};\n\n// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)\nvar _window = typeof window !== 'undefined' ? window : typeof __nested_webpack_require_94639__.g !== 'undefined' ? __nested_webpack_require_94639__.g : typeof self !== 'undefined' ? self : {};\n\n// global reference to slice\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nvar ERROR_TYPES_RE = /^(?:Uncaught (?:exception: )?)?((?:Eval|Internal|Range|Reference|Syntax|Type|URI)Error): ?(.*)$/;\nfunction getLocationHref() {\n  if (typeof document === 'undefined' || typeof document.location === 'undefined') return '';\n  return document.location.href;\n}\n\n/**\n * TraceKit.report: cross-browser processing of unhandled exceptions\n *\n * Syntax:\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *              on top frame; column number is not guaranteed\n *   - Opera:   full stack trace with line and column numbers\n *   - Chrome:  full stack trace with line and column numbers\n *   - Safari:  line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *   - IE:      line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a stackInfo object as described in the\n * TraceKit.computeStackTrace docs.\n */\nTraceKit.report = function reportModuleWrapper() {\n  var handlers = [],\n    lastArgs = null,\n    lastException = null,\n    lastExceptionStack = null;\n\n  /**\n   * Add a crash handler.\n   * @param {Function} handler\n   */\n  function subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n  }\n\n  /**\n   * Remove a crash handler.\n   * @param {Function} handler\n   */\n  function unsubscribe(handler) {\n    for (var i = handlers.length - 1; i >= 0; --i) {\n      if (handlers[i] === handler) {\n        handlers.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all crash handlers.\n   */\n  function unsubscribeAll() {\n    uninstallGlobalHandler();\n    handlers = [];\n  }\n\n  /**\n   * Dispatch stack information to all handlers.\n   * @param {Object.<string, *>} stack\n   */\n  function notifyHandlers(stack, isWindowError) {\n    var exception = null;\n    if (isWindowError && !TraceKit.collectWindowErrors) {\n      return;\n    }\n    for (var i in handlers) {\n      if (handlers.hasOwnProperty(i)) {\n        try {\n          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));\n        } catch (inner) {\n          exception = inner;\n        }\n      }\n    }\n    if (exception) {\n      throw exception;\n    }\n  }\n  var _oldOnerrorHandler, _onErrorHandlerInstalled;\n\n  /**\n   * Ensures all global unhandled exceptions are recorded.\n   * Supported by Gecko and IE.\n   * @param {string} message Error message.\n   * @param {string} url URL of script that generated the exception.\n   * @param {(number|string)} lineNo The line number at which the error\n   * occurred.\n   * @param {?(number|string)} colNo The column number at which the error\n   * occurred.\n   * @param {?Error} ex The actual Error object.\n   */\n  function traceKitWindowOnError(message, url, lineNo, colNo, ex) {\n    var stack = null;\n    if (lastExceptionStack) {\n      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n      processLastException();\n    } else if (ex) {\n      // New chrome and blink send along a real error object\n      // Let's just report that like a normal error.\n      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n      stack = TraceKit.computeStackTrace(ex);\n      notifyHandlers(stack, true);\n    } else {\n      var location = {\n        'url': url,\n        'line': lineNo,\n        'column': colNo\n      };\n      var name = undefined;\n      var msg = message; // must be new var or will modify original `arguments`\n      var groups;\n      if ({}.toString.call(message) === '[object String]') {\n        var groups = message.match(ERROR_TYPES_RE);\n        if (groups) {\n          name = groups[1];\n          msg = groups[2];\n        }\n      }\n      location.func = UNKNOWN_FUNCTION;\n      stack = {\n        'name': name,\n        'message': msg,\n        'url': getLocationHref(),\n        'stack': [location]\n      };\n      notifyHandlers(stack, true);\n    }\n    if (_oldOnerrorHandler) {\n      return _oldOnerrorHandler.apply(this, arguments);\n    }\n    return false;\n  }\n  function installGlobalHandler() {\n    if (_onErrorHandlerInstalled) {\n      return;\n    }\n    _oldOnerrorHandler = _window.onerror;\n    _window.onerror = traceKitWindowOnError;\n    _onErrorHandlerInstalled = true;\n  }\n  function uninstallGlobalHandler() {\n    if (!_onErrorHandlerInstalled) {\n      return;\n    }\n    _window.onerror = _oldOnerrorHandler;\n    _onErrorHandlerInstalled = false;\n    _oldOnerrorHandler = undefined;\n  }\n  function processLastException() {\n    var _lastExceptionStack = lastExceptionStack,\n      _lastArgs = lastArgs;\n    lastArgs = null;\n    lastExceptionStack = null;\n    lastException = null;\n    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));\n  }\n\n  /**\n   * Reports an unhandled Error to TraceKit.\n   * @param {Error} ex\n   * @param {?boolean} rethrow If false, do not re-throw the exception.\n   * Only used for window.onerror to not cause an infinite loop of\n   * rethrowing.\n   */\n  function report(ex, rethrow) {\n    var args = _slice.call(arguments, 1);\n    if (lastExceptionStack) {\n      if (lastException === ex) {\n        return; // already caught by an inner catch block, ignore\n      } else {\n        processLastException();\n      }\n    }\n    var stack = TraceKit.computeStackTrace(ex);\n    lastExceptionStack = stack;\n    lastException = ex;\n    lastArgs = args;\n\n    // If the stack trace is incomplete, wait for 2 seconds for\n    // slow slow IE to see if onerror occurs or not before reporting\n    // this exception; otherwise, we will end up with an incomplete\n    // stack trace\n    setTimeout(function () {\n      if (lastException === ex) {\n        processLastException();\n      }\n    }, stack.incomplete ? 2000 : 0);\n    if (rethrow !== false) {\n      throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n    }\n  }\n\n  report.subscribe = subscribe;\n  report.unsubscribe = unsubscribe;\n  report.uninstall = unsubscribeAll;\n  return report;\n}();\n\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n * Returns:\n *   s.name              - exception name\n *   s.message           - exception message\n *   s.stack[i].url      - JavaScript or HTML file URL\n *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)\n *   s.stack[i].args     - arguments passed to the function, if known\n *   s.stack[i].line     - line number, if known\n *   s.stack[i].column   - column number, if known\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n */\nTraceKit.computeStackTrace = function computeStackTraceWrapper() {\n  /**\n   * Escapes special characters, except for whitespace, in a string to be\n   * used inside a regular expression as a string literal.\n   * @param {string} text The string.\n   * @return {string} The escaped string literal.\n   */\n  function escapeRegExp(text) {\n    return text.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#]/g, '\\\\$&');\n  }\n\n  /**\n   * Escapes special characters in a string to be used inside a regular\n   * expression as a string literal. Also ensures that HTML entities will\n   * be matched the same as their literal friends.\n   * @param {string} body The string.\n   * @return {string} The escaped string.\n   */\n  function escapeCodeAsRegExpForMatchingInsideHTML(body) {\n    return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('\"', '(?:\"|&quot;)').replace(/\\s+/g, '\\\\s+');\n  }\n\n  // Contents of Exception in various browsers.\n  //\n  // SAFARI:\n  // ex.message = Can't find variable: qq\n  // ex.line = 59\n  // ex.sourceId = 580238192\n  // ex.sourceURL = http://...\n  // ex.expressionBeginOffset = 96\n  // ex.expressionCaretOffset = 98\n  // ex.expressionEndOffset = 98\n  // ex.name = ReferenceError\n  //\n  // FIREFOX:\n  // ex.message = qq is not defined\n  // ex.fileName = http://...\n  // ex.lineNumber = 59\n  // ex.columnNumber = 69\n  // ex.stack = ...stack trace... (see the example below)\n  // ex.name = ReferenceError\n  //\n  // CHROME:\n  // ex.message = qq is not defined\n  // ex.name = ReferenceError\n  // ex.type = not_defined\n  // ex.arguments = ['aa']\n  // ex.stack = ...stack trace...\n  //\n  // INTERNET EXPLORER:\n  // ex.message = ...\n  // ex.name = ReferenceError\n  //\n  // OPERA:\n  // ex.message = ...message... (see the example below)\n  // ex.name = ReferenceError\n  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n  /**\n   * Computes stack trace information from the stack property.\n   * Chrome and Gecko use this property.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceFromStackProp(ex) {\n    if (typeof ex.stack === 'undefined' || !ex.stack) return;\n    var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|<anonymous>).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i,\n      gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|resource|\\[native).*?)(?::(\\d+))?(?::(\\d+))?\\s*$/i,\n      winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i,\n      lines = ex.stack.split('\\n'),\n      stack = [],\n      parts,\n      element,\n      reference = /^(.*) is undefined$/.exec(ex.message);\n    for (var i = 0, j = lines.length; i < j; ++i) {\n      if (parts = chrome.exec(lines[i])) {\n        var isNative = parts[2] && parts[2].indexOf('native') !== -1;\n        element = {\n          'url': !isNative ? parts[2] : null,\n          'func': parts[1] || UNKNOWN_FUNCTION,\n          'args': isNative ? [parts[2]] : [],\n          'line': parts[3] ? +parts[3] : null,\n          'column': parts[4] ? +parts[4] : null\n        };\n      } else if (parts = winjs.exec(lines[i])) {\n        element = {\n          'url': parts[2],\n          'func': parts[1] || UNKNOWN_FUNCTION,\n          'args': [],\n          'line': +parts[3],\n          'column': parts[4] ? +parts[4] : null\n        };\n      } else if (parts = gecko.exec(lines[i])) {\n        element = {\n          'url': parts[3],\n          'func': parts[1] || UNKNOWN_FUNCTION,\n          'args': parts[2] ? parts[2].split(',') : [],\n          'line': parts[4] ? +parts[4] : null,\n          'column': parts[5] ? +parts[5] : null\n        };\n      } else {\n        continue;\n      }\n      if (!element.func && element.line) {\n        element.func = UNKNOWN_FUNCTION;\n      }\n      stack.push(element);\n    }\n    if (!stack.length) {\n      return null;\n    }\n    if (!stack[0].column && typeof ex.columnNumber !== 'undefined') {\n      // FireFox uses this awesome columnNumber property for its top frame\n      // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n      // so adding 1\n      stack[0].column = ex.columnNumber + 1;\n    }\n    return {\n      'name': ex.name,\n      'message': ex.message,\n      'url': getLocationHref(),\n      'stack': stack\n    };\n  }\n\n  /**\n   * Adds information about the first frame to incomplete stack traces.\n   * Safari and IE require this to get complete data on the first frame.\n   * @param {Object.<string, *>} stackInfo Stack trace information from\n   * one of the compute* methods.\n   * @param {string} url The URL of the script that caused an error.\n   * @param {(number|string)} lineNo The line number of the script that\n   * caused an error.\n   * @param {string=} message The error generated by the browser, which\n   * hopefully contains the name of the object that caused the error.\n   * @return {boolean} Whether or not the stack information was\n   * augmented.\n   */\n  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n    var initial = {\n      'url': url,\n      'line': lineNo\n    };\n    if (initial.url && initial.line) {\n      stackInfo.incomplete = false;\n      if (!initial.func) {\n        initial.func = UNKNOWN_FUNCTION;\n      }\n      if (stackInfo.stack.length > 0) {\n        if (stackInfo.stack[0].url === initial.url) {\n          if (stackInfo.stack[0].line === initial.line) {\n            return false; // already in stack trace\n          } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n            stackInfo.stack[0].line = initial.line;\n            return false;\n          }\n        }\n      }\n      stackInfo.stack.unshift(initial);\n      stackInfo.partial = true;\n      return true;\n    } else {\n      stackInfo.incomplete = true;\n    }\n    return false;\n  }\n\n  /**\n   * Computes stack trace information by walking the arguments.caller\n   * chain at the time the exception occurred. This will cause earlier\n   * frames to be missed but is the only way to get any stack trace in\n   * Safari and IE. The top frame is restored by\n   * {@link augmentStackTraceWithInitialElement}.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceByWalkingCallerChain(ex, depth) {\n    var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n      stack = [],\n      funcs = {},\n      recursion = false,\n      parts,\n      item,\n      source;\n    for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n      if (curr === computeStackTrace || curr === TraceKit.report) {\n        // console.log('skipping internal function');\n        continue;\n      }\n      item = {\n        'url': null,\n        'func': UNKNOWN_FUNCTION,\n        'line': null,\n        'column': null\n      };\n      if (curr.name) {\n        item.func = curr.name;\n      } else if (parts = functionName.exec(curr.toString())) {\n        item.func = parts[1];\n      }\n      if (typeof item.func === 'undefined') {\n        try {\n          item.func = parts.input.substring(0, parts.input.indexOf('{'));\n        } catch (e) {}\n      }\n      if (funcs['' + curr]) {\n        recursion = true;\n      } else {\n        funcs['' + curr] = true;\n      }\n      stack.push(item);\n    }\n    if (depth) {\n      // console.log('depth is ' + depth);\n      // console.log('stack is ' + stack.length);\n      stack.splice(0, depth);\n    }\n    var result = {\n      'name': ex.name,\n      'message': ex.message,\n      'url': getLocationHref(),\n      'stack': stack\n    };\n    augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n    return result;\n  }\n\n  /**\n   * Computes a stack trace for an exception.\n   * @param {Error} ex\n   * @param {(string|number)=} depth\n   */\n  function computeStackTrace(ex, depth) {\n    var stack = null;\n    depth = depth == null ? 0 : +depth;\n    try {\n      stack = computeStackTraceFromStackProp(ex);\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n    try {\n      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n    return {\n      'name': ex.name,\n      'message': ex.message,\n      'url': getLocationHref()\n    };\n  }\n  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n  return computeStackTrace;\n}();\nvar _default = TraceKit;\nexports[\"default\"] = _default;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/addListener.js\":\n/*!******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/addListener.js ***!\n  \\******************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = addListener;\nfunction addListener(type, handler) {\n  var obj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;\n  obj.addEventListener(type, handler, {\n    capture: true,\n    passive: true\n  });\n  return function () {\n    obj.removeEventListener(type, handler, {\n      capture: true,\n      passive: true\n    });\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/adjustOsVersion.ts\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/adjustOsVersion.ts ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.adjustOsVersion = adjustOsVersion;\nexports.adjustOs = adjustOs;\nfunction adjustOsVersion(osName, osVersionStr) {\n  var osVersion = osVersionStr;\n  if (osVersionStr && osName.toLowerCase().replace(/\\s/g, '').indexOf('macos') > -1) {\n    osVersion = osVersionStr.replace('10.15.7', '10.15.7+');\n  }\n  return osVersion;\n}\n\n// Used when os name and version are combined in 1 string, i.e. \"Mac OS X 10.15.7\"\nfunction adjustOs(os) {\n  return adjustOsVersion(os, os);\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/applyUrlSanitizer.js\":\n/*!************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/applyUrlSanitizer.js ***!\n  \\************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = applyUrlSanitizer;\nfunction applyUrlSanitizer(_ref) {\n  var logger = _ref.logger,\n    _ref$url = _ref.url,\n    url = _ref$url === void 0 ? '' : _ref$url;\n  var _ref2 = logger.getConfig('lr.browser') || {},\n    _ref2$urlSanitizer = _ref2.urlSanitizer,\n    urlSanitizer = _ref2$urlSanitizer === void 0 ? function (originalUrl) {\n      return originalUrl;\n    } : _ref2$urlSanitizer;\n  var sanitizedValue;\n  try {\n    sanitizedValue = urlSanitizer(url);\n  } catch (err) {\n    console.error(err);\n  }\n  if (typeof sanitizedValue === 'string') {\n    return sanitizedValue;\n  }\n\n  // if something went wrong or was set to null, redact completely\n  return '';\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/browserUtils.js\":\n/*!*******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/browserUtils.js ***!\n  \\*******************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getNodeName = getNodeName;\nexports.getTargetForEvent = getTargetForEvent;\nexports.getNodePath = getNodePath;\nfunction getNodeName(node) {\n  if (node.nodeName === '#document-fragment' && node.mode === 'open') {\n    return '$shadow-root';\n  } else if (node.nodeName) {\n    return node.nodeName.toLowerCase();\n  }\n  return '';\n}\nfunction getTargetForEvent(event) {\n  if (typeof event.composedPath === 'function' && event.composed) {\n    return event.composedPath()[0];\n  } else if (event.path) {\n    return event.path[0];\n  }\n  return event.target;\n}\n\n// maximum size of selector string, after which we no longer walk up the DOM tree to calculate\n// the node path. This cannot be larger than 2048\nvar SELECTOR_MAX_LENGTH = 1000;\nfunction getNodePath(element) {\n  var activeNode = element;\n  var nodePath = [];\n  var nodePathLength = 0;\n  while (activeNode && (activeNode.parentNode || activeNode.host)) {\n    var nodeName = getNodeName(activeNode);\n\n    // end at the body\n    if (nodeName === 'body') {\n      break;\n    }\n    var selector = {\n      nodeName: nodeName\n    };\n    var selectorLength = selector.nodeName.length;\n    if (activeNode.id && activeNode.id.length > 0) {\n      selector.id = activeNode.id;\n      selectorLength += activeNode.id.length;\n    }\n    if (activeNode.classList && activeNode.classList.length > 0) {\n      selector.classList = Array.prototype.slice.call(activeNode.classList, 0);\n      var classNames = Array.prototype.join.call(activeNode.classList, '');\n      // classNames sometimes is null\n      if (classNames) {\n        selectorLength += classNames.length;\n      }\n    }\n    if (nodePathLength + selectorLength > SELECTOR_MAX_LENGTH) {\n      break;\n    }\n\n    // IE11 may not have a children NodeList, and shadowRoots will not have a parentNode\n    if (activeNode.parentNode && activeNode.parentNode.children) {\n      try {\n        var nthChild = 0;\n        var siblingNode = activeNode;\n        do {\n          nthChild += 1;\n          siblingNode = siblingNode.previousElementSibling;\n        } while (siblingNode);\n        selector.nthChild = nthChild;\n      } catch (_) {\n        /* IE appears to provide a null/undefined value for children in some rare cases? */\n      }\n    }\n    nodePathLength += selectorLength;\n    nodePath.push(selector);\n    activeNode = activeNode.parentNode || activeNode.host;\n  }\n  return nodePath;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/constants/issues.ts\":\n/*!***********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/constants/issues.ts ***!\n  \\***********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_119801__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_119801__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ES_ISSUE_TYPE_BASE_FILTER = exports.ES_ISSUE_TYPES = exports.ISSUE_GROUP_TYPE = exports.ISSUE_TYPE = void 0;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_119801__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _ES_ISSUE_TYPE_BASE_F;\nvar ISSUE_TYPE = {\n  EXCEPTION: 'EXCEPTION',\n  NETWORK_ERROR: 'NETWORK_ERROR',\n  RAGE_CLICK: 'RAGE_CLICK',\n  DEAD_CLICK: 'DEAD_CLICK',\n  FRUSTRATING_NETWORK: 'FRUSTRATING_NETWORK',\n  ERROR_STATE: 'ERROR_STATE'\n};\nexports.ISSUE_TYPE = ISSUE_TYPE;\nvar ISSUE_GROUP_TYPE = {\n  ENCODED_FILTER: 'ENCODED_FILTER',\n  SENTRY: 'SENTRY',\n  TROYTOWN: 'TROYTOWN'\n};\nexports.ISSUE_GROUP_TYPE = ISSUE_GROUP_TYPE;\nvar ES_ISSUE_TYPES = [ISSUE_TYPE.RAGE_CLICK, ISSUE_TYPE.DEAD_CLICK, ISSUE_TYPE.FRUSTRATING_NETWORK, ISSUE_TYPE.ERROR_STATE];\nexports.ES_ISSUE_TYPES = ES_ISSUE_TYPES;\nvar ES_ISSUE_TYPE_BASE_FILTER = (_ES_ISSUE_TYPE_BASE_F = {}, (0, _defineProperty2.default)(_ES_ISSUE_TYPE_BASE_F, ISSUE_TYPE.RAGE_CLICK, {\n  rageClicked: {\n    operator: 'TEXT_IS',\n    strings: []\n  }\n}), (0, _defineProperty2.default)(_ES_ISSUE_TYPE_BASE_F, ISSUE_TYPE.DEAD_CLICK, {\n  deadClicked: {\n    operator: 'TEXT_IS',\n    strings: []\n  }\n}), _ES_ISSUE_TYPE_BASE_F);\nexports.ES_ISSUE_TYPE_BASE_FILTER = ES_ISSUE_TYPE_BASE_FILTER;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/constants/logTypes.js\":\n/*!*************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/constants/logTypes.js ***!\n  \\*************************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_121717__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_121717__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.LOG_FILTER_TYPES = exports.LOG_TYPES = void 0;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_121717__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _LOG_FILTER_TYPES;\nvar LOG_TYPES = {\n  LOG: 'LOG',\n  WARN: 'WARN',\n  ERROR: 'ERROR',\n  DEBUG: 'DEBUG',\n  INFO: 'INFO',\n  REDUX: 'REDUX',\n  LIFECYCLE: 'LIFECYCLE',\n  NAVIGATION: 'NAVIGATION',\n  NETWORK: 'NETWORK',\n  PREV_SESSION: 'PREV_SESSION',\n  NEXT_SESSION: 'NEXT_SESSION',\n  LOAD_MORE: 'LOAD_MORE',\n  EXCEPTION: 'EXCEPTION'\n};\nexports.LOG_TYPES = LOG_TYPES;\nvar LOG_FILTER_TYPES = (_LOG_FILTER_TYPES = {}, (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.LOG, {\n  label: 'Logs',\n  filterLabel: 'Log',\n  types: [LOG_TYPES.LOG]\n}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.WARN, {\n  label: 'Warnings',\n  filterLabel: 'Warning',\n  types: [LOG_TYPES.WARN]\n}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.ERROR, {\n  label: 'Errors',\n  filterLabel: 'Error',\n  types: [LOG_TYPES.ERROR, LOG_TYPES.EXCEPTION]\n}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.INFO, {\n  label: 'Info',\n  filterLabel: 'Info',\n  types: [LOG_TYPES.INFO]\n}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.DEBUG, {\n  label: 'Debug',\n  filterLabel: 'Debug',\n  types: [LOG_TYPES.DEBUG]\n}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.REDUX, {\n  label: 'Redux',\n  types: [LOG_TYPES.REDUX]\n}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.NAVIGATION, {\n  label: 'Navigation',\n  types: [LOG_TYPES.NAVIGATION, LOG_TYPES.LIFECYCLE]\n}), _LOG_FILTER_TYPES);\nexports.LOG_FILTER_TYPES = LOG_FILTER_TYPES;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/constants/metrics.js\":\n/*!************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/constants/metrics.js ***!\n  \\************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR = exports.DEFAULT_HEATMAP_FOR_URL_OPERATOR = exports.nextSortDirection = exports.SORT_DIRECTION = exports.FEEDBACK_SORT_COLUMN = exports.HEATMAP_FOR_URL_OPERATOR = exports.METRIC_RETENTION_TYPE = exports.METRIC_TIMESERIES_TYPE = void 0;\nvar METRIC_TIMESERIES_TYPE = {\n  SESSION_COUNT: 'SESSION_COUNT',\n  PERCENTILE: 'PERCENTILE',\n  CONVERSION_RATE: 'CONVERSION_RATE',\n  SESSION_PERCENTAGE: 'SESSION_PERCENTAGE',\n  ACTIVE_USERS: 'ACTIVE_USERS',\n  EVENT_COUNT: 'EVENT_COUNT'\n};\nexports.METRIC_TIMESERIES_TYPE = METRIC_TIMESERIES_TYPE;\nvar METRIC_RETENTION_TYPE = {\n  USER_PERCENTAGE: 'USER_PERCENTAGE'\n};\nexports.METRIC_RETENTION_TYPE = METRIC_RETENTION_TYPE;\nvar HEATMAP_FOR_URL_OPERATOR = {\n  IS: 'IS',\n  CONTAINS: 'CONTAINS',\n  LIKE: 'LIKE',\n  HREF_LIKE: 'HREF_LIKE'\n};\nexports.HEATMAP_FOR_URL_OPERATOR = HEATMAP_FOR_URL_OPERATOR;\nvar FEEDBACK_SORT_COLUMN = {\n  RATING: 'RATING',\n  SUBMISSION_DATE: 'SUBMISSION_DATE'\n};\nexports.FEEDBACK_SORT_COLUMN = FEEDBACK_SORT_COLUMN;\nvar SORT_DIRECTION = {\n  UNSET: 'UNSET',\n  ASC: 'ASC',\n  DESC: 'DESC'\n};\nexports.SORT_DIRECTION = SORT_DIRECTION;\nvar nextSortDirection = function nextSortDirection(direction) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$reverse = _ref.reverse,\n    reverse = _ref$reverse === void 0 ? false : _ref$reverse;\n  var UNSET = SORT_DIRECTION.UNSET,\n    ASC = SORT_DIRECTION.ASC,\n    DESC = SORT_DIRECTION.DESC;\n  var directionOptions = [UNSET, DESC, ASC];\n  if (reverse) {\n    directionOptions = [UNSET, ASC, DESC];\n  }\n  var index = directionOptions.indexOf(direction);\n  return directionOptions[(index + 1) % directionOptions.length];\n};\nexports.nextSortDirection = nextSortDirection;\nvar DEFAULT_HEATMAP_FOR_URL_OPERATOR = HEATMAP_FOR_URL_OPERATOR.IS;\nexports.DEFAULT_HEATMAP_FOR_URL_OPERATOR = DEFAULT_HEATMAP_FOR_URL_OPERATOR;\nvar DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR = HEATMAP_FOR_URL_OPERATOR.HREF_LIKE;\nexports.DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR = DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/constants/mobile.ts\":\n/*!***********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/constants/mobile.ts ***!\n  \\***********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MAXIMUM_SUPPORTED_VERSION = exports.MINIMUM_SUPPORTED_VERSION = exports.IOS_VERSION = exports.ANDROID_VERSION = void 0;\nvar ANDROID_VERSION = '1.25.0';\nexports.ANDROID_VERSION = ANDROID_VERSION;\nvar IOS_VERSION = '1.25.0';\n\n// Inclusive\nexports.IOS_VERSION = IOS_VERSION;\nvar MINIMUM_SUPPORTED_VERSION = '1.0.0';\n// Exclusive\nexports.MINIMUM_SUPPORTED_VERSION = MINIMUM_SUPPORTED_VERSION;\nvar MAXIMUM_SUPPORTED_VERSION = '1.26.0';\nexports.MAXIMUM_SUPPORTED_VERSION = MAXIMUM_SUPPORTED_VERSION;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/constants/nps.js\":\n/*!********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/constants/nps.js ***!\n  \\********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.DELIGHTED_FEEDBACK_PREFIX = exports.DELIGHTED_RESPONSES_REGEX = exports.WOOTRIC_RESPONSES_REGEX = void 0;\nvar WOOTRIC_RESPONSES_REGEX = /^https:\\/\\/production.wootric.com\\/responses/;\nexports.WOOTRIC_RESPONSES_REGEX = WOOTRIC_RESPONSES_REGEX;\nvar DELIGHTED_RESPONSES_REGEX = /^https:\\/\\/web.delighted.com\\/e\\/[a-zA-Z-]*\\/c/;\nexports.DELIGHTED_RESPONSES_REGEX = DELIGHTED_RESPONSES_REGEX;\nvar DELIGHTED_FEEDBACK_PREFIX = 'comment=';\nexports.DELIGHTED_FEEDBACK_PREFIX = DELIGHTED_FEEDBACK_PREFIX;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/constants/replayTypes.ts\":\n/*!****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/constants/replayTypes.ts ***!\n  \\****************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.REPLAY_TYPE = void 0;\nvar REPLAY_TYPE;\nexports.REPLAY_TYPE = REPLAY_TYPE;\n(function (REPLAY_TYPE) {\n  REPLAY_TYPE[\"SKIA\"] = \"SKIA\";\n  REPLAY_TYPE[\"DOM\"] = \"DOM\";\n  REPLAY_TYPE[\"PDF\"] = \"PDF\";\n})(REPLAY_TYPE || (exports.REPLAY_TYPE = REPLAY_TYPE = {}));\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/constants/sdkTypes.ts\":\n/*!*************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/constants/sdkTypes.ts ***!\n  \\*************************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_128982__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_128982__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SESSION_TYPE_TO_DISPLAY = exports.SDK_REPLAY_TYPE = exports.SDK_TYPE_TO_DISPLAY = exports.SDK_TYPE = void 0;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_128982__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _replayTypes = __nested_webpack_require_128982__(/*! ./replayTypes */ \"./packages/@logrocket/utils/src/constants/replayTypes.ts\");\nvar _SDK_TYPE_TO_DISPLAY, _SDK_REPLAY_TYPE;\n/*\n  SDK_TYPE should be imported as SESSION_TYPE based on how it is being used.\n  SDK_TYPE enumerates the supported sdkTypes from an ingestion/filtering perspective. sdkType is a\n  session data field in ES.\n  SESSION_TYPE is used to enumerate the supported sessionTypes for stripe plans, where we are\n  selling and managing your quota based on the sessionType of your stripe plan.\n*/\nvar SDK_TYPE;\nexports.SDK_TYPE = SDK_TYPE;\n(function (SDK_TYPE) {\n  SDK_TYPE[\"WEB\"] = \"web\";\n  SDK_TYPE[\"MOBILE\"] = \"mobile\";\n  SDK_TYPE[\"UNKNOWN\"] = \"unknown\";\n})(SDK_TYPE || (exports.SDK_TYPE = SDK_TYPE = {}));\nvar SDK_TYPE_TO_DISPLAY = (_SDK_TYPE_TO_DISPLAY = {}, (0, _defineProperty2.default)(_SDK_TYPE_TO_DISPLAY, SDK_TYPE.WEB, 'Web'), (0, _defineProperty2.default)(_SDK_TYPE_TO_DISPLAY, SDK_TYPE.MOBILE, 'Mobile'), _SDK_TYPE_TO_DISPLAY);\nexports.SDK_TYPE_TO_DISPLAY = SDK_TYPE_TO_DISPLAY;\nvar SDK_REPLAY_TYPE = (_SDK_REPLAY_TYPE = {}, (0, _defineProperty2.default)(_SDK_REPLAY_TYPE, SDK_TYPE.WEB, _replayTypes.REPLAY_TYPE.DOM), (0, _defineProperty2.default)(_SDK_REPLAY_TYPE, SDK_TYPE.MOBILE, _replayTypes.REPLAY_TYPE.SKIA), _SDK_REPLAY_TYPE);\nexports.SDK_REPLAY_TYPE = SDK_REPLAY_TYPE;\nvar SESSION_TYPE_TO_DISPLAY = SDK_TYPE_TO_DISPLAY;\nexports.SESSION_TYPE_TO_DISPLAY = SESSION_TYPE_TO_DISPLAY;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/constants/statusCodes.ts\":\n/*!****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/constants/statusCodes.ts ***!\n  \\****************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getStatusText = getStatusText;\nexports.STATUS_CODES = void 0;\n// status codes via https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n\nvar STATUS_CODES = {\n  0: '',\n  100: 'Continue',\n  101: 'Switching Protocol',\n  102: 'Processing',\n  103: 'Early Hints',\n  200: 'OK',\n  201: 'Created',\n  202: 'Accepted',\n  203: 'Non-Authoritative Information',\n  204: 'No Content',\n  205: 'Reset Content',\n  206: 'Partial Content',\n  207: 'Multi-Status',\n  208: 'Already Reported',\n  226: 'IM Used',\n  300: 'Multiple Choices',\n  301: 'Moved Permanently',\n  302: 'Found',\n  303: 'See Other',\n  304: 'Not Modified',\n  305: 'Use Proxy',\n  306: 'unused',\n  307: 'Temporary Redirect',\n  308: 'Permanent Redirect',\n  400: 'Bad Request',\n  401: 'Unauthorized',\n  402: 'Payment Required',\n  403: 'Forbidden',\n  404: 'Not Found',\n  405: 'Method Not Allowed',\n  406: 'Not Acceptable',\n  407: 'Proxy Authentication Required',\n  408: 'Request Timeout',\n  409: 'Conflict',\n  410: 'Gone',\n  411: 'Length Required',\n  412: 'Precondition Failed',\n  413: 'Payload Too Large',\n  414: 'URI Too Long',\n  415: 'Unsupported Media Type',\n  416: 'Range Not Satisfiable',\n  417: 'Expectation Failed',\n  418: 'I\\'m a teapot',\n  421: 'Misdirected Request',\n  422: 'Unprocessable Entity',\n  423: 'Locked',\n  424: 'Failed Dependency',\n  425: 'Too Early',\n  426: 'Upgrade Required',\n  428: 'Precondition Required',\n  429: 'Too Many Requests',\n  431: 'Request Header Fields Too Large',\n  451: 'Unavailable For Legal Reasons',\n  500: 'Internal Server Error',\n  501: 'Not Implemented',\n  502: 'Bad Gateway',\n  503: 'Service Unavailable',\n  504: 'Gateway Timeout',\n  505: 'HTTP Version Not Supported',\n  506: 'Variant Also Negotiates',\n  507: 'Insufficient Storage',\n  508: 'Loop Detected',\n  510: 'Not Extended',\n  511: 'Network Authentication Required'\n};\nexports.STATUS_CODES = STATUS_CODES;\nfunction getStatusText(statusCode) {\n  return STATUS_CODES[String(statusCode)];\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/contains.js\":\n/*!***************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/contains.js ***!\n  \\***************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = contains;\nfunction contains(value, search) {\n  return value && search && value.indexOf(search) > -1;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/deepArsonify.js\":\n/*!*******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/deepArsonify.js ***!\n  \\*******************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_134158__) {\n\n\"use strict\";\n\n\nvar _typeof = __nested_webpack_require_134158__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = deepArsonify;\nvar ARSON = _interopRequireWildcard(__nested_webpack_require_134158__(/*! @logrocket/arson */ \"./packages/@logrocket/arson/src/index.js\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction deepArsonify(data) {\n  return {\n    // table: Arson.toTable(data).map(shallowArsonify),\n    arson: ARSON.encode(data)\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/deepDearsonify.js\":\n/*!*********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/deepDearsonify.js ***!\n  \\*********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_136135__) {\n\n\"use strict\";\n\n\nvar _typeof = __nested_webpack_require_136135__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = deepDearsonify;\nvar ARSON = _interopRequireWildcard(__nested_webpack_require_136135__(/*! @logrocket/arson */ \"./packages/@logrocket/arson/src/index.js\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction deepDearsonify(data) {\n  if (!data) {\n    return data;\n  }\n  return ARSON.decode(data.arson);\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/endsWith.js\":\n/*!***************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/endsWith.js ***!\n  \\***************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = endsWith;\nfunction endsWith(value, search) {\n  return value && search && value.substring(value.length - search.length) === search;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/enhanceFunc.js\":\n/*!******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/enhanceFunc.js ***!\n  \\******************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = enhanceFunc;\n/* eslint no-param-reassign: [\"error\", { \"props\": false }] */\n\nfunction enhanceFunc(obj, method, handler) {\n  var original = obj[method];\n  function shim() {\n    var res;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (original) {\n      res = original.apply(this, args);\n    }\n    handler.apply(this, args);\n    return res;\n  }\n  obj[method] = shim;\n  return function () {\n    obj[method] = original;\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/find.js\":\n/*!***********************************************!*\\\n  !*** ./packages/@logrocket/utils/src/find.js ***!\n  \\***********************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = find;\nfunction find(array, predicate) {\n  for (var idx = 0; idx < array.length; idx++) {\n    if (predicate(array[idx])) {\n      return array[idx];\n    }\n  }\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/findIndex.js\":\n/*!****************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/findIndex.js ***!\n  \\****************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = findIndex;\nfunction findIndex(array, predicate) {\n  for (var idx = 0; idx < array.length; idx++) {\n    if (predicate(array[idx])) {\n      return idx;\n    }\n  }\n  return -1;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/findKeyFrames.js\":\n/*!********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/findKeyFrames.js ***!\n  \\********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_140634__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_140634__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = findKeyFrames;\nvar _sortedLastIndexBy = _interopRequireDefault(__nested_webpack_require_140634__(/*! lodash/sortedLastIndexBy */ \"./packages/@logrocket/utils/node_modules/lodash/sortedLastIndexBy.js\"));\n/**\n * Give an array of timed events and a time, find the array element\n * before and after that time and the progress between the frames (0 to 1)\n */\nfunction findKeyFrames(futures, time) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$sdkThrottle = _ref.sdkThrottle,\n    sdkThrottle = _ref$sdkThrottle === void 0 ? 500 : _ref$sdkThrottle;\n  if (!futures.length) {\n    return null;\n  }\n  var index = (0, _sortedLastIndexBy.default)(futures, {\n    time: time\n  }, 'time');\n  var next = futures[index] || futures[index - 1];\n  var prev = futures[index - 1] || next;\n\n  // Do not consider events further than `throttle` time away to be active.\n  // This prevents the slow-drift effect.\n  var totalTime = Math.min(next.time - prev.time, sdkThrottle);\n  var expired = Math.max(time - (next.time - totalTime), 0);\n  var ratio = totalTime === 0 ? 1 : Math.min(expired / totalTime, 1);\n  return {\n    prev: prev,\n    next: next,\n    ratio: ratio\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/flatten.js\":\n/*!**************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/flatten.js ***!\n  \\**************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = flatten;\nfunction flatten(acc, current) {\n  return acc.concat(current);\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/getCssRules.ts\":\n/*!******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/getCssRules.ts ***!\n  \\******************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getCssRule = exports.getCssRules = void 0;\nvar getCssRules = function getCssRules(sheetOrRule) {\n  try {\n    // Chrome 64 won't let you check sheet.rules without throwing if they're unavailable\n    // and Firefox uses cssRules\n    var cssRules = sheetOrRule.cssRules;\n    if (!cssRules && sheetOrRule instanceof CSSStyleSheet) {\n      return sheetOrRule.rules;\n    }\n    return cssRules;\n  } catch (err) {\n    // catch DOMExcpetion or SecurityException from attempting to access sheetOrRule.cssRules\n    //  on a cross origin hosted stylesheet.\n    return null;\n  }\n};\nexports.getCssRules = getCssRules;\nvar getCssRule = function getCssRule(sheetOrRule, ruleIndex) {\n  var rules = getCssRules(sheetOrRule);\n  if (!rules || ruleIndex >= rules.length) {\n    return null;\n  }\n  return rules.item(ruleIndex);\n};\nexports.getCssRule = getCssRule;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/getGraphQLOperation.js\":\n/*!**************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/getGraphQLOperation.js ***!\n  \\**************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = getGraphQLOperation;\nfunction getGraphQLOperation(body) {\n  if (body) {\n    try {\n      var parsedBody = typeof body === 'string' ? JSON.parse(body) : body;\n      var query = parsedBody.query.trim();\n      var match = query.match(/(query|mutation) ([a-z_-]+)/i);\n      if (!match) {\n        return {};\n      }\n      return {\n        operationType: match[1],\n        operationName: match[2]\n      };\n    } catch (_) {\n      return {};\n    }\n  }\n  return {};\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/getMockDeveloperUser.js\":\n/*!***************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/getMockDeveloperUser.js ***!\n  \\***************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = getMockDeveloperUser;\nfunction getMockDeveloperUser() {\n  return {\n    permissions: {\n      dashboard: {\n        metrics: true,\n        errors: true\n      },\n      sessionPlayback: {\n        developerPane: {\n          networkPane: {\n            requestBodiesAndHeaders: true\n          }\n        }\n      }\n    },\n    appRoles: []\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/getNodeSelector.js\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/getNodeSelector.js ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_145791__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_145791__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _protectFunc = _interopRequireDefault(__nested_webpack_require_145791__(/*! ./protectFunc */ \"./packages/@logrocket/utils/src/protectFunc.js\"));\nvar getNodeSelector = (0, _protectFunc.default)(function (node) {\n  // nodeName sometimes returns null\n  var nodeName = node.nodeName ? node.nodeName.toLowerCase() : '';\n  var selector = {\n    nodeName: nodeName\n  };\n  if (node.id && node.id.length > 0) {\n    selector.id = node.id;\n  }\n  if (node.classList && node.classList.length > 0) {\n    selector.classList = Array.prototype.slice.call(node.classList, 0);\n  }\n  return selector;\n});\nvar _default = getNodeSelector;\nexports[\"default\"] = _default;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/hashString.js\":\n/*!*****************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/hashString.js ***!\n  \\*****************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_147025__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_147025__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.combineHashes = exports.hashString = void 0;\nvar _protectFunc = _interopRequireDefault(__nested_webpack_require_147025__(/*! ./protectFunc */ \"./packages/@logrocket/utils/src/protectFunc.js\"));\nvar _sendTelemetryData = __nested_webpack_require_147025__(/*! ./sendTelemetryData */ \"./packages/@logrocket/utils/src/sendTelemetryData.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n// Java's String::hashCode\n// https://devdocs.io/openjdk~8/java/lang/string#hashCode--\nvar hashString = (0, _protectFunc.default)(function (str) {\n  try {\n    var hash = 0;\n    if (typeof str === 'string' && str.length) {\n      for (var i = 0; i < str.length; i++) {\n        hash = 31 * hash + str.charCodeAt(i);\n\n        // Force hash to stay in a 32 bit integer so bitshifting works\n        hash |= 0; // eslint-disable-line no-bitwise\n      }\n    }\n\n    return hash;\n  } catch (err) {\n    (0, _sendTelemetryData.sendTelemetry)('Failed to hash string', {\n      extra: {\n        str: str\n      }\n    });\n    return null;\n  }\n});\n\n// Boost's hash_combine\nexports.hashString = hashString;\nvar combineHashes = function combineHashes(hashes) {\n  var out = hashes.shift() || 0;\n  var _iterator = _createForOfIteratorHelper(hashes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var hash = _step.value;\n      out ^= hash + 0x9e3779b9 + (out << 6) + (out >> 2); // eslint-disable-line no-bitwise\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return out;\n};\nexports.combineHashes = combineHashes;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/identityStatus.ts\":\n/*!*********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/identityStatus.ts ***!\n  \\*********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.parseIdentityStatus = parseIdentityStatus;\nexports.IdentityStatus = void 0;\nvar IdentityStatus;\nexports.IdentityStatus = IdentityStatus;\n(function (IdentityStatus) {\n  IdentityStatus[IdentityStatus[\"Unknown\"] = 0] = \"Unknown\";\n  IdentityStatus[IdentityStatus[\"Anonymous\"] = 1] = \"Anonymous\";\n  IdentityStatus[IdentityStatus[\"Identified\"] = 2] = \"Identified\";\n})(IdentityStatus || (exports.IdentityStatus = IdentityStatus = {}));\nfunction parseIdentityStatus(val) {\n  if (!val) {\n    return IdentityStatus.Unknown;\n  }\n  switch (parseInt(val, 10)) {\n    case IdentityStatus.Anonymous:\n      return IdentityStatus.Anonymous;\n    case IdentityStatus.Identified:\n      return IdentityStatus.Identified;\n    default:\n      return IdentityStatus.Unknown;\n  }\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/index.ts\":\n/*!************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/index.ts ***!\n  \\************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_151814__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_151814__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _typeof = __nested_webpack_require_151814__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _exportNames = {\n  enhanceFunc: true,\n  shallowArsonify: true,\n  shallowDearsonify: true,\n  deepArsonify: true,\n  deepDearsonify: true,\n  addListener: true,\n  protectFunc: true,\n  findIndex: true,\n  find: true,\n  flatten: true,\n  selectorMatches: true,\n  parseSelectorForMatch: true,\n  querySelectorWithShadowDom: true,\n  sendErrorTelemetry: true,\n  sendTelemetry: true,\n  sanitizeValue: true,\n  adjustOs: true,\n  adjustOsVersion: true,\n  selectorFromNodePath: true,\n  startsWith: true,\n  endsWith: true,\n  contains: true,\n  uuid: true,\n  randomInt: true,\n  getCssRules: true,\n  getCssRule: true,\n  getNodeSelector: true,\n  getGraphQLOperation: true,\n  isSessionEvent: true,\n  isActivityEvent: true,\n  parseIntFromHex: true,\n  isRecordingSampled: true,\n  makeRecordingID: true,\n  setFromArray: true,\n  setToArray: true,\n  applyUrlSanitizer: true,\n  getMockDeveloperUser: true,\n  maybeCleanSwiftUIClassName: true,\n  LOG_FILTER_TYPES: true,\n  LOG_TYPES: true,\n  METRIC_TIMESERIES_TYPE: true,\n  HEATMAP_FOR_URL_OPERATOR: true,\n  DEFAULT_HEATMAP_FOR_URL_OPERATOR: true,\n  DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR: true,\n  SORT_DIRECTION: true,\n  FEEDBACK_SORT_COLUMN: true,\n  METRIC_RETENTION_TYPE: true,\n  ISSUE_TYPE: true,\n  ISSUE_GROUP_TYPE: true,\n  ES_ISSUE_TYPE_BASE_FILTER: true,\n  ES_ISSUE_TYPES: true,\n  findKeyFrames: true,\n  interpolate: true,\n  interpolateMobile: true,\n  removeOutdated: true,\n  DELIGHTED_RESPONSES_REGEX: true,\n  WOOTRIC_RESPONSES_REGEX: true,\n  REPLAY_TYPE: true,\n  SDK_REPLAY_TYPE: true,\n  SDK_TYPE: true,\n  SDK_TYPE_TO_DISPLAY: true,\n  SESSION_TYPE_TO_DISPLAY: true,\n  STATUS_CODES: true,\n  getStatusText: true,\n  parseQueryString: true,\n  likeOperator: true,\n  scrollMapHistogramToPercent: true,\n  combineHashes: true,\n  hashString: true,\n  encodeUserTraitString: true,\n  parseUserTraitString: true,\n  IdentityStatus: true,\n  parseIdentityStatus: true,\n  scrubException: true,\n  MobileConstants: true\n};\nObject.defineProperty(exports, \"enhanceFunc\", ({\n  enumerable: true,\n  get: function get() {\n    return _enhanceFunc.default;\n  }\n}));\nObject.defineProperty(exports, \"shallowArsonify\", ({\n  enumerable: true,\n  get: function get() {\n    return _shallowArsonify.default;\n  }\n}));\nObject.defineProperty(exports, \"shallowDearsonify\", ({\n  enumerable: true,\n  get: function get() {\n    return _shallowDearsonify.default;\n  }\n}));\nObject.defineProperty(exports, \"deepArsonify\", ({\n  enumerable: true,\n  get: function get() {\n    return _deepArsonify.default;\n  }\n}));\nObject.defineProperty(exports, \"deepDearsonify\", ({\n  enumerable: true,\n  get: function get() {\n    return _deepDearsonify.default;\n  }\n}));\nObject.defineProperty(exports, \"addListener\", ({\n  enumerable: true,\n  get: function get() {\n    return _addListener.default;\n  }\n}));\nObject.defineProperty(exports, \"protectFunc\", ({\n  enumerable: true,\n  get: function get() {\n    return _protectFunc.default;\n  }\n}));\nObject.defineProperty(exports, \"findIndex\", ({\n  enumerable: true,\n  get: function get() {\n    return _findIndex.default;\n  }\n}));\nObject.defineProperty(exports, \"find\", ({\n  enumerable: true,\n  get: function get() {\n    return _find.default;\n  }\n}));\nObject.defineProperty(exports, \"flatten\", ({\n  enumerable: true,\n  get: function get() {\n    return _flatten.default;\n  }\n}));\nObject.defineProperty(exports, \"selectorMatches\", ({\n  enumerable: true,\n  get: function get() {\n    return _selectorMatches.default;\n  }\n}));\nObject.defineProperty(exports, \"parseSelectorForMatch\", ({\n  enumerable: true,\n  get: function get() {\n    return _parseSelectorForMatch.default;\n  }\n}));\nObject.defineProperty(exports, \"querySelectorWithShadowDom\", ({\n  enumerable: true,\n  get: function get() {\n    return _querySelectorWithShadowDom.default;\n  }\n}));\nObject.defineProperty(exports, \"sendErrorTelemetry\", ({\n  enumerable: true,\n  get: function get() {\n    return _sendTelemetryData.default;\n  }\n}));\nObject.defineProperty(exports, \"sendTelemetry\", ({\n  enumerable: true,\n  get: function get() {\n    return _sendTelemetryData.sendTelemetry;\n  }\n}));\nObject.defineProperty(exports, \"sanitizeValue\", ({\n  enumerable: true,\n  get: function get() {\n    return _sanitizeValue.default;\n  }\n}));\nObject.defineProperty(exports, \"adjustOs\", ({\n  enumerable: true,\n  get: function get() {\n    return _adjustOsVersion.adjustOs;\n  }\n}));\nObject.defineProperty(exports, \"adjustOsVersion\", ({\n  enumerable: true,\n  get: function get() {\n    return _adjustOsVersion.adjustOsVersion;\n  }\n}));\nObject.defineProperty(exports, \"selectorFromNodePath\", ({\n  enumerable: true,\n  get: function get() {\n    return _selectorFromNodePath.default;\n  }\n}));\nObject.defineProperty(exports, \"startsWith\", ({\n  enumerable: true,\n  get: function get() {\n    return _startsWith.default;\n  }\n}));\nObject.defineProperty(exports, \"endsWith\", ({\n  enumerable: true,\n  get: function get() {\n    return _endsWith.default;\n  }\n}));\nObject.defineProperty(exports, \"contains\", ({\n  enumerable: true,\n  get: function get() {\n    return _contains.default;\n  }\n}));\nObject.defineProperty(exports, \"uuid\", ({\n  enumerable: true,\n  get: function get() {\n    return _uuid.default;\n  }\n}));\nObject.defineProperty(exports, \"randomInt\", ({\n  enumerable: true,\n  get: function get() {\n    return _randomInt.default;\n  }\n}));\nObject.defineProperty(exports, \"getCssRules\", ({\n  enumerable: true,\n  get: function get() {\n    return _getCssRules.getCssRules;\n  }\n}));\nObject.defineProperty(exports, \"getCssRule\", ({\n  enumerable: true,\n  get: function get() {\n    return _getCssRules.getCssRule;\n  }\n}));\nObject.defineProperty(exports, \"getNodeSelector\", ({\n  enumerable: true,\n  get: function get() {\n    return _getNodeSelector.default;\n  }\n}));\nObject.defineProperty(exports, \"getGraphQLOperation\", ({\n  enumerable: true,\n  get: function get() {\n    return _getGraphQLOperation.default;\n  }\n}));\nObject.defineProperty(exports, \"isSessionEvent\", ({\n  enumerable: true,\n  get: function get() {\n    return _isSessionEvent.default;\n  }\n}));\nObject.defineProperty(exports, \"isActivityEvent\", ({\n  enumerable: true,\n  get: function get() {\n    return _isActivityEvent.default;\n  }\n}));\nObject.defineProperty(exports, \"parseIntFromHex\", ({\n  enumerable: true,\n  get: function get() {\n    return _parseIntFromHex.default;\n  }\n}));\nObject.defineProperty(exports, \"isRecordingSampled\", ({\n  enumerable: true,\n  get: function get() {\n    return _isRecordingSampled.default;\n  }\n}));\nObject.defineProperty(exports, \"makeRecordingID\", ({\n  enumerable: true,\n  get: function get() {\n    return _makeRecordingID.default;\n  }\n}));\nObject.defineProperty(exports, \"setFromArray\", ({\n  enumerable: true,\n  get: function get() {\n    return _setFromArray.default;\n  }\n}));\nObject.defineProperty(exports, \"setToArray\", ({\n  enumerable: true,\n  get: function get() {\n    return _setToArray.default;\n  }\n}));\nObject.defineProperty(exports, \"applyUrlSanitizer\", ({\n  enumerable: true,\n  get: function get() {\n    return _applyUrlSanitizer.default;\n  }\n}));\nObject.defineProperty(exports, \"getMockDeveloperUser\", ({\n  enumerable: true,\n  get: function get() {\n    return _getMockDeveloperUser.default;\n  }\n}));\nObject.defineProperty(exports, \"maybeCleanSwiftUIClassName\", ({\n  enumerable: true,\n  get: function get() {\n    return _maybeCleanSwiftUIClassName.default;\n  }\n}));\nObject.defineProperty(exports, \"LOG_FILTER_TYPES\", ({\n  enumerable: true,\n  get: function get() {\n    return _logTypes.LOG_FILTER_TYPES;\n  }\n}));\nObject.defineProperty(exports, \"LOG_TYPES\", ({\n  enumerable: true,\n  get: function get() {\n    return _logTypes.LOG_TYPES;\n  }\n}));\nObject.defineProperty(exports, \"METRIC_TIMESERIES_TYPE\", ({\n  enumerable: true,\n  get: function get() {\n    return _metrics.METRIC_TIMESERIES_TYPE;\n  }\n}));\nObject.defineProperty(exports, \"HEATMAP_FOR_URL_OPERATOR\", ({\n  enumerable: true,\n  get: function get() {\n    return _metrics.HEATMAP_FOR_URL_OPERATOR;\n  }\n}));\nObject.defineProperty(exports, \"DEFAULT_HEATMAP_FOR_URL_OPERATOR\", ({\n  enumerable: true,\n  get: function get() {\n    return _metrics.DEFAULT_HEATMAP_FOR_URL_OPERATOR;\n  }\n}));\nObject.defineProperty(exports, \"DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR\", ({\n  enumerable: true,\n  get: function get() {\n    return _metrics.DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR;\n  }\n}));\nObject.defineProperty(exports, \"SORT_DIRECTION\", ({\n  enumerable: true,\n  get: function get() {\n    return _metrics.SORT_DIRECTION;\n  }\n}));\nObject.defineProperty(exports, \"FEEDBACK_SORT_COLUMN\", ({\n  enumerable: true,\n  get: function get() {\n    return _metrics.FEEDBACK_SORT_COLUMN;\n  }\n}));\nObject.defineProperty(exports, \"METRIC_RETENTION_TYPE\", ({\n  enumerable: true,\n  get: function get() {\n    return _metrics.METRIC_RETENTION_TYPE;\n  }\n}));\nObject.defineProperty(exports, \"ISSUE_TYPE\", ({\n  enumerable: true,\n  get: function get() {\n    return _issues.ISSUE_TYPE;\n  }\n}));\nObject.defineProperty(exports, \"ISSUE_GROUP_TYPE\", ({\n  enumerable: true,\n  get: function get() {\n    return _issues.ISSUE_GROUP_TYPE;\n  }\n}));\nObject.defineProperty(exports, \"ES_ISSUE_TYPE_BASE_FILTER\", ({\n  enumerable: true,\n  get: function get() {\n    return _issues.ES_ISSUE_TYPE_BASE_FILTER;\n  }\n}));\nObject.defineProperty(exports, \"ES_ISSUE_TYPES\", ({\n  enumerable: true,\n  get: function get() {\n    return _issues.ES_ISSUE_TYPES;\n  }\n}));\nObject.defineProperty(exports, \"findKeyFrames\", ({\n  enumerable: true,\n  get: function get() {\n    return _findKeyFrames.default;\n  }\n}));\nObject.defineProperty(exports, \"interpolate\", ({\n  enumerable: true,\n  get: function get() {\n    return _interpolate.default;\n  }\n}));\nObject.defineProperty(exports, \"interpolateMobile\", ({\n  enumerable: true,\n  get: function get() {\n    return _interpolate.interpolateMobile;\n  }\n}));\nObject.defineProperty(exports, \"removeOutdated\", ({\n  enumerable: true,\n  get: function get() {\n    return _removeOutdated.default;\n  }\n}));\nObject.defineProperty(exports, \"DELIGHTED_RESPONSES_REGEX\", ({\n  enumerable: true,\n  get: function get() {\n    return _nps.DELIGHTED_RESPONSES_REGEX;\n  }\n}));\nObject.defineProperty(exports, \"WOOTRIC_RESPONSES_REGEX\", ({\n  enumerable: true,\n  get: function get() {\n    return _nps.WOOTRIC_RESPONSES_REGEX;\n  }\n}));\nObject.defineProperty(exports, \"REPLAY_TYPE\", ({\n  enumerable: true,\n  get: function get() {\n    return _replayTypes.REPLAY_TYPE;\n  }\n}));\nObject.defineProperty(exports, \"SDK_REPLAY_TYPE\", ({\n  enumerable: true,\n  get: function get() {\n    return _sdkTypes.SDK_REPLAY_TYPE;\n  }\n}));\nObject.defineProperty(exports, \"SDK_TYPE\", ({\n  enumerable: true,\n  get: function get() {\n    return _sdkTypes.SDK_TYPE;\n  }\n}));\nObject.defineProperty(exports, \"SDK_TYPE_TO_DISPLAY\", ({\n  enumerable: true,\n  get: function get() {\n    return _sdkTypes.SDK_TYPE_TO_DISPLAY;\n  }\n}));\nObject.defineProperty(exports, \"SESSION_TYPE_TO_DISPLAY\", ({\n  enumerable: true,\n  get: function get() {\n    return _sdkTypes.SESSION_TYPE_TO_DISPLAY;\n  }\n}));\nObject.defineProperty(exports, \"STATUS_CODES\", ({\n  enumerable: true,\n  get: function get() {\n    return _statusCodes.STATUS_CODES;\n  }\n}));\nObject.defineProperty(exports, \"getStatusText\", ({\n  enumerable: true,\n  get: function get() {\n    return _statusCodes.getStatusText;\n  }\n}));\nObject.defineProperty(exports, \"parseQueryString\", ({\n  enumerable: true,\n  get: function get() {\n    return _parseQueryString.parseQueryString;\n  }\n}));\nObject.defineProperty(exports, \"likeOperator\", ({\n  enumerable: true,\n  get: function get() {\n    return _likeOperator.likeOperator;\n  }\n}));\nObject.defineProperty(exports, \"scrollMapHistogramToPercent\", ({\n  enumerable: true,\n  get: function get() {\n    return _scrollMapHistogramToPercent.default;\n  }\n}));\nObject.defineProperty(exports, \"combineHashes\", ({\n  enumerable: true,\n  get: function get() {\n    return _hashString.combineHashes;\n  }\n}));\nObject.defineProperty(exports, \"hashString\", ({\n  enumerable: true,\n  get: function get() {\n    return _hashString.hashString;\n  }\n}));\nObject.defineProperty(exports, \"encodeUserTraitString\", ({\n  enumerable: true,\n  get: function get() {\n    return _userTraitStrings.encodeUserTraitString;\n  }\n}));\nObject.defineProperty(exports, \"parseUserTraitString\", ({\n  enumerable: true,\n  get: function get() {\n    return _userTraitStrings.parseUserTraitString;\n  }\n}));\nObject.defineProperty(exports, \"IdentityStatus\", ({\n  enumerable: true,\n  get: function get() {\n    return _identityStatus.IdentityStatus;\n  }\n}));\nObject.defineProperty(exports, \"parseIdentityStatus\", ({\n  enumerable: true,\n  get: function get() {\n    return _identityStatus.parseIdentityStatus;\n  }\n}));\nObject.defineProperty(exports, \"scrubException\", ({\n  enumerable: true,\n  get: function get() {\n    return _scrubException.scrubException;\n  }\n}));\nexports.MobileConstants = void 0;\nvar _enhanceFunc = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./enhanceFunc */ \"./packages/@logrocket/utils/src/enhanceFunc.js\"));\nvar _shallowArsonify = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./shallowArsonify */ \"./packages/@logrocket/utils/src/shallowArsonify.js\"));\nvar _shallowDearsonify = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./shallowDearsonify */ \"./packages/@logrocket/utils/src/shallowDearsonify.js\"));\nvar _deepArsonify = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./deepArsonify */ \"./packages/@logrocket/utils/src/deepArsonify.js\"));\nvar _deepDearsonify = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./deepDearsonify */ \"./packages/@logrocket/utils/src/deepDearsonify.js\"));\nvar _addListener = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./addListener */ \"./packages/@logrocket/utils/src/addListener.js\"));\nvar _protectFunc = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./protectFunc */ \"./packages/@logrocket/utils/src/protectFunc.js\"));\nvar _findIndex = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./findIndex */ \"./packages/@logrocket/utils/src/findIndex.js\"));\nvar _find = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./find */ \"./packages/@logrocket/utils/src/find.js\"));\nvar _flatten = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./flatten */ \"./packages/@logrocket/utils/src/flatten.js\"));\nvar _selectorMatches = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./selectorMatches */ \"./packages/@logrocket/utils/src/selectorMatches.js\"));\nvar _parseSelectorForMatch = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./parseSelectorForMatch */ \"./packages/@logrocket/utils/src/parseSelectorForMatch.js\"));\nvar _querySelectorWithShadowDom = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./querySelectorWithShadowDom */ \"./packages/@logrocket/utils/src/querySelectorWithShadowDom.js\"));\nvar _sendTelemetryData = _interopRequireWildcard(__nested_webpack_require_151814__(/*! ./sendTelemetryData */ \"./packages/@logrocket/utils/src/sendTelemetryData.js\"));\nvar _sanitizeValue = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./sanitizeValue */ \"./packages/@logrocket/utils/src/sanitizeValue.js\"));\nvar _adjustOsVersion = __nested_webpack_require_151814__(/*! ./adjustOsVersion */ \"./packages/@logrocket/utils/src/adjustOsVersion.ts\");\nvar _selectorFromNodePath = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./selectorFromNodePath */ \"./packages/@logrocket/utils/src/selectorFromNodePath.js\"));\nvar _startsWith = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./startsWith */ \"./packages/@logrocket/utils/src/startsWith.js\"));\nvar _endsWith = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./endsWith */ \"./packages/@logrocket/utils/src/endsWith.js\"));\nvar _contains = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./contains */ \"./packages/@logrocket/utils/src/contains.js\"));\nvar _uuid = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./uuid */ \"./packages/@logrocket/utils/src/uuid.js\"));\nvar _randomInt = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./randomInt */ \"./packages/@logrocket/utils/src/randomInt.js\"));\nvar _getCssRules = __nested_webpack_require_151814__(/*! ./getCssRules */ \"./packages/@logrocket/utils/src/getCssRules.ts\");\nvar _getNodeSelector = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./getNodeSelector */ \"./packages/@logrocket/utils/src/getNodeSelector.js\"));\nvar _getGraphQLOperation = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./getGraphQLOperation */ \"./packages/@logrocket/utils/src/getGraphQLOperation.js\"));\nvar _isSessionEvent = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./isSessionEvent */ \"./packages/@logrocket/utils/src/isSessionEvent.js\"));\nvar _isActivityEvent = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./isActivityEvent */ \"./packages/@logrocket/utils/src/isActivityEvent.js\"));\nvar _parseIntFromHex = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./parseIntFromHex */ \"./packages/@logrocket/utils/src/parseIntFromHex.js\"));\nvar _isRecordingSampled = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./isRecordingSampled */ \"./packages/@logrocket/utils/src/isRecordingSampled.js\"));\nvar _makeRecordingID = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./makeRecordingID */ \"./packages/@logrocket/utils/src/makeRecordingID.js\"));\nvar _setFromArray = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./setFromArray */ \"./packages/@logrocket/utils/src/setFromArray.js\"));\nvar _setToArray = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./setToArray */ \"./packages/@logrocket/utils/src/setToArray.js\"));\nvar _applyUrlSanitizer = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./applyUrlSanitizer */ \"./packages/@logrocket/utils/src/applyUrlSanitizer.js\"));\nvar _getMockDeveloperUser = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./getMockDeveloperUser */ \"./packages/@logrocket/utils/src/getMockDeveloperUser.js\"));\nvar _maybeCleanSwiftUIClassName = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./maybeCleanSwiftUIClassName */ \"./packages/@logrocket/utils/src/maybeCleanSwiftUIClassName.ts\"));\nvar _logTypes = __nested_webpack_require_151814__(/*! ./constants/logTypes */ \"./packages/@logrocket/utils/src/constants/logTypes.js\");\nvar _metrics = __nested_webpack_require_151814__(/*! ./constants/metrics */ \"./packages/@logrocket/utils/src/constants/metrics.js\");\nvar _issues = __nested_webpack_require_151814__(/*! ./constants/issues */ \"./packages/@logrocket/utils/src/constants/issues.ts\");\nvar _findKeyFrames = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./findKeyFrames */ \"./packages/@logrocket/utils/src/findKeyFrames.js\"));\nvar _interpolate = _interopRequireWildcard(__nested_webpack_require_151814__(/*! ./interpolate */ \"./packages/@logrocket/utils/src/interpolate.js\"));\nvar _removeOutdated = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./removeOutdated */ \"./packages/@logrocket/utils/src/removeOutdated.js\"));\nvar _nps = __nested_webpack_require_151814__(/*! ./constants/nps */ \"./packages/@logrocket/utils/src/constants/nps.js\");\nvar _replayTypes = __nested_webpack_require_151814__(/*! ./constants/replayTypes */ \"./packages/@logrocket/utils/src/constants/replayTypes.ts\");\nvar _sdkTypes = __nested_webpack_require_151814__(/*! ./constants/sdkTypes */ \"./packages/@logrocket/utils/src/constants/sdkTypes.ts\");\nvar _statusCodes = __nested_webpack_require_151814__(/*! ./constants/statusCodes */ \"./packages/@logrocket/utils/src/constants/statusCodes.ts\");\nvar _parseQueryString = __nested_webpack_require_151814__(/*! ./parseQueryString */ \"./packages/@logrocket/utils/src/parseQueryString.js\");\nvar _likeOperator = __nested_webpack_require_151814__(/*! ./likeOperator */ \"./packages/@logrocket/utils/src/likeOperator.js\");\nvar _scrollMapHistogramToPercent = _interopRequireDefault(__nested_webpack_require_151814__(/*! ./scrollMapHistogramToPercent */ \"./packages/@logrocket/utils/src/scrollMapHistogramToPercent.js\"));\nvar _hashString = __nested_webpack_require_151814__(/*! ./hashString */ \"./packages/@logrocket/utils/src/hashString.js\");\nvar _userTraitStrings = __nested_webpack_require_151814__(/*! ./userTraitStrings */ \"./packages/@logrocket/utils/src/userTraitStrings.ts\");\nvar _identityStatus = __nested_webpack_require_151814__(/*! ./identityStatus */ \"./packages/@logrocket/utils/src/identityStatus.ts\");\nvar _scrubException = __nested_webpack_require_151814__(/*! ./scrubException */ \"./packages/@logrocket/utils/src/scrubException.ts\");\nvar _MobileConstants = _interopRequireWildcard(__nested_webpack_require_151814__(/*! ./constants/mobile */ \"./packages/@logrocket/utils/src/constants/mobile.ts\"));\nexports.MobileConstants = _MobileConstants;\nvar _browserUtils = __nested_webpack_require_151814__(/*! ./browserUtils */ \"./packages/@logrocket/utils/src/browserUtils.js\");\nObject.keys(_browserUtils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _browserUtils[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _browserUtils[key];\n    }\n  });\n});\nvar _isValidAppID = __nested_webpack_require_151814__(/*! ./isValidAppID */ \"./packages/@logrocket/utils/src/isValidAppID.ts\");\nObject.keys(_isValidAppID).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _isValidAppID[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _isValidAppID[key];\n    }\n  });\n});\nvar _requireValue = __nested_webpack_require_151814__(/*! ./requireValue */ \"./packages/@logrocket/utils/src/requireValue.ts\");\nObject.keys(_requireValue).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _requireValue[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _requireValue[key];\n    }\n  });\n});\nvar _types = __nested_webpack_require_151814__(/*! ./types */ \"./packages/@logrocket/utils/src/types.ts\");\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/interpolate.js\":\n/*!******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/interpolate.js ***!\n  \\******************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_175681__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_175681__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = interpolate;\nexports.interpolateMobile = interpolateMobile;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_175681__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction interpolate(keyFrames, props) {\n  if (!keyFrames) {\n    return {};\n  }\n  var prev = keyFrames.prev,\n    next = keyFrames.next,\n    ratio = keyFrames.ratio;\n  var mid = _objectSpread({}, next);\n  var _iterator = _createForOfIteratorHelper(props),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var p = _step.value;\n      mid[p] = prev[p] + (next[p] - prev[p]) * ratio;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return mid;\n}\nfunction interpolateMobile(keyFrames, props, time) {\n  if (!keyFrames) {\n    return {};\n  }\n  var prev = keyFrames.prev,\n    next = keyFrames.next;\n  if (next.type === 'MOVE') {\n    return interpolate(keyFrames, props);\n  }\n\n  // let touch events only linger for half a second on the screen\n  if (prev === next && Math.abs(time - next.time) > 500) {\n    return null;\n  }\n  return next;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/isActivityEvent.js\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/isActivityEvent.js ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isActivityEvent;\nfunction isActivityEvent(type) {\n  var activityTypes = ['lr.browser.MouseEvent', 'lr.browser.ScrollEvent', 'lr.browser.InputEvent', 'lr.browser.InputChangeEvent', 'lr.android.TouchEvent', 'lr.android.InputChangeEvent', 'lr.ios.TouchEvent', 'lr.ios.InputChangeEvent'];\n  return activityTypes.indexOf(type) > -1;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/isRecordingSampled.js\":\n/*!*************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/isRecordingSampled.js ***!\n  \\*************************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_180647__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_180647__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isRecordingSampled;\nvar _parseIntFromHex = _interopRequireDefault(__nested_webpack_require_180647__(/*! ./parseIntFromHex */ \"./packages/@logrocket/utils/src/parseIntFromHex.js\"));\nvar SAMPLE_BUCKETS = 10000; // As few as 0.01% of recordings\n\nfunction isRecordingSampled(recordingID, samplePercent) {\n  if (samplePercent <= 0) {\n    return false;\n  }\n  var maxBucket = Math.floor(samplePercent * SAMPLE_BUCKETS);\n  var num = (0, _parseIntFromHex.default)(recordingID);\n  var bucket = num % SAMPLE_BUCKETS;\n  return bucket <= maxBucket;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/isSessionEvent.js\":\n/*!*********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/isSessionEvent.js ***!\n  \\*********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = isSessionEvent;\nvar SESSION_EVENT_WHITELIST = ['lr.browser.NavigationEvent', 'lr.browser.InputChangeEvent', 'lr.browser.InputEvent'];\nfunction isSessionEvent(event) {\n  return SESSION_EVENT_WHITELIST.indexOf(event.type) > -1 || event.data.eventType === 'CLICK';\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/isValidAppID.ts\":\n/*!*******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/isValidAppID.ts ***!\n  \\*******************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isValidAppID = isValidAppID;\n// This pattern matches the orgSlug/appSlug format we expect for appIDs. Each slug is generated using the `slugify`\n// helper which performs a few conversions:\n// 1) All unicode is converted to approximate ASCII, or removed if there is no replacement.\n// 2) Spaces are converted to hyphens\n// 3) Remove any characters that are not alphanumeric, a hyphen, or an underscore.\n// 4) And finally, lowercase the string.\n//\n// https://docs.djangoproject.com/en/1.10/_modules/django/utils/text/#slugify\n//\n// The fields storing these slugs are SlugField instances, which use a different validation regex allowing uppercase\n// characters. As the final step in `slugify` is to lowercase all text, and that is how we generate slugs, we do not\n// consider uppercase characters valid in an appID.\n//\n// https://docs.djangoproject.com/en/1.10/_modules/django/core/validators/ (see slug_re)\nvar APP_ID_PATTERN = /^[a-z0-9_-]+\\/[a-z0-9_-]+$/;\nfunction isValidAppID(appID) {\n  return typeof appID === 'string' && APP_ID_PATTERN.test(appID);\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/likeOperator.js\":\n/*!*******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/likeOperator.js ***!\n  \\*******************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.likeOperator = likeOperator;\nfunction likeOperator(value, pattern) {\n  // Behaves like the ES \"wildcard\" query\n  // (See: https://www.elastic.co/guide/en/elasticsearch/reference/6.5/query-dsl-wildcard-query.html#query-dsl-wildcard-query)\n\n  var escaped = pattern.replace(\n  // (See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping)\n  /[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  // To emulate the ES wildcard search in regex\n  // (a) prefix '*' with the regex wildcard '.' character\n  // (c) convert '?' to '.'\n  // Keep in mind that we have escaped these characters, so we actually need to match\n  // their escaped versions.\n  var escapedRegexString = escaped.replace(/\\\\\\*/g, '.*').replace(/\\\\\\?/g, '.');\n  var regex = new RegExp(\"^\".concat(escapedRegexString, \"$\"));\n  return regex.test(value);\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/logError.js\":\n/*!***************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/logError.js ***!\n  \\***************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar canBind = typeof console !== 'undefined' && console.error && console.error.bind;\nvar logError = canBind ? console.error.bind(console) : function () {};\nvar _default = logError;\nexports[\"default\"] = _default;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/makeRecordingID.js\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/makeRecordingID.js ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_185750__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_185750__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = makeRecordingID;\nvar _uuid = _interopRequireDefault(__nested_webpack_require_185750__(/*! ./uuid */ \"./packages/@logrocket/utils/src/uuid.js\"));\nfunction makeRecordingID() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    _ref$prefix = _ref.prefix,\n    prefix = _ref$prefix === void 0 ? 5 : _ref$prefix;\n  return \"\".concat(prefix, \"-\").concat((0, _uuid.default)());\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/mapValues.js\":\n/*!****************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/mapValues.js ***!\n  \\****************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = mapValues;\nfunction mapValues(obj, f) {\n  if (obj == null) {\n    return {};\n  }\n  var res = {};\n  Object.keys(obj).forEach(function (key) {\n    res[key] = f(obj[key]);\n  });\n  return res;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/maybeCleanSwiftUIClassName.ts\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/maybeCleanSwiftUIClassName.ts ***!\n  \\*********************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = maybeCleanSwiftUIClassName;\nfunction maybeCleanSwiftUIClassName(className) {\n  // replace angle brackets present in SwiftUI ViewController type strings with ascii encoding and strip spaces\n  return className.replace(/</g, '%3c').replace(/>/g, '%3e').replace(/\\s/g, '');\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/parseIntFromHex.js\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/parseIntFromHex.js ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseIntFromHex;\nfunction parseIntFromHex(string) {\n  // strip non-hex characters\n  var hex = string.replace(/[^0-9a-f]/g, '');\n  return parseInt(\"0x\".concat(hex), 16) || 0;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/parseQueryString.js\":\n/*!***********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/parseQueryString.js ***!\n  \\***********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_188676__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_188676__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.parseQueryString = void 0;\nvar _slicedToArray2 = _interopRequireDefault(__nested_webpack_require_188676__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\nvar parseSearchParams = function parseSearchParams(queryString) {\n  // Ideally this would use URLSearchParams but that's unsupported in IE 11\n  var params = {};\n  var fragments = queryString.split('&');\n  // The way this is constructed will take the last of any duplicate keys\n  fragments.forEach(function (fragment) {\n    var _fragment$split$map$m = fragment.split('=')\n      // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent#decoding_query_parameters_from_a_url\n      .map(function (s) {\n        return s.replace(/\\+/g, ' ');\n      }).map(decodeURIComponent),\n      _fragment$split$map$m2 = (0, _slicedToArray2.default)(_fragment$split$map$m, 2),\n      key = _fragment$split$map$m2[0],\n      value = _fragment$split$map$m2[1];\n    params[key] = value;\n  });\n  return params;\n};\n\n/**\n * Parse a full URL into an object with keys and values for parameters in the query\n * string of the URL.\n */\nvar parseQueryString = function parseQueryString(href) {\n  var queryDelimiterIndex = href.indexOf('?');\n  if (queryDelimiterIndex === -1) {\n    return {};\n  }\n\n  // Strip the leading '?'\n  var queryString = href.substring(queryDelimiterIndex + 1);\n  return parseSearchParams(queryString);\n};\nexports.parseQueryString = parseQueryString;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/parseSelectorForMatch.js\":\n/*!****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/parseSelectorForMatch.js ***!\n  \\****************************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_190782__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_190782__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseSelectorForMatch;\nvar _toConsumableArray2 = _interopRequireDefault(__nested_webpack_require_190782__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\nvar _slicedToArray2 = _interopRequireDefault(__nested_webpack_require_190782__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\nvar _startsWith = _interopRequireDefault(__nested_webpack_require_190782__(/*! ./startsWith */ \"./packages/@logrocket/utils/src/startsWith.js\"));\nvar nthChildDelim = '~';\nvar nthChildPrefix = ':nth-child(';\n\n// parses selectorString into an array of node objects identifying the following attributes:\n// id: <String>, classNames: [<String>], nodeName: <String>, directDesc: <Bool>, nthChild: <String>\nfunction parseSelectorForMatch(selectorString) {\n  var parsedStr = selectorString.replace(/\\s*>\\s*|:nth-child\\(([1-9][0-9]*|odd|even)\\)|\\s+/gi, function (match) {\n    if (match.indexOf('>') > -1) {\n      return ' >';\n    }\n    if (match.trim().length === 0) {\n      return ' ';\n    }\n    return \"\".concat(nthChildDelim).concat(match.slice(nthChildPrefix.length));\n  });\n  return parsedStr.split(/\\s+/).map(function (nodeString) {\n    var nodeObject = {};\n    var cleanNodeString = nodeString;\n    if (cleanNodeString.charAt(0) === '>') {\n      nodeObject.directDesc = true;\n      cleanNodeString = cleanNodeString.slice(1);\n    }\n    cleanNodeString = cleanNodeString.replace(/^([a-z0-9-_]+)/ig, function (match) {\n      nodeObject.nodeName = match;\n      return '';\n    });\n    if (cleanNodeString.charAt(0) === nthChildDelim) {\n      var _cleanNodeString$slic = cleanNodeString.slice(1).split(')'),\n        _cleanNodeString$slic2 = (0, _slicedToArray2.default)(_cleanNodeString$slic, 2),\n        childID = _cleanNodeString$slic2[0],\n        rest = _cleanNodeString$slic2[1];\n      nodeObject.nthChild = childID;\n      cleanNodeString = rest;\n    }\n    cleanNodeString.replace(/\\.|#/gi, function (match) {\n      return \" \".concat(match);\n    }).trim().split(' ').forEach(function (nodePart) {\n      if ((0, _startsWith.default)(nodePart, '.')) {\n        var className = nodePart.slice(1);\n        nodeObject.classList = nodeObject.classList ? [].concat((0, _toConsumableArray2.default)(nodeObject.classList), [className]) : [className];\n      } else if ((0, _startsWith.default)(nodePart, '#')) {\n        nodeObject.id = nodePart.slice(1);\n      }\n    });\n    return nodeObject;\n  });\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/protectFunc.js\":\n/*!******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/protectFunc.js ***!\n  \\******************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_193823__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_193823__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = protectFunc;\nvar _sendTelemetryData = _interopRequireDefault(__nested_webpack_require_193823__(/*! ./sendTelemetryData */ \"./packages/@logrocket/utils/src/sendTelemetryData.js\"));\nvar _logError = _interopRequireDefault(__nested_webpack_require_193823__(/*! ./logError */ \"./packages/@logrocket/utils/src/logError.js\"));\nfunction protectFunc(f) {\n  var onFail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n  return function () {\n    var result;\n    try {\n      result = f.apply(void 0, arguments);\n    } catch (err) {\n      if (typeof window !== 'undefined' && window._lrdebug) {\n        throw err;\n      }\n      var payload = onFail(err);\n      (0, _logError.default)('LogRocket', err);\n      (0, _sendTelemetryData.default)(err, payload);\n    }\n    return result;\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/querySelectorWithShadowDom.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/querySelectorWithShadowDom.js ***!\n  \\*********************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = querySelectorWithShadowDom;\nexports.caseInsensitiveQuerySelector = void 0;\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar getMatchingChildren = function getMatchingChildren(_ref) {\n  var root = _ref.root,\n    selectorList = _ref.selectorList,\n    directDesc = _ref.directDesc;\n  var selectorParts = selectorList[0].split(/(?=\\.)|(?=#)/);\n\n  // element selector looks like \"type:nth-child(x)\"\n  var elementSelector = selectorParts.shift();\n  var id = '';\n  var classes = [];\n  selectorParts.forEach(function (part) {\n    if (part[0] === '#') {\n      id = part.toLowerCase().substring(1).trim();\n    }\n    if (part[0] === '.') {\n      classes.push(part.toLowerCase().substring(1).trim());\n    }\n  });\n  var matchingElements;\n  if (directDesc) {\n    matchingElements = [root.querySelector(\":scope > \".concat(elementSelector))];\n  } else {\n    matchingElements = root.querySelectorAll(elementSelector);\n  }\n  var matches = [];\n  // check each matched elements for a full match\n  var _iterator = _createForOfIteratorHelper(matchingElements),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var currentMatch = _step.value;\n      if (!currentMatch || id !== currentMatch.id.toLowerCase()) {\n        return \"continue\";\n      }\n      var currentClasses = Array.from(currentMatch.classList.values()).map(function (c) {\n        return c.toLowerCase();\n      }).filter(function (s) {\n        return s !== '' && s[0] !== ':';\n      }); // no pseudo classes or empties\n\n      if (!classes.every(function (v) {\n        return currentClasses.indexOf(v) > -1;\n      })) {\n        return \"continue\";\n      }\n      matches.push(currentMatch);\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return matches;\n};\n\n// The parser expects the selector to be formatted as an ES mouse click selector:\n\n// div:nth-child(1)#some-id > div:nth-child(1)#id-me.class1.class2 > div:nth-child(3) > ...\n\n// with the given selector format it will return the same result as\n// root.querySelector(selector) without case sensitivity\nvar caseInsensitiveQuerySelector = function caseInsensitiveQuerySelector(root, selector) {\n  if (!selector.length) {\n    return null;\n  }\n\n  // If root is part of a shadow DOM, start from the shadow root. Otherwise,\n  //  root must start at body element to protect against malformed DOMs:\n  var rootElement;\n  if (root.host) {\n    // The presence of root.host indicates a shadow root:\n    rootElement = root;\n  } else {\n    rootElement = root.querySelector('body');\n  }\n\n  // no shadow dom root or body tag\n  if (!rootElement) {\n    return null;\n  }\n\n  // when storing selectors we truncate the leading segments of long selector strings\n  // this makes the first selector segment possibly anywhere in the DOM\n  var queue = [{\n    matches: [rootElement],\n    selectorList: selector.split(' > '),\n    directDesc: false\n  }];\n  while (queue.length) {\n    var _queue$shift = queue.shift(),\n      matches = _queue$shift.matches,\n      selectorList = _queue$shift.selectorList,\n      directDesc = _queue$shift.directDesc;\n    var _iterator2 = _createForOfIteratorHelper(matches),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var matchedElement = _step2.value;\n        var currentMatches = getMatchingChildren({\n          root: matchedElement,\n          selectorList: selectorList,\n          directDesc: directDesc\n        });\n\n        // did I find it?\n        if (currentMatches.length && selectorList.length === 1) {\n          return currentMatches[0];\n        }\n        if (currentMatches.length) {\n          queue.push({\n            matches: currentMatches,\n            selectorList: selectorList.slice(1),\n            directDesc: true // all segments after the first must be direct descendants\n          });\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return null;\n};\nexports.caseInsensitiveQuerySelector = caseInsensitiveQuerySelector;\nfunction querySelectorWithShadowDom(element, fullSelector) {\n  if (fullSelector.startsWith('$shadow-root >')) {\n    throw new Error(\"Malformed selector '\".concat(fullSelector, \"': should not start with $shadow-root\"));\n  }\n  if (fullSelector.endsWith('> $shadow-root')) {\n    // Selector ends in an empty shadow root; remove it so we don't perform an invalid query:\n    // eslint-disable-next-line no-param-reassign\n    fullSelector = fullSelector.slice(0, fullSelector.length - '> $shadow-root'.length);\n  }\n  var currentRoot = element;\n  var currentNode;\n  var selectors = fullSelector.split('> $shadow-root >');\n  for (var i = 0; i < selectors.length; i++) {\n    currentNode = caseInsensitiveQuerySelector(currentRoot, selectors[i]);\n\n    // Dive into the shadow!\n    if (currentNode && i < selectors.length - 1) {\n      if (currentNode.shadowRoot) {\n        currentRoot = currentNode.shadowRoot;\n      } else {\n        throw new Error(\"Missing shadowRoot for selector '\".concat(fullSelector, \"' at depth \").concat(i));\n      }\n    }\n  }\n  return {\n    root: currentRoot,\n    node: currentNode\n  };\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/randomInt.js\":\n/*!****************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/randomInt.js ***!\n  \\****************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = randomInt;\n// min is inclusive, max is exclusive\nfunction randomInt(min, max) {\n  var minInt = Math.ceil(min);\n  var maxInt = Math.floor(max);\n  return Math.floor(Math.random() * (maxInt - minInt)) + minInt;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/removeOutdated.js\":\n/*!*********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/removeOutdated.js ***!\n  \\*********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_203072__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_203072__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = removeOutdated;\nvar _sortedLastIndexBy = _interopRequireDefault(__nested_webpack_require_203072__(/*! lodash/sortedLastIndexBy */ \"./packages/@logrocket/utils/node_modules/lodash/sortedLastIndexBy.js\"));\nvar KEEP = 5000;\nfunction removeOutdated(state, action) {\n  if (state.length === 0) {\n    return state;\n  }\n\n  // Find the first entry which is **before** the given actions time.\n  var index = (0, _sortedLastIndexBy.default)(state, {\n    time: action.time - KEEP\n  }, 'time') - 1;\n  var first = state[index];\n\n  // Keep one entry that is more than KEEP away, and remove the rest of them.\n  if (first && action.time - first.time > KEEP && index > 0) {\n    return state.slice(index);\n  }\n  return state;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/requireValue.ts\":\n/*!*******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/requireValue.ts ***!\n  \\*******************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.requireValue = void 0;\nvar requireValue = function requireValue(value) {\n  if (typeof value === 'undefined') {\n    throw new Error('Value must not be undefined.');\n  }\n  return value;\n};\nexports.requireValue = requireValue;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/sanitizeValue.js\":\n/*!********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/sanitizeValue.js ***!\n  \\********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = sanitizeValue;\nvar _replaceWithLipsum = function _replaceWithLipsum(content) {\n  // eslint-disable-next-line max-len\n  var lipsum = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. ';\n  var repeatLength = Math.ceil(content.length / lipsum.length);\n  var replacementContent = '';\n  while (repeatLength > 0) {\n    replacementContent += lipsum;\n    repeatLength--;\n  }\n  return replacementContent.slice(0, content.length);\n};\nfunction sanitizeValue(valueToClean, taintType) {\n  var value = String(valueToClean);\n  if (String(taintType).toLowerCase() === 'lipsum') {\n    return _replaceWithLipsum(value);\n  }\n  return '';\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/scrollMapHistogramToPercent.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/scrollMapHistogramToPercent.js ***!\n  \\**********************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = scrollMapHistogramToPercent;\nfunction scrollMapHistogramToPercent(buckets, scrollHeight) {\n  var scrollMap = [];\n  var currentSessionCount = buckets.reduce(function (acc, d) {\n    return acc + d.count;\n  }, 0);\n  var cursor = 0;\n  for (var p = 1; p <= 100; p++) {\n    var containerPosition = scrollHeight * (p * 0.01);\n    if (cursor >= buckets.length) {\n      scrollMap.push(0); // beyond scrolled area has 0 sessions\n    } else {\n      scrollMap.push(currentSessionCount);\n      if (containerPosition > buckets[cursor].maxScroll) {\n        currentSessionCount -= buckets[cursor].count;\n        cursor++;\n      }\n    }\n  }\n  return scrollMap;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/scrubException.ts\":\n/*!*********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/scrubException.ts ***!\n  \\*********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_207320__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_207320__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.scrubException = scrubException;\nvar _typeof2 = _interopRequireDefault(__nested_webpack_require_207320__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction isScalar(value) {\n  return /boolean|number|string/.test((0, _typeof2.default)(value));\n}\nvar optionalScalars = [\n// Valid values for 'level' are 'fatal', 'error', 'warning', 'info',\n// and 'debug'. Defaults to 'error'.\n'level', 'logger'];\nvar optionalMaps = ['tags', 'extra'];\nfunction scrubException(data, options) {\n  if (options) {\n    var _iterator = _createForOfIteratorHelper(optionalScalars),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var field = _step.value;\n        var value = options[field];\n        if (isScalar(value)) {\n          // eslint-disable-next-line no-param-reassign\n          data[field] = value.toString();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper(optionalMaps),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _field = _step2.value;\n        var dirty = options[_field] || {};\n        var scrubbed = {};\n        for (var _i = 0, _Object$keys = Object.keys(dirty); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          var _value = dirty[key];\n          if (isScalar(_value)) {\n            scrubbed[key.toString()] = _value.toString();\n          }\n        }\n\n        // eslint-disable-next-line no-param-reassign\n        data[_field] = scrubbed;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/selectorFromNodePath.js\":\n/*!***************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/selectorFromNodePath.js ***!\n  \\***************************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_211239__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_211239__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = selectorFromNodePath;\nvar _toConsumableArray2 = _interopRequireDefault(__nested_webpack_require_211239__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction selectorFromNodePath() {\n  var nodePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var selectors = [];\n  // NodePaths are { nodeName: String, classList: [String], id: String }\n  var _iterator = _createForOfIteratorHelper((0, _toConsumableArray2.default)(nodePath).reverse()),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var path = _step.value;\n      var nodeName = path.nodeName,\n        id = path.id,\n        nthChild = path.nthChild;\n      var classList = path.classList;\n      var selectorParts = [];\n\n      // pseudo classes\n      var pseudoClassList = [];\n      nthChild && pseudoClassList.push(\"nth-child(\".concat(nthChild, \")\"));\n      // ... more as we decide to support them\n\n      if (nodeName) {\n        selectorParts.push(nodeName);\n        pseudoClassList.sort().map(function (pseudoClass) {\n          return selectorParts.push(\":\".concat(pseudoClass));\n        });\n      }\n      if (id) {\n        selectorParts.push(\"#\".concat(id));\n      }\n      if (classList && classList.length) {\n        classList = classList.map(function (value) {\n          return value.toLowerCase();\n        }).sort();\n        selectorParts = [].concat((0, _toConsumableArray2.default)(selectorParts), (0, _toConsumableArray2.default)(classList.map(function (className) {\n          return \".\".concat(className);\n        })));\n      }\n      if (selectorParts.length) {\n        selectors.push(selectorParts.join(' '));\n      }\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return selectors.join(' > ');\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/selectorMatches.js\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/selectorMatches.js ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_215320__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_215320__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = selectorMatches;\nvar _toConsumableArray2 = _interopRequireDefault(__nested_webpack_require_215320__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\nvar _typeof2 = _interopRequireDefault(__nested_webpack_require_215320__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\nvar _findIndex = _interopRequireDefault(__nested_webpack_require_215320__(/*! ./findIndex */ \"./packages/@logrocket/utils/src/findIndex.js\"));\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n// checks that nodeB fulfills all requirements specified in nodeA\nfunction nodesMatch(nodeA, nodeB) {\n  if (!(nodeA && nodeB)) {\n    return false;\n  }\n  if (nodeA.id && nodeA.id !== nodeB.id) {\n    return false;\n  }\n  if (nodeA.nodeName && nodeA.nodeName !== nodeB.nodeName) {\n    return false;\n  }\n  if (nodeA.classList && (!nodeB.classList || nodeA.classList.map(function (classNameA) {\n    return classNameA.toLowerCase();\n  }).some(function (classNameA) {\n    return nodeB.classList.map(function (classNameB) {\n      return classNameB.toLowerCase();\n    }).indexOf(classNameA) === -1;\n  }))) {\n    return false;\n  }\n  if (nodeA.nthChild) {\n    var parsed = parseInt(nodeA.nthChild, 10);\n    if (isNaN(parsed)) {\n      return Math.abs(nodeB.nthChild % 2) === (nodeA.nthChild === 'odd' ? 1 : 0);\n    }\n    return parsed === nodeB.nthChild;\n  }\n  return true;\n}\n\n// checks that nodePath includes, in order, all nodes specified in parsedSelector\nfunction selectorMatches(nodePath, parsedSelector) {\n  var topDownNodePath = nodePath.slice(0).reverse();\n  var matchIndex;\n  var _iterator = _createForOfIteratorHelper(parsedSelector),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var selectorNode = _step.value;\n      if (selectorNode.directDesc) {\n        if (nodesMatch.apply(void 0, [selectorNode].concat((0, _toConsumableArray2.default)(topDownNodePath.splice(0, 1))))) {\n          return \"continue\";\n        } else {\n          return {\n            v: false\n          };\n        }\n      }\n      matchIndex = (0, _findIndex.default)(topDownNodePath, function (pathNode) {\n        return nodesMatch(selectorNode, pathNode);\n      });\n      if (matchIndex === -1) {\n        return {\n          v: false\n        };\n      }\n      topDownNodePath.splice(0, matchIndex + 1);\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n      if ((0, _typeof2.default)(_ret) === \"object\") return _ret.v;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return true;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/sendTelemetryData.js\":\n/*!************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/sendTelemetryData.js ***!\n  \\************************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_220094__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_220094__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.sendTelemetry = sendTelemetry;\nexports[\"default\"] = sendErrorTelemetry;\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_220094__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _logError = _interopRequireDefault(__nested_webpack_require_220094__(/*! ./logError */ \"./packages/@logrocket/utils/src/logError.js\"));\nvar _TraceKit = _interopRequireDefault(__nested_webpack_require_220094__(/*! ./TraceKit */ \"./packages/@logrocket/utils/src/TraceKit.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// eslint-disable-next-line no-undef\nvar SCRIPT_VERSION =   true ? \"b0db2bde13abbdaac4ddf7651e7be60eb639ccf7\" : 0;\nfunction _sendToSentry(data) {\n  var XHR = window._lrXMLHttpRequest || XMLHttpRequest;\n  try {\n    var req = new XHR();\n    var message = data.message;\n    var url = 'https://e.logrocket.com/api/3/store/?sentry_version=7&sentry_client=http%2F3.8.0&sentry_key=b64162b4187a4c5caae8a68a7e291793';\n    req.open('POST', url);\n    req.send(JSON.stringify(_objectSpread({\n      message: message,\n      logger: 'javascript',\n      platform: 'javascript',\n      request: {\n        headers: {\n          'User-Agent': typeof navigator !== 'undefined' && navigator.userAgent\n        },\n        url: typeof location !== 'undefined' && location.href\n      },\n      release: SCRIPT_VERSION,\n      environment:   false || 'test'\n    }, data)));\n  } catch (err) {\n    (0, _logError.default)('Failed to send', err);\n  }\n}\nfunction sendTelemetry(message, more) {\n  if (typeof window !== 'undefined' && window._lrdebug) {\n    return void (0, _logError.default)(message);\n  }\n  if (more && more.extra && more.extra.appID && typeof more.extra.appID.indexOf === 'function' && more.extra.appID.indexOf('au2drp/') === 0 && Math.random() >= 0.25) {\n    return;\n  }\n  _sendToSentry(_objectSpread({\n    message: message\n  }, more));\n}\nfunction sendErrorTelemetry(err, payload) {\n  try {\n    var message = err.message;\n    var stringPayload;\n    try {\n      stringPayload = JSON.stringify(payload).slice(0, 1000);\n    } catch (err) {\n      try {\n        stringPayload = \"Could not stringify payload: \".concat(Object.prototype.toString.call(payload));\n      } catch (err) {/* nada */}\n    }\n    var stack;\n    try {\n      stack = _TraceKit.default.computeStackTrace(err).stack.map(function (frame) {\n        return {\n          filename: frame.url,\n          lineno: frame.line,\n          colno: frame.column,\n          function: frame.func || '?'\n        };\n      });\n    } catch (err) {\n      /* nada */\n    }\n    _sendToSentry({\n      message: message,\n      extra: {\n        stringPayload: stringPayload\n      },\n      exception: {\n        values: [{\n          type: err.type,\n          value: message,\n          stacktrace: {\n            frames: stack\n          }\n        }]\n      }\n    });\n  } catch (err) {\n    (0, _logError.default)('Failed to send', err);\n  }\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/setFromArray.js\":\n/*!*******************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/setFromArray.js ***!\n  \\*******************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = setFromArray;\nfunction setFromArray(array) {\n  var set = new Set();\n  array.forEach(function (el) {\n    return set.add(el);\n  });\n  return set;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/setToArray.js\":\n/*!*****************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/setToArray.js ***!\n  \\*****************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = setToArray;\nfunction setToArray(set) {\n  var array = [];\n  set.forEach(function (el) {\n    return array.push(el);\n  });\n  return array;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/shallowArsonify.js\":\n/*!**********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/shallowArsonify.js ***!\n  \\**********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = shallowArsonify;\nfunction shallowArsonify(value) {\n  var type = {}.toString.call(value);\n  switch (type) {\n    case '[object Undefined]':\n      {\n        return {\n          undefined: {}\n        };\n      }\n    case '[object Null]':\n      {\n        return {\n          null: {}\n        };\n      }\n    case '[object Boolean]':\n      {\n        return {\n          boolean: {\n            bool: value\n          }\n        };\n      }\n    case '[object Number]':\n      {\n        return {\n          number: {\n            double: value\n          }\n        };\n      }\n    case '[object String]':\n      {\n        return {\n          string: {\n            string: value\n          }\n        };\n      }\n    case '[object Object]':\n      {\n        return {\n          object: {\n            map: value\n          }\n        };\n      }\n    case '[object Array]':\n      {\n        return {\n          array: {\n            map: value\n          }\n        };\n      }\n    case '[object Date]':\n      {\n        return {\n          date: {\n            double: value.getTime()\n          }\n        };\n      }\n    case '[object Error]':\n      {\n        return {\n          string: {\n            string: \"\".concat(value.name, \": \").concat(value.message)\n          }\n        };\n      }\n    default:\n      {\n        return {\n          unsupported: {\n            type: type\n          }\n        };\n      }\n  }\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/shallowDearsonify.js\":\n/*!************************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/shallowDearsonify.js ***!\n  \\************************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = shallowDearsonify;\n/* eslint-disable consistent-return */\n\nfunction shallowDearsonify(value) {\n  var type = value.type || Object.keys(value)[0];\n  switch (type) {\n    case 'undefined':\n      {\n        return undefined;\n      }\n    case 'null':\n      {\n        return null;\n      }\n    case 'boolean':\n      {\n        return value.boolean.bool;\n      }\n    case 'number':\n      {\n        return value.number.double;\n      }\n    case 'string':\n      {\n        return value.string.string;\n      }\n    case 'object':\n      {\n        return value.object.map;\n      }\n    case 'array':\n      {\n        return Object.keys(value.array.map).reduce(function (array, key) {\n          // eslint-disable-next-line no-param-reassign\n          array[key] = value.array.map[key];\n          return array;\n        }, []);\n      }\n    case 'date':\n      {\n        return new Date(value.date.double);\n      }\n    case 'unsupported':\n      {\n        return value.unsupported.type;\n      }\n    default:\n      {\n        /* istanbul ignore next */\n        throw new TypeError(\"Unexpected value in shallowDearsonify: \".concat(value));\n      }\n  }\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/startsWith.js\":\n/*!*****************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/startsWith.js ***!\n  \\*****************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = startsWith;\nfunction startsWith(value, search) {\n  var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return value && search && value.substring(pos, pos + search.length) === search;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/types.ts\":\n/*!************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/types.ts ***!\n  \\************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/userTraitStrings.ts\":\n/*!***********************************************************!*\\\n  !*** ./packages/@logrocket/utils/src/userTraitStrings.ts ***!\n  \\***********************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.parseUserTraitString = exports.encodeUserTraitString = void 0;\n// Character used to separate key/value pairs when concatenated, i.e. \"key:value\":\nvar USER_TRAIT_DELIMITER = ':';\n\n// String used to temporarily escape above value when included in a user-defined string:\nvar delimiterReplace = String.fromCharCode(26);\n\n/** Encode strings to be used as a custom key-value pair, ex. for user traits */\nvar encodeUserTraitString = function encodeUserTraitString() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return args\n  // Escape instances of delimiter value in user-defined text:\n  .map(function (str) {\n    return str.replace(new RegExp(USER_TRAIT_DELIMITER, 'g'), delimiterReplace);\n  }).join(USER_TRAIT_DELIMITER);\n};\n\n/** Split encoded user trait string into original key & value */\nexports.encodeUserTraitString = encodeUserTraitString;\nvar parseUserTraitString = function parseUserTraitString(string) {\n  var nonEmptyStr = string || USER_TRAIT_DELIMITER; // Ensure at least two strings will be returned\n  return nonEmptyStr.split(USER_TRAIT_DELIMITER)\n  // Restore previously escaped instances of delimiter character:\n  .map(function (str) {\n    return str.replace(new RegExp(delimiterReplace, 'g'), USER_TRAIT_DELIMITER);\n  });\n};\nexports.parseUserTraitString = parseUserTraitString;\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/src/uuid.js\":\n/*!***********************************************!*\\\n  !*** ./packages/@logrocket/utils/src/uuid.js ***!\n  \\***********************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = uuid;\n// https://gist.github.com/jed/982883\n// eslint-disable-next-line\nfunction uuid(a) {\n  return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);\n}\n\n/***/ }),\n\n/***/ \"./packages/logrocket/src/LogRocket.js\":\n/*!*********************************************!*\\\n  !*** ./packages/logrocket/src/LogRocket.js ***!\n  \\*********************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_232142__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_232142__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = exports.MAX_QUEUE_SIZE = void 0;\nvar _classCallCheck2 = _interopRequireDefault(__nested_webpack_require_232142__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\nvar _createClass2 = _interopRequireDefault(__nested_webpack_require_232142__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\nvar _defineProperty2 = _interopRequireDefault(__nested_webpack_require_232142__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _objectWithoutProperties2 = _interopRequireDefault(__nested_webpack_require_232142__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"./node_modules/@babel/runtime/helpers/objectWithoutProperties.js\"));\nvar _network = _interopRequireDefault(__nested_webpack_require_232142__(/*! @logrocket/network */ \"./packages/@logrocket/network/src/index.js\"));\nvar _exceptions = __nested_webpack_require_232142__(/*! @logrocket/exceptions */ \"./packages/@logrocket/exceptions/src/index.js\");\nvar _console = _interopRequireDefault(__nested_webpack_require_232142__(/*! @logrocket/console */ \"./packages/@logrocket/console/src/index.js\"));\nvar _redux = __nested_webpack_require_232142__(/*! @logrocket/redux */ \"./packages/@logrocket/redux/src/index.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar MAX_QUEUE_SIZE = 1000;\nexports.MAX_QUEUE_SIZE = MAX_QUEUE_SIZE;\nvar considerIngestServerOption = function considerIngestServerOption() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    ingestServer = _ref.ingestServer,\n    options = (0, _objectWithoutProperties2.default)(_ref, [\"ingestServer\"]);\n  if (ingestServer) {\n    return _objectSpread({\n      serverURL: \"\".concat(ingestServer, \"/i\"),\n      statsURL: \"\".concat(ingestServer, \"/s\")\n    }, options);\n  }\n  return options;\n};\nvar LogRocket = /*#__PURE__*/function () {\n  function LogRocket() {\n    var _this = this;\n    (0, _classCallCheck2.default)(this, LogRocket);\n    this._buffer = [];\n    // TODO: tests for these exposed methods.\n    ['log', 'info', 'warn', 'error', 'debug'].forEach(function (method) {\n      _this[method] = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this.addEvent('lr.core.LogEvent', function () {\n          var consoleOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          if (method === 'error' && consoleOptions.shouldAggregateConsoleErrors) {\n            _exceptions.Capture.captureMessage(_this, args[0], args, {}, true);\n          }\n          return {\n            logLevel: method.toUpperCase(),\n            args: args\n          };\n        }, {\n          shouldCaptureStackTrace: true\n        });\n      };\n    });\n    this._isInitialized = false;\n    this._installed = [];\n\n    // expose a callback to get the session URL from the global context\n    window._lr_surl_cb = this.getSessionURL.bind(this);\n  }\n  (0, _createClass2.default)(LogRocket, [{\n    key: \"addEvent\",\n    value: function addEvent(type, getMessage) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var time = Date.now();\n      this._run(function (logger) {\n        logger.addEvent(type, getMessage, _objectSpread(_objectSpread({}, opts), {}, {\n          timeOverride: time\n        }));\n      });\n    }\n  }, {\n    key: \"onLogger\",\n    value: function onLogger(logger) {\n      this._logger = logger;\n      while (this._buffer.length > 0) {\n        var f = this._buffer.shift();\n        f(this._logger);\n      }\n    }\n  }, {\n    key: \"_run\",\n    value: function _run(f) {\n      if (this._isDisabled) {\n        return;\n      }\n      if (this._logger) {\n        f(this._logger);\n      } else {\n        if (this._buffer.length >= MAX_QUEUE_SIZE) {\n          this._isDisabled = true;\n          console.warn('LogRocket: script did not load. Check that you have a valid network connection.');\n          this.uninstall();\n          return;\n        }\n        this._buffer.push(f.bind(this));\n      }\n    }\n  }, {\n    key: \"init\",\n    value: function init(appID) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!this._isInitialized) {\n        var _opts$shouldAugmentNP = opts.shouldAugmentNPS,\n          shouldAugmentNPS = _opts$shouldAugmentNP === void 0 ? true : _opts$shouldAugmentNP,\n          _opts$shouldParseXHRB = opts.shouldParseXHRBlob,\n          shouldParseXHRBlob = _opts$shouldParseXHRB === void 0 ? false : _opts$shouldParseXHRB,\n          _opts$shouldDetectExc = opts.shouldDetectExceptions,\n          shouldDetectExceptions = _opts$shouldDetectExc === void 0 ? true : _opts$shouldDetectExc;\n        if (shouldDetectExceptions) {\n          this._installed.push((0, _exceptions.registerExceptions)(this));\n        }\n        this._installed.push((0, _network.default)(this, {\n          shouldAugmentNPS: !!shouldAugmentNPS,\n          shouldParseXHRBlob: !!shouldParseXHRBlob\n        }));\n        this._installed.push((0, _console.default)(this));\n        this._isInitialized = true;\n        this._run(function (logger) {\n          logger.init(appID, considerIngestServerOption(opts));\n        });\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._run(function (logger) {\n        logger.start();\n      });\n    }\n  }, {\n    key: \"uninstall\",\n    value: function uninstall() {\n      this._installed.forEach(function (f) {\n        return f();\n      });\n      this._buffer = [];\n      this._run(function (logger) {\n        logger.uninstall();\n      });\n    }\n  }, {\n    key: \"identify\",\n    value: function identify(id, opts) {\n      this._run(function (logger) {\n        logger.identify(id, opts);\n      });\n    }\n  }, {\n    key: \"startNewSession\",\n    value: function startNewSession() {\n      this._run(function (logger) {\n        logger.startNewSession();\n      });\n    }\n  }, {\n    key: \"track\",\n    value: function track(customEventName, eventProperties) {\n      this._run(function (logger) {\n        logger.track(customEventName, eventProperties);\n      });\n    }\n  }, {\n    key: \"getSessionURL\",\n    value: function getSessionURL(cb) {\n      if (typeof cb !== 'function') {\n        throw new Error('LogRocket: must pass callback to getSessionURL()');\n      }\n      this._run(function (logger) {\n        if (logger.getSessionURL) {\n          logger.getSessionURL(cb);\n        } else {\n          cb(logger.recordingURL);\n        }\n      });\n    }\n  }, {\n    key: \"getVersion\",\n    value: function getVersion(cb) {\n      this._run(function (logger) {\n        cb(logger.version);\n      });\n    }\n  }, {\n    key: \"captureMessage\",\n    value: function captureMessage(message) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _exceptions.Capture.captureMessage(this, message, [message], options);\n    }\n  }, {\n    key: \"captureException\",\n    value: function captureException(exception) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _exceptions.Capture.captureException(this, exception, options);\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return this._logger && this._logger.version;\n    }\n  }, {\n    key: \"sessionURL\",\n    get: function get() {\n      return this._logger && this._logger.recordingURL;\n    }\n  }, {\n    key: \"recordingURL\",\n    get: function get() {\n      return this._logger && this._logger.recordingURL;\n    }\n  }, {\n    key: \"recordingID\",\n    get: function get() {\n      return this._logger && this._logger.recordingID;\n    }\n  }, {\n    key: \"threadID\",\n    get: function get() {\n      return this._logger && this._logger.threadID;\n    }\n  }, {\n    key: \"tabID\",\n    get: function get() {\n      return this._logger && this._logger.tabID;\n    }\n  }, {\n    key: \"reduxEnhancer\",\n    value: function reduxEnhancer() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return (0, _redux.createEnhancer)(this, options);\n    }\n  }, {\n    key: \"reduxMiddleware\",\n    value: function reduxMiddleware() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return (0, _redux.createMiddleware)(this, options);\n    }\n  }, {\n    key: \"isDisabled\",\n    get: function get() {\n      return !!(this._isDisabled || this._logger && this._logger._isDisabled);\n    }\n  }]);\n  return LogRocket;\n}();\nexports[\"default\"] = LogRocket;\n\n/***/ }),\n\n/***/ \"./packages/logrocket/src/makeLogRocket.js\":\n/*!*************************************************!*\\\n  !*** ./packages/logrocket/src/makeLogRocket.js ***!\n  \\*************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_242049__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_242049__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = makeLogRocket;\nvar _LogRocket = _interopRequireDefault(__nested_webpack_require_242049__(/*! ./LogRocket */ \"./packages/logrocket/src/LogRocket.js\"));\nvar REACT_NATIVE_NOTICE = 'LogRocket does not yet support React Native.';\nvar makeNoopPolyfill = function makeNoopPolyfill() {\n  return {\n    init: function init() {},\n    uninstall: function uninstall() {},\n    log: function log() {},\n    info: function info() {},\n    warn: function warn() {},\n    error: function error() {},\n    debug: function debug() {},\n    addEvent: function addEvent() {},\n    identify: function identify() {},\n    start: function start() {},\n    get threadID() {\n      return null;\n    },\n    get recordingID() {\n      return null;\n    },\n    get recordingURL() {\n      return null;\n    },\n    reduxEnhancer: function reduxEnhancer() {\n      return function (store) {\n        return function () {\n          return store.apply(void 0, arguments);\n        };\n      };\n    },\n    reduxMiddleware: function reduxMiddleware() {\n      return function () {\n        return function (next) {\n          return function (action) {\n            return next(action);\n          };\n        };\n      };\n    },\n    track: function track() {},\n    getSessionURL: function getSessionURL() {},\n    getVersion: function getVersion() {},\n    startNewSession: function startNewSession() {},\n    onLogger: function onLogger() {},\n    setClock: function setClock() {},\n    captureMessage: function captureMessage() {},\n    captureException: function captureException() {}\n  };\n};\nfunction makeLogRocket() {\n  var getLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    throw new Error(REACT_NATIVE_NOTICE);\n  }\n  if (typeof window !== 'undefined') {\n    if (window._disableLogRocket) {\n      return makeNoopPolyfill();\n    }\n    if (window.MutationObserver && window.WeakMap) {\n      // Save window globals that we rely on.\n      window._lrMutationObserver = window.MutationObserver;\n      var instance = new _LogRocket.default();\n      getLogger(instance);\n      return instance;\n    }\n  }\n  return makeNoopPolyfill();\n}\n\n/***/ }),\n\n/***/ \"./packages/logrocket/src/setup.js\":\n/*!*****************************************!*\\\n  !*** ./packages/logrocket/src/setup.js ***!\n  \\*****************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_244774__) {\n\n\"use strict\";\n\n\nvar _interopRequireDefault = __nested_webpack_require_244774__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = setup;\nvar _objectWithoutProperties2 = _interopRequireDefault(__nested_webpack_require_244774__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"./node_modules/@babel/runtime/helpers/objectWithoutProperties.js\"));\nvar _makeLogRocket = _interopRequireDefault(__nested_webpack_require_244774__(/*! ./makeLogRocket */ \"./packages/logrocket/src/makeLogRocket.js\"));\nvar CDN_SERVER_MAP = {\n  'cdn.logrocket.io': 'https://r.logrocket.io',\n  'cdn.lr-ingest.io': 'https://r.lr-ingest.io',\n  'cdn.lr-in.com': 'https://r.lr-in.com',\n  'cdn.lr-in-prod.com': 'https://r.lr-in-prod.com',\n  'cdn.lr-ingest.com': 'https://r.lr-ingest.com',\n  'cdn.ingest-lr.com': 'https://r.ingest-lr.com',\n  'cdn.lr-intake.com': 'https://r.lr-intake.com',\n  'cdn-staging.logrocket.io': 'https://staging-i.logrocket.io',\n  'cdn-staging.lr-ingest.io': 'https://staging-i.lr-ingest.io',\n  'cdn-staging.lr-in.com': 'https://staging-i.lr-in.com',\n  'cdn-staging.lr-in-prod.com': 'https://staging-i.lr-in-prod.com',\n  'cdn-staging.lr-ingest.com': 'https://staging-i.lr-ingest.com',\n  'cdn-staging.ingest-lr.com': 'https://staging-i.ingest-lr.com',\n  'cdn-staging.lr-intake.com': 'https://staging-i.lr-intake.com'\n};\nfunction setup() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    enterpriseServer = _ref.enterpriseServer,\n    _ref$sdkVersion = _ref.sdkVersion,\n    sdkVersion = _ref$sdkVersion === void 0 ? \"6.0.1\" : _ref$sdkVersion,\n    opts = (0, _objectWithoutProperties2.default)(_ref, [\"enterpriseServer\", \"sdkVersion\"]);\n  var scriptOrigin =   false ? 0 : 'https://cdn.logrocket.io';\n  var scriptIngest;\n  if (sdkVersion === 'script') {\n    try {\n      // eslint-disable-next-line compat/compat\n      var scriptTag = document.currentScript;\n      var matches = scriptTag.src.match(/^(https?:\\/\\/([^\\\\]+))\\/.+$/);\n      var scriptHostname = matches && matches[2];\n      if (scriptHostname && CDN_SERVER_MAP[scriptHostname]) {\n        scriptOrigin = matches && matches[1];\n        scriptIngest = CDN_SERVER_MAP[scriptHostname];\n      }\n    } catch (_) {\n      /* no-op */\n    }\n  } else {\n    // NPM\n    scriptOrigin =   false ? 0 : 'https://cdn.lr-intake.com';\n    scriptIngest =   false ? 0 : 'https://r.lr-intake.com';\n  }\n  var sdkServer = opts.sdkServer || enterpriseServer;\n  var ingestServer = opts.ingestServer || enterpriseServer || scriptIngest;\n  var instance = (0, _makeLogRocket.default)(function () {\n    var script = document.createElement('script');\n    if (ingestServer) {\n      if (typeof window.__SDKCONFIG__ === 'undefined') {\n        window.__SDKCONFIG__ = {};\n      }\n      window.__SDKCONFIG__.serverURL = \"\".concat(ingestServer, \"/i\");\n      window.__SDKCONFIG__.statsURL = \"\".concat(ingestServer, \"/s\");\n    }\n    if (sdkServer) {\n      script.src = \"\".concat(sdkServer, \"/logger.min.js\");\n    } else if (window.__SDKCONFIG__ && window.__SDKCONFIG__.loggerURL) {\n      script.src = window.__SDKCONFIG__.loggerURL;\n    } else if (window._lrAsyncScript) {\n      script.src = window._lrAsyncScript;\n    } else {\n      script.src = \"\".concat(scriptOrigin, \"/logger-1.min.js\");\n    }\n    script.async = true;\n    document.head.appendChild(script);\n    script.onload = function () {\n      // Brave browser: Advertises its user-agent as Chrome ##.##... then\n      // loads logger.min.js, but blocks the execution of the script\n      // causing _LRlogger to be undefined.  Let's make sure its there first.\n      if (typeof window._LRLogger === 'function') {\n        instance.onLogger(new window._LRLogger({\n          sdkVersion: sdkVersion\n        }));\n      } else {\n        console.warn('LogRocket: script execution has been blocked by a product or service.');\n        instance.uninstall();\n      }\n    };\n    script.onerror = function () {\n      console.warn('LogRocket: script could not load. Check that you have a valid network connection.');\n      instance.uninstall();\n    };\n  });\n  return instance;\n}\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_DataView.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_DataView.js ***!\n  \\********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_249336__) {\n\nvar getNative = __nested_webpack_require_249336__(/*! ./_getNative */ \"./packages/@logrocket/utils/node_modules/lodash/_getNative.js\"),\n    root = __nested_webpack_require_249336__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_Hash.js\":\n/*!****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_Hash.js ***!\n  \\****************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_250065__) {\n\nvar hashClear = __nested_webpack_require_250065__(/*! ./_hashClear */ \"./packages/@logrocket/utils/node_modules/lodash/_hashClear.js\"),\n    hashDelete = __nested_webpack_require_250065__(/*! ./_hashDelete */ \"./packages/@logrocket/utils/node_modules/lodash/_hashDelete.js\"),\n    hashGet = __nested_webpack_require_250065__(/*! ./_hashGet */ \"./packages/@logrocket/utils/node_modules/lodash/_hashGet.js\"),\n    hashHas = __nested_webpack_require_250065__(/*! ./_hashHas */ \"./packages/@logrocket/utils/node_modules/lodash/_hashHas.js\"),\n    hashSet = __nested_webpack_require_250065__(/*! ./_hashSet */ \"./packages/@logrocket/utils/node_modules/lodash/_hashSet.js\");\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_ListCache.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_ListCache.js ***!\n  \\*********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_251594__) {\n\nvar listCacheClear = __nested_webpack_require_251594__(/*! ./_listCacheClear */ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheClear.js\"),\n    listCacheDelete = __nested_webpack_require_251594__(/*! ./_listCacheDelete */ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheDelete.js\"),\n    listCacheGet = __nested_webpack_require_251594__(/*! ./_listCacheGet */ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheGet.js\"),\n    listCacheHas = __nested_webpack_require_251594__(/*! ./_listCacheHas */ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheHas.js\"),\n    listCacheSet = __nested_webpack_require_251594__(/*! ./_listCacheSet */ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheSet.js\");\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_Map.js\":\n/*!***************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_Map.js ***!\n  \\***************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_253246__) {\n\nvar getNative = __nested_webpack_require_253246__(/*! ./_getNative */ \"./packages/@logrocket/utils/node_modules/lodash/_getNative.js\"),\n    root = __nested_webpack_require_253246__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_MapCache.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_MapCache.js ***!\n  \\********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_253976__) {\n\nvar mapCacheClear = __nested_webpack_require_253976__(/*! ./_mapCacheClear */ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheClear.js\"),\n    mapCacheDelete = __nested_webpack_require_253976__(/*! ./_mapCacheDelete */ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheDelete.js\"),\n    mapCacheGet = __nested_webpack_require_253976__(/*! ./_mapCacheGet */ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheGet.js\"),\n    mapCacheHas = __nested_webpack_require_253976__(/*! ./_mapCacheHas */ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheHas.js\"),\n    mapCacheSet = __nested_webpack_require_253976__(/*! ./_mapCacheSet */ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheSet.js\");\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_Promise.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_Promise.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_255639__) {\n\nvar getNative = __nested_webpack_require_255639__(/*! ./_getNative */ \"./packages/@logrocket/utils/node_modules/lodash/_getNative.js\"),\n    root = __nested_webpack_require_255639__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_Set.js\":\n/*!***************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_Set.js ***!\n  \\***************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_256361__) {\n\nvar getNative = __nested_webpack_require_256361__(/*! ./_getNative */ \"./packages/@logrocket/utils/node_modules/lodash/_getNative.js\"),\n    root = __nested_webpack_require_256361__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_SetCache.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_SetCache.js ***!\n  \\********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_257091__) {\n\nvar MapCache = __nested_webpack_require_257091__(/*! ./_MapCache */ \"./packages/@logrocket/utils/node_modules/lodash/_MapCache.js\"),\n    setCacheAdd = __nested_webpack_require_257091__(/*! ./_setCacheAdd */ \"./packages/@logrocket/utils/node_modules/lodash/_setCacheAdd.js\"),\n    setCacheHas = __nested_webpack_require_257091__(/*! ./_setCacheHas */ \"./packages/@logrocket/utils/node_modules/lodash/_setCacheHas.js\");\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_Stack.js\":\n/*!*****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_Stack.js ***!\n  \\*****************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_258335__) {\n\nvar ListCache = __nested_webpack_require_258335__(/*! ./_ListCache */ \"./packages/@logrocket/utils/node_modules/lodash/_ListCache.js\"),\n    stackClear = __nested_webpack_require_258335__(/*! ./_stackClear */ \"./packages/@logrocket/utils/node_modules/lodash/_stackClear.js\"),\n    stackDelete = __nested_webpack_require_258335__(/*! ./_stackDelete */ \"./packages/@logrocket/utils/node_modules/lodash/_stackDelete.js\"),\n    stackGet = __nested_webpack_require_258335__(/*! ./_stackGet */ \"./packages/@logrocket/utils/node_modules/lodash/_stackGet.js\"),\n    stackHas = __nested_webpack_require_258335__(/*! ./_stackHas */ \"./packages/@logrocket/utils/node_modules/lodash/_stackHas.js\"),\n    stackSet = __nested_webpack_require_258335__(/*! ./_stackSet */ \"./packages/@logrocket/utils/node_modules/lodash/_stackSet.js\");\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_Symbol.js\":\n/*!******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_Symbol.js ***!\n  \\******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_259925__) {\n\nvar root = __nested_webpack_require_259925__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_Uint8Array.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_Uint8Array.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_260505__) {\n\nvar root = __nested_webpack_require_260505__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\");\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_WeakMap.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_WeakMap.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_261085__) {\n\nvar getNative = __nested_webpack_require_261085__(/*! ./_getNative */ \"./packages/@logrocket/utils/node_modules/lodash/_getNative.js\"),\n    root = __nested_webpack_require_261085__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_arrayFilter.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_arrayFilter.js ***!\n  \\***********************************************************************/\n/***/ (function(module) {\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_arrayLikeKeys.js\":\n/*!*************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_arrayLikeKeys.js ***!\n  \\*************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_262822__) {\n\nvar baseTimes = __nested_webpack_require_262822__(/*! ./_baseTimes */ \"./packages/@logrocket/utils/node_modules/lodash/_baseTimes.js\"),\n    isArguments = __nested_webpack_require_262822__(/*! ./isArguments */ \"./packages/@logrocket/utils/node_modules/lodash/isArguments.js\"),\n    isArray = __nested_webpack_require_262822__(/*! ./isArray */ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\"),\n    isBuffer = __nested_webpack_require_262822__(/*! ./isBuffer */ \"./packages/@logrocket/utils/node_modules/lodash/isBuffer.js\"),\n    isIndex = __nested_webpack_require_262822__(/*! ./_isIndex */ \"./packages/@logrocket/utils/node_modules/lodash/_isIndex.js\"),\n    isTypedArray = __nested_webpack_require_262822__(/*! ./isTypedArray */ \"./packages/@logrocket/utils/node_modules/lodash/isTypedArray.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_arrayMap.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_arrayMap.js ***!\n  \\********************************************************************/\n/***/ (function(module) {\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_arrayPush.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_arrayPush.js ***!\n  \\*********************************************************************/\n/***/ (function(module) {\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_arraySome.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_arraySome.js ***!\n  \\*********************************************************************/\n/***/ (function(module) {\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_268064__) {\n\nvar eq = __nested_webpack_require_268064__(/*! ./eq */ \"./packages/@logrocket/utils/node_modules/lodash/eq.js\");\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseGet.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseGet.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_268998__) {\n\nvar castPath = __nested_webpack_require_268998__(/*! ./_castPath */ \"./packages/@logrocket/utils/node_modules/lodash/_castPath.js\"),\n    toKey = __nested_webpack_require_268998__(/*! ./_toKey */ \"./packages/@logrocket/utils/node_modules/lodash/_toKey.js\");\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseGetAllKeys.js\":\n/*!**************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseGetAllKeys.js ***!\n  \\**************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_270173__) {\n\nvar arrayPush = __nested_webpack_require_270173__(/*! ./_arrayPush */ \"./packages/@logrocket/utils/node_modules/lodash/_arrayPush.js\"),\n    isArray = __nested_webpack_require_270173__(/*! ./isArray */ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\");\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_271457__) {\n\nvar Symbol = __nested_webpack_require_271457__(/*! ./_Symbol */ \"./packages/@logrocket/utils/node_modules/lodash/_Symbol.js\"),\n    getRawTag = __nested_webpack_require_271457__(/*! ./_getRawTag */ \"./packages/@logrocket/utils/node_modules/lodash/_getRawTag.js\"),\n    objectToString = __nested_webpack_require_271457__(/*! ./_objectToString */ \"./packages/@logrocket/utils/node_modules/lodash/_objectToString.js\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseHasIn.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseHasIn.js ***!\n  \\*********************************************************************/\n/***/ (function(module) {\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsArguments.js\":\n/*!***************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsArguments.js ***!\n  \\***************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_273609__) {\n\nvar baseGetTag = __nested_webpack_require_273609__(/*! ./_baseGetTag */ \"./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js\"),\n    isObjectLike = __nested_webpack_require_273609__(/*! ./isObjectLike */ \"./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsEqual.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsEqual.js ***!\n  \\***********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_274652__) {\n\nvar baseIsEqualDeep = __nested_webpack_require_274652__(/*! ./_baseIsEqualDeep */ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsEqualDeep.js\"),\n    isObjectLike = __nested_webpack_require_274652__(/*! ./isObjectLike */ \"./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js\");\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsEqualDeep.js\":\n/*!***************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsEqualDeep.js ***!\n  \\***************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_276247__) {\n\nvar Stack = __nested_webpack_require_276247__(/*! ./_Stack */ \"./packages/@logrocket/utils/node_modules/lodash/_Stack.js\"),\n    equalArrays = __nested_webpack_require_276247__(/*! ./_equalArrays */ \"./packages/@logrocket/utils/node_modules/lodash/_equalArrays.js\"),\n    equalByTag = __nested_webpack_require_276247__(/*! ./_equalByTag */ \"./packages/@logrocket/utils/node_modules/lodash/_equalByTag.js\"),\n    equalObjects = __nested_webpack_require_276247__(/*! ./_equalObjects */ \"./packages/@logrocket/utils/node_modules/lodash/_equalObjects.js\"),\n    getTag = __nested_webpack_require_276247__(/*! ./_getTag */ \"./packages/@logrocket/utils/node_modules/lodash/_getTag.js\"),\n    isArray = __nested_webpack_require_276247__(/*! ./isArray */ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\"),\n    isBuffer = __nested_webpack_require_276247__(/*! ./isBuffer */ \"./packages/@logrocket/utils/node_modules/lodash/isBuffer.js\"),\n    isTypedArray = __nested_webpack_require_276247__(/*! ./isTypedArray */ \"./packages/@logrocket/utils/node_modules/lodash/isTypedArray.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsMatch.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsMatch.js ***!\n  \\***********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_280291__) {\n\nvar Stack = __nested_webpack_require_280291__(/*! ./_Stack */ \"./packages/@logrocket/utils/node_modules/lodash/_Stack.js\"),\n    baseIsEqual = __nested_webpack_require_280291__(/*! ./_baseIsEqual */ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsEqual.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsNative.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsNative.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_282610__) {\n\nvar isFunction = __nested_webpack_require_282610__(/*! ./isFunction */ \"./packages/@logrocket/utils/node_modules/lodash/isFunction.js\"),\n    isMasked = __nested_webpack_require_282610__(/*! ./_isMasked */ \"./packages/@logrocket/utils/node_modules/lodash/_isMasked.js\"),\n    isObject = __nested_webpack_require_282610__(/*! ./isObject */ \"./packages/@logrocket/utils/node_modules/lodash/isObject.js\"),\n    toSource = __nested_webpack_require_282610__(/*! ./_toSource */ \"./packages/@logrocket/utils/node_modules/lodash/_toSource.js\");\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsTypedArray.js\":\n/*!****************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsTypedArray.js ***!\n  \\****************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_284757__) {\n\nvar baseGetTag = __nested_webpack_require_284757__(/*! ./_baseGetTag */ \"./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js\"),\n    isLength = __nested_webpack_require_284757__(/*! ./isLength */ \"./packages/@logrocket/utils/node_modules/lodash/isLength.js\"),\n    isObjectLike = __nested_webpack_require_284757__(/*! ./isObjectLike */ \"./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseIteratee.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIteratee.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_287617__) {\n\nvar baseMatches = __nested_webpack_require_287617__(/*! ./_baseMatches */ \"./packages/@logrocket/utils/node_modules/lodash/_baseMatches.js\"),\n    baseMatchesProperty = __nested_webpack_require_287617__(/*! ./_baseMatchesProperty */ \"./packages/@logrocket/utils/node_modules/lodash/_baseMatchesProperty.js\"),\n    identity = __nested_webpack_require_287617__(/*! ./identity */ \"./packages/@logrocket/utils/node_modules/lodash/identity.js\"),\n    isArray = __nested_webpack_require_287617__(/*! ./isArray */ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\"),\n    property = __nested_webpack_require_287617__(/*! ./property */ \"./packages/@logrocket/utils/node_modules/lodash/property.js\");\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseKeys.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseKeys.js ***!\n  \\********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_289300__) {\n\nvar isPrototype = __nested_webpack_require_289300__(/*! ./_isPrototype */ \"./packages/@logrocket/utils/node_modules/lodash/_isPrototype.js\"),\n    nativeKeys = __nested_webpack_require_289300__(/*! ./_nativeKeys */ \"./packages/@logrocket/utils/node_modules/lodash/_nativeKeys.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseMatches.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseMatches.js ***!\n  \\***********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_290631__) {\n\nvar baseIsMatch = __nested_webpack_require_290631__(/*! ./_baseIsMatch */ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsMatch.js\"),\n    getMatchData = __nested_webpack_require_290631__(/*! ./_getMatchData */ \"./packages/@logrocket/utils/node_modules/lodash/_getMatchData.js\"),\n    matchesStrictComparable = __nested_webpack_require_290631__(/*! ./_matchesStrictComparable */ \"./packages/@logrocket/utils/node_modules/lodash/_matchesStrictComparable.js\");\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseMatchesProperty.js\":\n/*!*******************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseMatchesProperty.js ***!\n  \\*******************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_292025__) {\n\nvar baseIsEqual = __nested_webpack_require_292025__(/*! ./_baseIsEqual */ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsEqual.js\"),\n    get = __nested_webpack_require_292025__(/*! ./get */ \"./packages/@logrocket/utils/node_modules/lodash/get.js\"),\n    hasIn = __nested_webpack_require_292025__(/*! ./hasIn */ \"./packages/@logrocket/utils/node_modules/lodash/hasIn.js\"),\n    isKey = __nested_webpack_require_292025__(/*! ./_isKey */ \"./packages/@logrocket/utils/node_modules/lodash/_isKey.js\"),\n    isStrictComparable = __nested_webpack_require_292025__(/*! ./_isStrictComparable */ \"./packages/@logrocket/utils/node_modules/lodash/_isStrictComparable.js\"),\n    matchesStrictComparable = __nested_webpack_require_292025__(/*! ./_matchesStrictComparable */ \"./packages/@logrocket/utils/node_modules/lodash/_matchesStrictComparable.js\"),\n    toKey = __nested_webpack_require_292025__(/*! ./_toKey */ \"./packages/@logrocket/utils/node_modules/lodash/_toKey.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseProperty.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseProperty.js ***!\n  \\************************************************************************/\n/***/ (function(module) {\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_basePropertyDeep.js\":\n/*!****************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_basePropertyDeep.js ***!\n  \\****************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_294843__) {\n\nvar baseGet = __nested_webpack_require_294843__(/*! ./_baseGet */ \"./packages/@logrocket/utils/node_modules/lodash/_baseGet.js\");\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseSortedIndexBy.js\":\n/*!*****************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseSortedIndexBy.js ***!\n  \\*****************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_295727__) {\n\nvar isSymbol = __nested_webpack_require_295727__(/*! ./isSymbol */ \"./packages/@logrocket/utils/node_modules/lodash/isSymbol.js\");\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeMin = Math.min;\n\n/**\n * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n * which invokes `iteratee` for `value` and each element of `array` to compute\n * their sort ranking. The iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The iteratee invoked per element.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndexBy(array, value, iteratee, retHighest) {\n  var low = 0,\n      high = array == null ? 0 : array.length;\n  if (high === 0) {\n    return 0;\n  }\n\n  value = iteratee(value);\n  var valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsSymbol = isSymbol(value),\n      valIsUndefined = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        othIsDefined = computed !== undefined,\n        othIsNull = computed === null,\n        othIsReflexive = computed === computed,\n        othIsSymbol = isSymbol(computed);\n\n    if (valIsNaN) {\n      var setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? (computed <= value) : (computed < value);\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\nmodule.exports = baseSortedIndexBy;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseTimes.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseTimes.js ***!\n  \\*********************************************************************/\n/***/ (function(module) {\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseToString.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseToString.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_299298__) {\n\nvar Symbol = __nested_webpack_require_299298__(/*! ./_Symbol */ \"./packages/@logrocket/utils/node_modules/lodash/_Symbol.js\"),\n    arrayMap = __nested_webpack_require_299298__(/*! ./_arrayMap */ \"./packages/@logrocket/utils/node_modules/lodash/_arrayMap.js\"),\n    isArray = __nested_webpack_require_299298__(/*! ./isArray */ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\"),\n    isSymbol = __nested_webpack_require_299298__(/*! ./isSymbol */ \"./packages/@logrocket/utils/node_modules/lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_baseUnary.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseUnary.js ***!\n  \\*********************************************************************/\n/***/ (function(module) {\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_cacheHas.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_cacheHas.js ***!\n  \\********************************************************************/\n/***/ (function(module) {\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_castPath.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_castPath.js ***!\n  \\********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_302480__) {\n\nvar isArray = __nested_webpack_require_302480__(/*! ./isArray */ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\"),\n    isKey = __nested_webpack_require_302480__(/*! ./_isKey */ \"./packages/@logrocket/utils/node_modules/lodash/_isKey.js\"),\n    stringToPath = __nested_webpack_require_302480__(/*! ./_stringToPath */ \"./packages/@logrocket/utils/node_modules/lodash/_stringToPath.js\"),\n    toString = __nested_webpack_require_302480__(/*! ./toString */ \"./packages/@logrocket/utils/node_modules/lodash/toString.js\");\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_coreJsData.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_coreJsData.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_303753__) {\n\nvar root = __nested_webpack_require_303753__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\");\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_equalArrays.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_equalArrays.js ***!\n  \\***********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_304376__) {\n\nvar SetCache = __nested_webpack_require_304376__(/*! ./_SetCache */ \"./packages/@logrocket/utils/node_modules/lodash/_SetCache.js\"),\n    arraySome = __nested_webpack_require_304376__(/*! ./_arraySome */ \"./packages/@logrocket/utils/node_modules/lodash/_arraySome.js\"),\n    cacheHas = __nested_webpack_require_304376__(/*! ./_cacheHas */ \"./packages/@logrocket/utils/node_modules/lodash/_cacheHas.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Check that cyclic values are equal.\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_equalByTag.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_equalByTag.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_307665__) {\n\nvar Symbol = __nested_webpack_require_307665__(/*! ./_Symbol */ \"./packages/@logrocket/utils/node_modules/lodash/_Symbol.js\"),\n    Uint8Array = __nested_webpack_require_307665__(/*! ./_Uint8Array */ \"./packages/@logrocket/utils/node_modules/lodash/_Uint8Array.js\"),\n    eq = __nested_webpack_require_307665__(/*! ./eq */ \"./packages/@logrocket/utils/node_modules/lodash/eq.js\"),\n    equalArrays = __nested_webpack_require_307665__(/*! ./_equalArrays */ \"./packages/@logrocket/utils/node_modules/lodash/_equalArrays.js\"),\n    mapToArray = __nested_webpack_require_307665__(/*! ./_mapToArray */ \"./packages/@logrocket/utils/node_modules/lodash/_mapToArray.js\"),\n    setToArray = __nested_webpack_require_307665__(/*! ./_setToArray */ \"./packages/@logrocket/utils/node_modules/lodash/_setToArray.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_equalObjects.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_equalObjects.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_312285__) {\n\nvar getAllKeys = __nested_webpack_require_312285__(/*! ./_getAllKeys */ \"./packages/@logrocket/utils/node_modules/lodash/_getAllKeys.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Check that cyclic values are equal.\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_freeGlobal.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_freeGlobal.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_315724__) {\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __nested_webpack_require_315724__.g == 'object' && __nested_webpack_require_315724__.g && __nested_webpack_require_315724__.g.Object === Object && __nested_webpack_require_315724__.g;\n\nmodule.exports = freeGlobal;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_getAllKeys.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_getAllKeys.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_316343__) {\n\nvar baseGetAllKeys = __nested_webpack_require_316343__(/*! ./_baseGetAllKeys */ \"./packages/@logrocket/utils/node_modules/lodash/_baseGetAllKeys.js\"),\n    getSymbols = __nested_webpack_require_316343__(/*! ./_getSymbols */ \"./packages/@logrocket/utils/node_modules/lodash/_getSymbols.js\"),\n    keys = __nested_webpack_require_316343__(/*! ./keys */ \"./packages/@logrocket/utils/node_modules/lodash/keys.js\");\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_getMapData.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_getMapData.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_317427__) {\n\nvar isKeyable = __nested_webpack_require_317427__(/*! ./_isKeyable */ \"./packages/@logrocket/utils/node_modules/lodash/_isKeyable.js\");\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_getMatchData.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_getMatchData.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_318302__) {\n\nvar isStrictComparable = __nested_webpack_require_318302__(/*! ./_isStrictComparable */ \"./packages/@logrocket/utils/node_modules/lodash/_isStrictComparable.js\"),\n    keys = __nested_webpack_require_318302__(/*! ./keys */ \"./packages/@logrocket/utils/node_modules/lodash/keys.js\");\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_getNative.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_getNative.js ***!\n  \\*********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_319422__) {\n\nvar baseIsNative = __nested_webpack_require_319422__(/*! ./_baseIsNative */ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsNative.js\"),\n    getValue = __nested_webpack_require_319422__(/*! ./_getValue */ \"./packages/@logrocket/utils/node_modules/lodash/_getValue.js\");\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_getRawTag.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_getRawTag.js ***!\n  \\*********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_320451__) {\n\nvar Symbol = __nested_webpack_require_320451__(/*! ./_Symbol */ \"./packages/@logrocket/utils/node_modules/lodash/_Symbol.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_getSymbols.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_getSymbols.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_322054__) {\n\nvar arrayFilter = __nested_webpack_require_322054__(/*! ./_arrayFilter */ \"./packages/@logrocket/utils/node_modules/lodash/_arrayFilter.js\"),\n    stubArray = __nested_webpack_require_322054__(/*! ./stubArray */ \"./packages/@logrocket/utils/node_modules/lodash/stubArray.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_getTag.js\":\n/*!******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_getTag.js ***!\n  \\******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_323473__) {\n\nvar DataView = __nested_webpack_require_323473__(/*! ./_DataView */ \"./packages/@logrocket/utils/node_modules/lodash/_DataView.js\"),\n    Map = __nested_webpack_require_323473__(/*! ./_Map */ \"./packages/@logrocket/utils/node_modules/lodash/_Map.js\"),\n    Promise = __nested_webpack_require_323473__(/*! ./_Promise */ \"./packages/@logrocket/utils/node_modules/lodash/_Promise.js\"),\n    Set = __nested_webpack_require_323473__(/*! ./_Set */ \"./packages/@logrocket/utils/node_modules/lodash/_Set.js\"),\n    WeakMap = __nested_webpack_require_323473__(/*! ./_WeakMap */ \"./packages/@logrocket/utils/node_modules/lodash/_WeakMap.js\"),\n    baseGetTag = __nested_webpack_require_323473__(/*! ./_baseGetTag */ \"./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js\"),\n    toSource = __nested_webpack_require_323473__(/*! ./_toSource */ \"./packages/@logrocket/utils/node_modules/lodash/_toSource.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_getValue.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_getValue.js ***!\n  \\********************************************************************/\n/***/ (function(module) {\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_hasPath.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_hasPath.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_326891__) {\n\nvar castPath = __nested_webpack_require_326891__(/*! ./_castPath */ \"./packages/@logrocket/utils/node_modules/lodash/_castPath.js\"),\n    isArguments = __nested_webpack_require_326891__(/*! ./isArguments */ \"./packages/@logrocket/utils/node_modules/lodash/isArguments.js\"),\n    isArray = __nested_webpack_require_326891__(/*! ./isArray */ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\"),\n    isIndex = __nested_webpack_require_326891__(/*! ./_isIndex */ \"./packages/@logrocket/utils/node_modules/lodash/_isIndex.js\"),\n    isLength = __nested_webpack_require_326891__(/*! ./isLength */ \"./packages/@logrocket/utils/node_modules/lodash/isLength.js\"),\n    toKey = __nested_webpack_require_326891__(/*! ./_toKey */ \"./packages/@logrocket/utils/node_modules/lodash/_toKey.js\");\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_hashClear.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashClear.js ***!\n  \\*********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_328833__) {\n\nvar nativeCreate = __nested_webpack_require_328833__(/*! ./_nativeCreate */ \"./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js\");\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_hashDelete.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashDelete.js ***!\n  \\**********************************************************************/\n/***/ (function(module) {\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_hashGet.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashGet.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_330356__) {\n\nvar nativeCreate = __nested_webpack_require_330356__(/*! ./_nativeCreate */ \"./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_hashHas.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashHas.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_331586__) {\n\nvar nativeCreate = __nested_webpack_require_331586__(/*! ./_nativeCreate */ \"./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_hashSet.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashSet.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_332670__) {\n\nvar nativeCreate = __nested_webpack_require_332670__(/*! ./_nativeCreate */ \"./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_isIndex.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_isIndex.js ***!\n  \\*******************************************************************/\n/***/ (function(module) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_isKey.js\":\n/*!*****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_isKey.js ***!\n  \\*****************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_334804__) {\n\nvar isArray = __nested_webpack_require_334804__(/*! ./isArray */ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\"),\n    isSymbol = __nested_webpack_require_334804__(/*! ./isSymbol */ \"./packages/@logrocket/utils/node_modules/lodash/isSymbol.js\");\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_isKeyable.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_isKeyable.js ***!\n  \\*********************************************************************/\n/***/ (function(module) {\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_isMasked.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_isMasked.js ***!\n  \\********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_336984__) {\n\nvar coreJsData = __nested_webpack_require_336984__(/*! ./_coreJsData */ \"./packages/@logrocket/utils/node_modules/lodash/_coreJsData.js\");\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_isPrototype.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_isPrototype.js ***!\n  \\***********************************************************************/\n/***/ (function(module) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_isStrictComparable.js\":\n/*!******************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_isStrictComparable.js ***!\n  \\******************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_338871__) {\n\nvar isObject = __nested_webpack_require_338871__(/*! ./isObject */ \"./packages/@logrocket/utils/node_modules/lodash/isObject.js\");\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheClear.js\":\n/*!**************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheClear.js ***!\n  \\**************************************************************************/\n/***/ (function(module) {\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheDelete.js\":\n/*!***************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheDelete.js ***!\n  \\***************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_340343__) {\n\nvar assocIndexOf = __nested_webpack_require_340343__(/*! ./_assocIndexOf */ \"./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js\");\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheGet.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheGet.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_341596__) {\n\nvar assocIndexOf = __nested_webpack_require_341596__(/*! ./_assocIndexOf */ \"./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheHas.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheHas.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_342494__) {\n\nvar assocIndexOf = __nested_webpack_require_342494__(/*! ./_assocIndexOf */ \"./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_listCacheSet.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheSet.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_343375__) {\n\nvar assocIndexOf = __nested_webpack_require_343375__(/*! ./_assocIndexOf */ \"./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheClear.js\":\n/*!*************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheClear.js ***!\n  \\*************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_344410__) {\n\nvar Hash = __nested_webpack_require_344410__(/*! ./_Hash */ \"./packages/@logrocket/utils/node_modules/lodash/_Hash.js\"),\n    ListCache = __nested_webpack_require_344410__(/*! ./_ListCache */ \"./packages/@logrocket/utils/node_modules/lodash/_ListCache.js\"),\n    Map = __nested_webpack_require_344410__(/*! ./_Map */ \"./packages/@logrocket/utils/node_modules/lodash/_Map.js\");\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheDelete.js\":\n/*!**************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheDelete.js ***!\n  \\**************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_345437__) {\n\nvar getMapData = __nested_webpack_require_345437__(/*! ./_getMapData */ \"./packages/@logrocket/utils/node_modules/lodash/_getMapData.js\");\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheGet.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheGet.js ***!\n  \\***********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_346359__) {\n\nvar getMapData = __nested_webpack_require_346359__(/*! ./_getMapData */ \"./packages/@logrocket/utils/node_modules/lodash/_getMapData.js\");\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheHas.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheHas.js ***!\n  \\***********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_347161__) {\n\nvar getMapData = __nested_webpack_require_347161__(/*! ./_getMapData */ \"./packages/@logrocket/utils/node_modules/lodash/_getMapData.js\");\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_mapCacheSet.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheSet.js ***!\n  \\***********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_348015__) {\n\nvar getMapData = __nested_webpack_require_348015__(/*! ./_getMapData */ \"./packages/@logrocket/utils/node_modules/lodash/_getMapData.js\");\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_mapToArray.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapToArray.js ***!\n  \\**********************************************************************/\n/***/ (function(module) {\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_matchesStrictComparable.js\":\n/*!***********************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_matchesStrictComparable.js ***!\n  \\***********************************************************************************/\n/***/ (function(module) {\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_memoizeCapped.js\":\n/*!*************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_memoizeCapped.js ***!\n  \\*************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_350651__) {\n\nvar memoize = __nested_webpack_require_350651__(/*! ./memoize */ \"./packages/@logrocket/utils/node_modules/lodash/memoize.js\");\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_351756__) {\n\nvar getNative = __nested_webpack_require_351756__(/*! ./_getNative */ \"./packages/@logrocket/utils/node_modules/lodash/_getNative.js\");\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_nativeKeys.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_nativeKeys.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_352410__) {\n\nvar overArg = __nested_webpack_require_352410__(/*! ./_overArg */ \"./packages/@logrocket/utils/node_modules/lodash/_overArg.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_nodeUtil.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_nodeUtil.js ***!\n  \\********************************************************************/\n/***/ (function(module, exports, __nested_webpack_require_353054__) {\n\n/* module decorator */ module = __nested_webpack_require_353054__.nmd(module);\nvar freeGlobal = __nested_webpack_require_353054__(/*! ./_freeGlobal */ \"./packages/@logrocket/utils/node_modules/lodash/_freeGlobal.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_objectToString.js\":\n/*!**************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_objectToString.js ***!\n  \\**************************************************************************/\n/***/ (function(module) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_overArg.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_overArg.js ***!\n  \\*******************************************************************/\n/***/ (function(module) {\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\":\n/*!****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_root.js ***!\n  \\****************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_356161__) {\n\nvar freeGlobal = __nested_webpack_require_356161__(/*! ./_freeGlobal */ \"./packages/@logrocket/utils/node_modules/lodash/_freeGlobal.js\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_setCacheAdd.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_setCacheAdd.js ***!\n  \\***********************************************************************/\n/***/ (function(module) {\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_setCacheHas.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_setCacheHas.js ***!\n  \\***********************************************************************/\n/***/ (function(module) {\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_setToArray.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_setToArray.js ***!\n  \\**********************************************************************/\n/***/ (function(module) {\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_stackClear.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackClear.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_359039__) {\n\nvar ListCache = __nested_webpack_require_359039__(/*! ./_ListCache */ \"./packages/@logrocket/utils/node_modules/lodash/_ListCache.js\");\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_stackDelete.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackDelete.js ***!\n  \\***********************************************************************/\n/***/ (function(module) {\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_stackGet.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackGet.js ***!\n  \\********************************************************************/\n/***/ (function(module) {\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_stackHas.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackHas.js ***!\n  \\********************************************************************/\n/***/ (function(module) {\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_stackSet.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackSet.js ***!\n  \\********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_361756__) {\n\nvar ListCache = __nested_webpack_require_361756__(/*! ./_ListCache */ \"./packages/@logrocket/utils/node_modules/lodash/_ListCache.js\"),\n    Map = __nested_webpack_require_361756__(/*! ./_Map */ \"./packages/@logrocket/utils/node_modules/lodash/_Map.js\"),\n    MapCache = __nested_webpack_require_361756__(/*! ./_MapCache */ \"./packages/@logrocket/utils/node_modules/lodash/_MapCache.js\");\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_stringToPath.js\":\n/*!************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_stringToPath.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_363239__) {\n\nvar memoizeCapped = __nested_webpack_require_363239__(/*! ./_memoizeCapped */ \"./packages/@logrocket/utils/node_modules/lodash/_memoizeCapped.js\");\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_toKey.js\":\n/*!*****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_toKey.js ***!\n  \\*****************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_364530__) {\n\nvar isSymbol = __nested_webpack_require_364530__(/*! ./isSymbol */ \"./packages/@logrocket/utils/node_modules/lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/_toSource.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/_toSource.js ***!\n  \\********************************************************************/\n/***/ (function(module) {\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/eq.js\":\n/*!*************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/eq.js ***!\n  \\*************************************************************/\n/***/ (function(module) {\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/get.js\":\n/*!**************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/get.js ***!\n  \\**************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_367475__) {\n\nvar baseGet = __nested_webpack_require_367475__(/*! ./_baseGet */ \"./packages/@logrocket/utils/node_modules/lodash/_baseGet.js\");\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/hasIn.js\":\n/*!****************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/hasIn.js ***!\n  \\****************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_368800__) {\n\nvar baseHasIn = __nested_webpack_require_368800__(/*! ./_baseHasIn */ \"./packages/@logrocket/utils/node_modules/lodash/_baseHasIn.js\"),\n    hasPath = __nested_webpack_require_368800__(/*! ./_hasPath */ \"./packages/@logrocket/utils/node_modules/lodash/_hasPath.js\");\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/identity.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/identity.js ***!\n  \\*******************************************************************/\n/***/ (function(module) {\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isArguments.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isArguments.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_370796__) {\n\nvar baseIsArguments = __nested_webpack_require_370796__(/*! ./_baseIsArguments */ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsArguments.js\"),\n    isObjectLike = __nested_webpack_require_370796__(/*! ./isObjectLike */ \"./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isArray.js\":\n/*!******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isArray.js ***!\n  \\******************************************************************/\n/***/ (function(module) {\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isArrayLike.js\":\n/*!**********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isArrayLike.js ***!\n  \\**********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_373189__) {\n\nvar isFunction = __nested_webpack_require_373189__(/*! ./isFunction */ \"./packages/@logrocket/utils/node_modules/lodash/isFunction.js\"),\n    isLength = __nested_webpack_require_373189__(/*! ./isLength */ \"./packages/@logrocket/utils/node_modules/lodash/isLength.js\");\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isBuffer.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isBuffer.js ***!\n  \\*******************************************************************/\n/***/ (function(module, exports, __nested_webpack_require_374536__) {\n\n/* module decorator */ module = __nested_webpack_require_374536__.nmd(module);\nvar root = __nested_webpack_require_374536__(/*! ./_root */ \"./packages/@logrocket/utils/node_modules/lodash/_root.js\"),\n    stubFalse = __nested_webpack_require_374536__(/*! ./stubFalse */ \"./packages/@logrocket/utils/node_modules/lodash/stubFalse.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isFunction.js\":\n/*!*********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isFunction.js ***!\n  \\*********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_376227__) {\n\nvar baseGetTag = __nested_webpack_require_376227__(/*! ./_baseGetTag */ \"./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js\"),\n    isObject = __nested_webpack_require_376227__(/*! ./isObject */ \"./packages/@logrocket/utils/node_modules/lodash/isObject.js\");\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isLength.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isLength.js ***!\n  \\*******************************************************************/\n/***/ (function(module) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isObject.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isObject.js ***!\n  \\*******************************************************************/\n/***/ (function(module) {\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js ***!\n  \\***********************************************************************/\n/***/ (function(module) {\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isSymbol.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isSymbol.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_380901__) {\n\nvar baseGetTag = __nested_webpack_require_380901__(/*! ./_baseGetTag */ \"./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js\"),\n    isObjectLike = __nested_webpack_require_380901__(/*! ./isObjectLike */ \"./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/isTypedArray.js\":\n/*!***********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/isTypedArray.js ***!\n  \\***********************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_382138__) {\n\nvar baseIsTypedArray = __nested_webpack_require_382138__(/*! ./_baseIsTypedArray */ \"./packages/@logrocket/utils/node_modules/lodash/_baseIsTypedArray.js\"),\n    baseUnary = __nested_webpack_require_382138__(/*! ./_baseUnary */ \"./packages/@logrocket/utils/node_modules/lodash/_baseUnary.js\"),\n    nodeUtil = __nested_webpack_require_382138__(/*! ./_nodeUtil */ \"./packages/@logrocket/utils/node_modules/lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/keys.js\":\n/*!***************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/keys.js ***!\n  \\***************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_383440__) {\n\nvar arrayLikeKeys = __nested_webpack_require_383440__(/*! ./_arrayLikeKeys */ \"./packages/@logrocket/utils/node_modules/lodash/_arrayLikeKeys.js\"),\n    baseKeys = __nested_webpack_require_383440__(/*! ./_baseKeys */ \"./packages/@logrocket/utils/node_modules/lodash/_baseKeys.js\"),\n    isArrayLike = __nested_webpack_require_383440__(/*! ./isArrayLike */ \"./packages/@logrocket/utils/node_modules/lodash/isArrayLike.js\");\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/memoize.js\":\n/*!******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/memoize.js ***!\n  \\******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_384941__) {\n\nvar MapCache = __nested_webpack_require_384941__(/*! ./_MapCache */ \"./packages/@logrocket/utils/node_modules/lodash/_MapCache.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/property.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/property.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_387619__) {\n\nvar baseProperty = __nested_webpack_require_387619__(/*! ./_baseProperty */ \"./packages/@logrocket/utils/node_modules/lodash/_baseProperty.js\"),\n    basePropertyDeep = __nested_webpack_require_387619__(/*! ./_basePropertyDeep */ \"./packages/@logrocket/utils/node_modules/lodash/_basePropertyDeep.js\"),\n    isKey = __nested_webpack_require_387619__(/*! ./_isKey */ \"./packages/@logrocket/utils/node_modules/lodash/_isKey.js\"),\n    toKey = __nested_webpack_require_387619__(/*! ./_toKey */ \"./packages/@logrocket/utils/node_modules/lodash/_toKey.js\");\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/sortedLastIndexBy.js\":\n/*!****************************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/sortedLastIndexBy.js ***!\n  \\****************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_389148__) {\n\nvar baseIteratee = __nested_webpack_require_389148__(/*! ./_baseIteratee */ \"./packages/@logrocket/utils/node_modules/lodash/_baseIteratee.js\"),\n    baseSortedIndexBy = __nested_webpack_require_389148__(/*! ./_baseSortedIndexBy */ \"./packages/@logrocket/utils/node_modules/lodash/_baseSortedIndexBy.js\");\n\n/**\n * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * var objects = [{ 'x': 4 }, { 'x': 5 }];\n *\n * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n * // => 1\n *\n * // The `_.property` iteratee shorthand.\n * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n * // => 1\n */\nfunction sortedLastIndexBy(array, value, iteratee) {\n  return baseSortedIndexBy(array, value, baseIteratee(iteratee, 2), true);\n}\n\nmodule.exports = sortedLastIndexBy;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/stubArray.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/stubArray.js ***!\n  \\********************************************************************/\n/***/ (function(module) {\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/stubFalse.js\":\n/*!********************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/stubFalse.js ***!\n  \\********************************************************************/\n/***/ (function(module) {\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n/***/ }),\n\n/***/ \"./packages/@logrocket/utils/node_modules/lodash/toString.js\":\n/*!*******************************************************************!*\\\n  !*** ./packages/@logrocket/utils/node_modules/lodash/toString.js ***!\n  \\*******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_392113__) {\n\nvar baseToString = __nested_webpack_require_392113__(/*! ./_baseToString */ \"./packages/@logrocket/utils/node_modules/lodash/_baseToString.js\");\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!\n  \\*****************************************************************/\n/***/ (function(module) {\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!\n  \\***************************************************************/\n/***/ (function(module) {\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!\n  \\******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_394259__) {\n\nvar arrayLikeToArray = __nested_webpack_require_394259__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!\n  \\***************************************************************/\n/***/ (function(module) {\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/createClass.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!\n  \\************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_395530__) {\n\nvar toPropertyKey = __nested_webpack_require_395530__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/toPropertyKey.js\");\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/defineProperty.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!\n  \\***************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_396778__) {\n\nvar toPropertyKey = __nested_webpack_require_396778__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/toPropertyKey.js\");\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!\n  \\**********************************************************************/\n/***/ (function(module) {\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/iterableToArray.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!\n  \\****************************************************************/\n/***/ (function(module) {\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!\n  \\*********************************************************************/\n/***/ (function(module) {\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!\n  \\****************************************************************/\n/***/ (function(module) {\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/nonIterableSpread.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!\n  \\******************************************************************/\n/***/ (function(module) {\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/objectWithoutProperties.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!\n  \\************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_401275__) {\n\nvar objectWithoutPropertiesLoose = __nested_webpack_require_401275__(/*! ./objectWithoutPropertiesLoose.js */ \"./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js\");\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js\":\n/*!*****************************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!\n  \\*****************************************************************************/\n/***/ (function(module) {\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!\n  \\**************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_403285__) {\n\nvar arrayWithHoles = __nested_webpack_require_403285__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\nvar iterableToArrayLimit = __nested_webpack_require_403285__(/*! ./iterableToArrayLimit.js */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = __nested_webpack_require_403285__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\nvar nonIterableRest = __nested_webpack_require_403285__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!\n  \\******************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_404491__) {\n\nvar arrayWithoutHoles = __nested_webpack_require_404491__(/*! ./arrayWithoutHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\");\nvar iterableToArray = __nested_webpack_require_404491__(/*! ./iterableToArray.js */ \"./node_modules/@babel/runtime/helpers/iterableToArray.js\");\nvar unsupportedIterableToArray = __nested_webpack_require_404491__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\nvar nonIterableSpread = __nested_webpack_require_404491__(/*! ./nonIterableSpread.js */ \"./node_modules/@babel/runtime/helpers/nonIterableSpread.js\");\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/toPrimitive.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!\n  \\************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_405672__) {\n\nvar _typeof = (__nested_webpack_require_405672__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/toPropertyKey.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!\n  \\**************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_406656__) {\n\nvar _typeof = (__nested_webpack_require_406656__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nvar toPrimitive = __nested_webpack_require_406656__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/toPrimitive.js\");\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/typeof.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!\n  \\*******************************************************/\n/***/ (function(module) {\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\":\n/*!***************************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!\n  \\***************************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_408371__) {\n\nvar arrayLikeToArray = __nested_webpack_require_408371__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_409310__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_409310__);\n/******/ \t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/global */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_409310__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/node module decorator */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_409310__.nmd = function(module) {\n/******/ \t\t\tmodule.paths = [];\n/******/ \t\t\tif (!module.children) module.children = [];\n/******/ \t\t\treturn module;\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n!function() {\n\"use strict\";\nvar exports = __nested_webpack_exports__;\n/*!**********************************************!*\\\n  !*** ./packages/logrocket/src/module-npm.js ***!\n  \\**********************************************/\n\n\nvar _interopRequireDefault = __nested_webpack_require_409310__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _setup = _interopRequireDefault(__nested_webpack_require_409310__(/*! ./setup */ \"./packages/logrocket/src/setup.js\"));\nvar instance = (0, _setup.default)();\nvar _default = instance;\nexports[\"default\"] = _default;\n}();\n__nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9ncm9ja2V0L2Rpc3QvYnVpbGQudW1kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sYUFLSjtBQUNGLENBQUM7QUFDRCw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOEJBQW1COztBQUVyRTs7O0FBR0EsNkJBQTZCLDhCQUFtQjtBQUNoRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxzQ0FBc0MsOEJBQW1CO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FB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Q0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQ0FBbUI7O0FBRXJFOzs7QUFHQSw2QkFBNkIsaUNBQW1CO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4Q0FBOEMsaUNBQW1CO0FBQ2pFLDJDQUEyQyxpQ0FBbUI7QUFDOUQsOENBQThDLGlDQUFtQjtBQUNqRSx1REFBdUQsaUNBQW1CO0FBQzFFLHNDQUFzQyxpQ0FBbUI7QUFDekQsa0JBQWtCLGlDQUFtQjtBQUNyQyxzQ0FBc0MsaUNBQW1CO0FBQ3pELGFBQWEsaUNBQW1CO0FBQ2hDLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQztBQUN2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsMERBQTBELG9LQUFvSyxtRkFBbUYsS0FBSztBQUN4ZjtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsV0FBVztBQUNuRjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsSUFBSSwwQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBbUI7QUFDakM7QUFDQTtBQUNBOzs7QUFHQSw2QkFBNkIsaUNBQW1CO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQ0FBb0MsaUNBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBbUIsR0FBRywwQkFBbUI7QUFDekMsaUJBQWlCLDBCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VpbGhlcm1lZnJlaXRhcy5jb20vLi9ub2RlX21vZHVsZXMvbG9ncm9ja2V0L2Rpc3QvYnVpbGQudW1kLmpzP2E2ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2Fyc29uL3NyYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC9hcnNvbi9zcmMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZiAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXCIpKTtcbi8qIGVzbGludC1kaXNhYmxlICovXG5cbnZhciBVTkRFRklORURfSU5ERVggPSAtMTtcbnZhciBBUlJBWV9IT0xFX0lOREVYID0gLTI7XG52YXIgTkFOX0lOREVYID0gLTM7XG52YXIgUE9TX0lORl9JTkRFWCA9IC00O1xudmFyIE5FR19JTkZfSU5ERVggPSAtNTtcbnZhciBjdXN0b21UeXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgcmVnaXN0ZXJUeXBlID0gZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKHR5cGVOYW1lLCBoYW5kbGVycykge1xuICBmdW5jdGlvbiBjaGVjayhtZXRob2ROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyc1ttZXRob2ROYW1lXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZWNvbmQgYXJndW1lbnQgdG8gQVJTT04ucmVnaXN0ZXJUeXBlKFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZU5hbWUpICsgXCIsIC4uLikgXCIgKyBcIm11c3QgYmUgYW4gb2JqZWN0IHdpdGggYSBcIiArIG1ldGhvZE5hbWUgKyBcIiBtZXRob2RcIik7XG4gICAgfVxuICB9XG4gIGNoZWNrKFwiZGVjb25zdHJ1Y3RcIik7XG4gIGNoZWNrKFwicmVjb25zdHJ1Y3RcIik7XG4gIGN1c3RvbVR5cGVzW3R5cGVOYW1lXSA9IGhhbmRsZXJzO1xufTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZGF0ZVRhZyA9IFwiW29iamVjdCBEYXRlXVwiO1xudmFyIHJlZ0V4cFRhZyA9IFwiW29iamVjdCBSZWdFeHBdXCI7XG52YXIgc2V0VGFnID0gXCJbb2JqZWN0IFNldF1cIjtcbnZhciBtYXBUYWcgPSBcIltvYmplY3QgTWFwXVwiO1xudHlwZW9mIEJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiByZWdpc3RlclR5cGUoXCJCdWZmZXJcIiwge1xuICBkZWNvbnN0cnVjdDogZnVuY3Rpb24gZGVjb25zdHJ1Y3QoYnVmKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihidWYpICYmIFtidWYudG9TdHJpbmcoXCJiYXNlNjRcIiksIFwiYmFzZTY0XCJdO1xuICB9LFxuICAvLyBUaGUgcmVjb25zdHJ1Y3QgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdHdpY2U6IG9uY2Ugd2l0aCBub1xuICAvLyBhcmd1bWVudHMsIHdoaWNoIGFsbG93cyBpdCB0byByZXR1cm4gYSBwbGFjZWhvbGRlciBvYmplY3QgcmVmZXJlbmNlO1xuICAvLyBhbmQgb25jZSB3aXRoIG9uZSBhcmd1bWVudCwgYSBjb3B5IG9mIHRoZSBhcnJheSByZXR1cm5lZCBieSB0aGVcbiAgLy8gZGVjb25zdHJ1Y3QgZnVuY3Rpb24uIEZvciBpbW11dGFibGUgdHlwZXMgbGlrZSBCdWZmZXIsIERhdGUsIGFuZFxuICAvLyBSZWdFeHAsIHRoZSByZWNvbnN0cnVjdCBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZmFsc3kgdmFsdWUgd2hlbiBpdFxuICAvLyByZWNlaXZlcyBubyBhcmd1bWVudHMsIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBjcmVhdGUgYW4gZW1wdHlcbiAgLy8gQnVmZmVyIG9yIERhdGUgYW5kIGxhdGVyIGZpbGwgaW4gaXRzIGNvbnRlbnRzLiAgRm9yIGNvbnRhaW5lciB0eXBlc1xuICAvLyBsaWtlIE1hcCBhbmQgU2V0LCB0aGUgcmVjb25zdHJ1Y3QgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gZW1wdHlcbiAgLy8gaW5zdGFuY2Ugb2YgdGhlIGNvbnRhaW5lciB3aGVuIGl0IHJlY2VpdmVzIG5vIGFyZ3VtZW50cywgc28gdGhhdCB3ZVxuICAvLyBjYW4gZmlsbCBpbiB0aGF0IGVtcHR5IGNvbnRhaW5lciBsYXRlci4gVGhpcyB0d28tcGhhc2VkIHN0cmF0ZWd5IGlzXG4gIC8vIGVzc2VudGlhbCBmb3IgZGVjb2RpbmcgY29udGFpbmVycyB0aGF0IGNvbnRhaW4gdGhlbXNlbHZlcy5cbiAgcmVjb25zdHJ1Y3Q6IGZ1bmN0aW9uIHJlY29uc3RydWN0KGFyZ3MpIHtcbiAgICByZXR1cm4gYXJncyAmJiBCdWZmZXIuZnJvbShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxufSk7XG5yZWdpc3RlclR5cGUoXCJEYXRlXCIsIHtcbiAgZGVjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGRlY29uc3RydWN0KGRhdGUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChkYXRlKSA9PT0gZGF0ZVRhZyAmJiBbZGF0ZS50b0pTT04oKV07XG4gIH0sXG4gIHJlY29uc3RydWN0OiBmdW5jdGlvbiByZWNvbnN0cnVjdChhcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MgJiYgbmV3IERhdGUoYXJnc1swXSk7XG4gIH1cbn0pO1xucmVnaXN0ZXJUeXBlKFwiUmVnRXhwXCIsIHtcbiAgZGVjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGRlY29uc3RydWN0KGV4cCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGV4cCkgPT09IHJlZ0V4cFRhZykge1xuICAgICAgdmFyIGFyZ3MgPSBbZXhwLnNvdXJjZV07XG4gICAgICB2YXIgZmxhZ3MgPSBcIlwiO1xuICAgICAgaWYgKGV4cC5pZ25vcmVDYXNlKSBmbGFncyArPSBcImlcIjtcbiAgICAgIGlmIChleHAubXVsdGlsaW5lKSBmbGFncyArPSBcIm1cIjtcbiAgICAgIGlmIChleHAuZ2xvYmFsKSBmbGFncyArPSBcImdcIjtcbiAgICAgIGlmIChmbGFncykge1xuICAgICAgICBhcmdzLnB1c2goZmxhZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICB9LFxuICByZWNvbnN0cnVjdDogZnVuY3Rpb24gcmVjb25zdHJ1Y3QoYXJncykge1xuICAgIHJldHVybiBhcmdzICYmIG5ldyBSZWdFeHAoYXJnc1swXSwgYXJnc1sxXSk7XG4gIH1cbn0pO1xudHlwZW9mIFNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBBcnJheS5mcm9tID09PSBcImZ1bmN0aW9uXCIgJiYgcmVnaXN0ZXJUeXBlKFwiU2V0XCIsIHtcbiAgZGVjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGRlY29uc3RydWN0KHNldCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKHNldCkgPT09IHNldFRhZykge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbiAgICB9XG4gIH0sXG4gIHJlY29uc3RydWN0OiBmdW5jdGlvbiByZWNvbnN0cnVjdCh2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICB2YWx1ZXMuZm9yRWFjaCh0aGlzLmFkZCwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KCk7XG4gICAgfVxuICB9XG59KTtcbnR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgQXJyYXkuZnJvbSA9PT0gXCJmdW5jdGlvblwiICYmIHJlZ2lzdGVyVHlwZShcIk1hcFwiLCB7XG4gIGRlY29uc3RydWN0OiBmdW5jdGlvbiBkZWNvbnN0cnVjdChtYXApIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChtYXApID09PSBtYXBUYWcpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG1hcCk7XG4gICAgfVxuICB9LFxuICByZWNvbnN0cnVjdDogZnVuY3Rpb24gcmVjb25zdHJ1Y3QoZW50cmllcykge1xuICAgIGlmIChlbnRyaWVzKSB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b1RhYmxlKHZhbHVlKSk7XG59XG5mdW5jdGlvbiB0b1RhYmxlKHZhbHVlKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGluZGV4TWFwID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiICYmIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gZ2V0SW5kZXgodmFsdWUpIHtcbiAgICBzd2l0Y2ggKCgwLCBfdHlwZW9mMi5kZWZhdWx0KSh2YWx1ZSkpIHtcbiAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgcmV0dXJuIFVOREVGSU5FRF9JTkRFWDtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBOQU5fSU5ERVg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gTkVHX0lORl9JTkRFWCA6IFBPU19JTkZfSU5ERVg7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbCB0aHJvdWdoLi4uXG4gICAgfVxuXG4gICAgdmFyIGluZGV4O1xuICAgIGlmIChpbmRleE1hcCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBNYXAsIHVzZSBpdCBpbnN0ZWFkIG9mIHZhbHVlcy5pbmRleE9mIHRvIGFjY2VsZXJhdGVcbiAgICAgIC8vIG9iamVjdCBsb29rdXBzLlxuICAgICAgaW5kZXggPSBpbmRleE1hcC5nZXQodmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbmRleCA9IHZhbHVlcy5wdXNoKHZhbHVlKSAtIDE7XG4gICAgICAgIGluZGV4TWFwLnNldCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IHZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSB2YWx1ZXMucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgZnVuY3Rpb24gY29weSh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZSBhcnJheSBoYXMgaG9sZXMsIHNvIG1ha2Ugc3VyZSB3ZSBmaWxsIHRoZW0gd2l0aCB0aGVcbiAgICAgICAgICAvLyBBUlJBWV9IT0xFX0lOREVYIGNvbnN0YW50LlxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IEFSUkFZX0hPTEVfSU5ERVg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciB0eXBlTmFtZSBpbiBjdXN0b21UeXBlcykge1xuICAgICAgICAgIC8vIElmIHZhbHVlIGlzIG5vdCBhIHBsYWluIE9iamVjdCwgYnV0IHNvbWV0aGluZyBleG90aWMgbGlrZSBhXG4gICAgICAgICAgLy8gRGF0ZSBvciBhIFJlZ0V4cCwgc2VyaWFsaXplIGl0IGFzIGFuIGFycmF5IHdpdGggdHlwZU5hbWUgYXNcbiAgICAgICAgICAvLyBpdHMgZmlyc3QgZWxlbWVudC4gVGhlc2UgYXJyYXlzIGNhbiBiZSBkaXN0aW5ndWlzaGVkIGZyb21cbiAgICAgICAgICAvLyBub3JtYWwgYXJyYXlzLCBiZWNhdXNlIGFsbCBvdGhlciBub24tZW1wdHkgYXJyYXlzIHdpbGwgYmVcbiAgICAgICAgICAvLyBzZXJpYWxpemVkIHdpdGggYSBudW1lcmljIHZhbHVlIGFzIHRoZWlyIGZpcnN0IGVsZW1lbnQuXG4gICAgICAgICAgdmFyIGFyZ3MgPSBjdXN0b21UeXBlc1t0eXBlTmFtZV0uZGVjb25zdHJ1Y3QodmFsdWUpO1xuICAgICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgYXJnc1tpXSA9IGdldEluZGV4KGFyZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHR5cGVOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGdldEluZGV4KHZhbHVlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBBc3NpZ25zIHRoZSByb290IHZhbHVlIHRvIHZhbHVlc1swXS5cbiAgdmFyIGluZGV4MCA9IGdldEluZGV4KHZhbHVlKTtcbiAgaWYgKGluZGV4MCA8IDApIHtcbiAgICAvLyBJZiB2YWx1ZSBpcyBzb21ldGhpbmcgc3BlY2lhbCB0aGF0IGdldHMgYSBuZWdhdGl2ZSBpbmRleCwgdGhlbiB3ZVxuICAgIC8vIGRvbid0IG5lZWQgdG8gYnVpbGQgYSB0YWJsZSBhdCBhbGwsIGFuZCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGF0XG4gICAgLy8gbmVnYXRpdmUgaW5kZXggYXMgYSBjb21wbGV0ZSBzZXJpYWxpemF0aW9uLiBUaGlzIGF2b2lkcyBhbWJpZ3VpdHlcbiAgICAvLyBhYm91dCBpbmRleGVzIHZlcnN1cyBwcmltaXRpdmUgbGl0ZXJhbCB2YWx1ZXMuXG4gICAgcmV0dXJuIGluZGV4MDtcbiAgfVxuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGZvciBsb29wIGNhbm5vdCBiZSBhIGZvckVhY2ggbG9vcCwgYmVjYXVzZVxuICAvLyB2YWx1ZXMubGVuZ3RoIGlzIGV4cGVjdGVkIHRvIGNoYW5nZSBkdXJpbmcgaXRlcmF0aW9uLlxuICBmb3IgKHZhciB0YWJsZSA9IFtdLCB2ID0gMDsgdiA8IHZhbHVlcy5sZW5ndGg7ICsrdikge1xuICAgIHRhYmxlW3ZdID0gY29weSh2YWx1ZXNbdl0pO1xuICB9XG4gIHJldHVybiB0YWJsZTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgdmFyIGlzT2JqZWN0ID0gdmFsdWUgJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbHVlKSA9PT0gXCJvYmplY3RcIjtcbiAgaWYgKGlzT2JqZWN0KSB7XG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA6IHZhbHVlLl9fcHJvdG9fXztcbiAgICByZXR1cm4gcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVjb2RlKGVuY29kaW5nKSB7XG4gIHJldHVybiBmcm9tVGFibGUoSlNPTi5wYXJzZShlbmNvZGluZykpO1xufVxuZnVuY3Rpb24gZnJvbVRhYmxlKHRhYmxlKSB7XG4gIGlmICh0eXBlb2YgdGFibGUgPT09IFwibnVtYmVyXCIgJiYgdGFibGUgPCAwKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlV2l0aG91dENhY2hlKHRhYmxlKTtcbiAgfVxuICB2YXIgZ2V0VmFsdWVDYWNoZSA9IG5ldyBBcnJheSh0YWJsZS5sZW5ndGgpO1xuICBmdW5jdGlvbiBnZXRWYWx1ZShpbmRleCkge1xuICAgIHJldHVybiBpbmRleCBpbiBnZXRWYWx1ZUNhY2hlID8gZ2V0VmFsdWVDYWNoZVtpbmRleF0gOiBnZXRWYWx1ZUNhY2hlW2luZGV4XSA9IGdldFZhbHVlV2l0aG91dENhY2hlKGluZGV4KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRWYWx1ZVdpdGhvdXRDYWNoZShpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGlmIChpbmRleCA9PT0gVU5ERUZJTkVEX0lOREVYKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gQVJSQVlfSE9MRV9JTkRFWCkge1xuICAgICAgICAvLyBOZXZlciByZWFjaGVkIGJlY2F1c2UgaGFuZGxlZCBzcGVjaWFsbHkgYmVsb3cuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gTkFOX0lOREVYKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT09IFBPU19JTkZfSU5ERVgpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSBORUdfSU5GX0lOREVYKSB7XG4gICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEFSU09OIGluZGV4OiBcIiArIGluZGV4KTtcbiAgICB9XG4gICAgdmFyIGVudHJ5ID0gdGFibGVbaW5kZXhdO1xuICAgIGlmIChlbnRyeSAmJiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkoZW50cnkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgdmFyIGVsZW0wID0gZW50cnlbMF07XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbTAgPT09IFwic3RyaW5nXCIgJiYgZWxlbTAgaW4gY3VzdG9tVHlwZXMpIHtcbiAgICAgICAgICB2YXIgcmVjID0gY3VzdG9tVHlwZXNbZWxlbTBdLnJlY29uc3RydWN0O1xuICAgICAgICAgIHZhciBlbXB0eSA9IHJlYygpO1xuICAgICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlY29uc3RydWN0IGhhbmRsZXIgcmV0dXJucyBhbiBvYmplY3QsIHRyZWF0IGl0IGFzXG4gICAgICAgICAgICAvLyBhbiBlbXB0eSBpbnN0YW5jZSBvZiB0aGUgZGVzaXJlZCB0eXBlLCBhbmQgc2NoZWR1bGUgaXQgdG9cbiAgICAgICAgICAgIC8vIGJlIGZpbGxlZCBpbiBsYXRlci4gVGhpcyB0d28tc3RhZ2UgcHJvY2VzcyBhbGxvd3MgZXhvdGljXG4gICAgICAgICAgICAvLyBjb250YWluZXIgb2JqZWN0cyB0byBjb250YWluIHRoZW1zZWx2ZXMuXG4gICAgICAgICAgICBjb250YWluZXJzLnB1c2goe1xuICAgICAgICAgICAgICByZWNvbnN0cnVjdDogcmVjLFxuICAgICAgICAgICAgICBlbXB0eTogZW1wdHksXG4gICAgICAgICAgICAgIGFyZ0luZGV4ZXM6IGVudHJ5LnNsaWNlKDEpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgcmVjb25zdHJ1Y3QgaGFuZGxlciByZXR1cm5lZCBhIGZhbHN5IHZhbHVlLCB0aGVuIHdlXG4gICAgICAgICAgLy8gYXNzdW1lIG5vbmUgb2YgaXRzIGFyZ3VtZW50cyByZWZlciB0byBleG90aWMgY29udGFpbmVycywgc29cbiAgICAgICAgICAvLyB3ZSBjYW4gcmVjb25zdHJ1Y3QgdGhlIG9iamVjdCBpbW1lZGlhdGVseS4gRXhhbXBsZXM6IEJ1ZmZlcixcbiAgICAgICAgICAvLyBEYXRlLCBSZWdFeHAuXG4gICAgICAgICAgcmV0dXJuIHRhYmxlW2luZGV4XSA9IGVtcHR5IHx8IHJlYyhlbnRyeS5zbGljZSgxKS5tYXAoZ2V0VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIZXJlIGVudHJ5IGlzIGFscmVhZHkgdGhlIGNvcnJlY3QgYXJyYXkgb3Igb2JqZWN0IHJlZmVyZW5jZSBmb3JcbiAgICAgIC8vIHRoaXMgaW5kZXgsIGJ1dCBpdHMgdmFsdWVzIGFyZSBzdGlsbCBpbmRleGVzIHRoYXQgd2lsbCBuZWVkIHRvIGJlXG4gICAgICAvLyByZXNvbHZlZCBsYXRlci5cbiAgICAgIG9iamVjdHMucHVzaChlbnRyeSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICB2YXIgY29udGFpbmVycyA9IFtdO1xuICB2YXIgb2JqZWN0cyA9IFtdO1xuXG4gIC8vIEZpcnN0IHBhc3M6IG1ha2Ugc3VyZSBhbGwgZXhvdGljIG9iamVjdHMgYXJlIGRlc2VyaWFsaXplZCBmaXN0LCBhbmRcbiAgLy8ga2VlcCB0cmFjayBvZiBhbGwgcGxhaW4gb2JqZWN0IGVudHJpZXMgZm9yIGxhdGVyLlxuICB0YWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgIGdldFZhbHVlKGkpO1xuICB9KTtcblxuICAvLyBTZWNvbmQgcGFzczogbm93IHRoYXQgd2UgaGF2ZSBmaW5hbCBvYmplY3QgcmVmZXJlbmNlcyBmb3IgYWxsIGV4b3RpY1xuICAvLyBvYmplY3RzLCB3ZSBjYW4gc2FmZWx5IHJlc29sdmUgYXJndW1lbnQgaW5kZXhlcyBmb3IgdGhlIGVtcHR5IG9uZXMuXG4gIGNvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIGMuYXJncyA9IGMuYXJnSW5kZXhlcy5tYXAoZ2V0VmFsdWUpO1xuICB9KTtcblxuICAvLyBUaGlyZCBwYXNzOiByZXNvbHZlIHZhbHVlIGluZGV4ZXMgZm9yIG9yZGluYXJ5IGFycmF5cyBhbmQgb2JqZWN0cy5cbiAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGluZGV4ID0gb2JqW2tleV07XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIExlYXZlIG5vbi1udW1lcmljIGluZGV4ZXMgdW50b3VjaGVkLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gQVJSQVlfSE9MRV9JTkRFWCkge1xuICAgICAgICAgIC8vIEFycmF5IGhvbGVzIGhhdmUgdG8gYmUgaGFuZGxlZCBzcGVjaWFsbHkgaGVyZSwgc2luY2UgZ2V0VmFsdWVcbiAgICAgICAgICAvLyBkb2VzIG5vdCBoYXZlIGEgcmVmZXJlbmNlIHRvIG9iai5cbiAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyByZWN1cnNpb24gaXMgZ3VhcmFudGVlZCBub3QgdG8gYWRkIG1vcmUgb2JqZWN0cywgYmVjYXVzZVxuICAgICAgICAvLyB3ZSBrbm93IHRoZSBpbmRleCBpcyBuZWdhdGl2ZS5cbiAgICAgICAgb2JqW2tleV0gPSBnZXRWYWx1ZShpbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb24tbmVnYXRpdmUgaW5kZXhlcyByZWZlciB0byBub3JtYWwgdGFibGUgdmFsdWVzLlxuICAgICAgICBvYmpba2V5XSA9IHRhYmxlW2luZGV4XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gRm91cnRoIHBhc3M6IGFsbCBwb3NzaWJsZSBvYmplY3QgcmVmZXJlbmNlcyBoYXZlIGJlZW4gZXN0YWJsaXNoZWQsIHNvXG4gIC8vIHdlIGNhbiBmaW5hbGx5IGluaXRpYWxpemUgdGhlIGVtcHR5IGNvbnRhaW5lciBvYmplY3RzLlxuICBjb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICBjLnJlY29uc3RydWN0LmNhbGwoYy5lbXB0eSwgYy5hcmdzKTtcbiAgfSk7XG4gIHJldHVybiB0YWJsZVswXTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2NvbnNvbGUvc3JjL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvY29uc29sZS9zcmMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIF9yZWdpc3RlckNvbnNvbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVnaXN0ZXJDb25zb2xlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2NvbnNvbGUvc3JjL3JlZ2lzdGVyQ29uc29sZS5qc1wiKSk7XG52YXIgX2RlZmF1bHQgPSBfcmVnaXN0ZXJDb25zb2xlLmRlZmF1bHQ7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvY29uc29sZS9zcmMvcmVnaXN0ZXJDb25zb2xlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2NvbnNvbGUvc3JjL3JlZ2lzdGVyQ29uc29sZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcmVnaXN0ZXJDb25zb2xlO1xudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZiAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXCIpKTtcbnZhciBfZW5oYW5jZUZ1bmMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBsb2dyb2NrZXQvdXRpbHMvc3JjL2VuaGFuY2VGdW5jICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9lbmhhbmNlRnVuYy5qc1wiKSk7XG52YXIgX2V4Y2VwdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAbG9ncm9ja2V0L2V4Y2VwdGlvbnMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvZXhjZXB0aW9ucy9zcmMvaW5kZXguanNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5mdW5jdGlvbiByZWdpc3RlckNvbnNvbGUobG9nZ2VyKSB7XG4gIHZhciB1bnN1YkZ1bmN0aW9ucyA9IFtdO1xuICB2YXIgbWV0aG9kcyA9IFsnbG9nJywgJ3dhcm4nLCAnaW5mbycsICdlcnJvcicsICdkZWJ1ZyddO1xuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHVuc3ViRnVuY3Rpb25zLnB1c2goKDAsIF9lbmhhbmNlRnVuYy5kZWZhdWx0KShjb25zb2xlLCBtZXRob2QsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmFkZEV2ZW50KCdsci5jb3JlLkxvZ0V2ZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uc29sZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gY29uc29sZU9wdGlvbnMuaXNFbmFibGVkO1xuICAgICAgICBpZiAoKDAsIF90eXBlb2YyLmRlZmF1bHQpKGlzRW5hYmxlZCkgPT09ICdvYmplY3QnICYmIGlzRW5hYmxlZFttZXRob2RdID09PSBmYWxzZSB8fCBpc0VuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2Vycm9yJyAmJiBjb25zb2xlT3B0aW9ucy5zaG91bGRBZ2dyZWdhdGVDb25zb2xlRXJyb3JzKSB7XG4gICAgICAgICAgX2V4Y2VwdGlvbnMuQ2FwdHVyZS5jYXB0dXJlTWVzc2FnZShsb2dnZXIsIGFyZ3NbMF0sIGFyZ3MsIHt9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvZ0xldmVsOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHVuc3ViRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHVuc3ViRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiB1bnN1YkZ1bmN0aW9uKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9leGNlcHRpb25zL3NyYy9DYXB0dXJlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC9leGNlcHRpb25zL3NyYy9DYXB0dXJlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY2FwdHVyZU1lc3NhZ2UgPSBjYXB0dXJlTWVzc2FnZTtcbmV4cG9ydHMuY2FwdHVyZUV4Y2VwdGlvbiA9IGNhcHR1cmVFeGNlcHRpb247XG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGxvZ3JvY2tldC91dGlscyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvaW5kZXgudHNcIik7XG52YXIgX1RyYWNlS2l0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAbG9ncm9ja2V0L3V0aWxzL3NyYy9UcmFjZUtpdCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvVHJhY2VLaXQuanNcIikpO1xudmFyIF9zdGFja1RyYWNlRnJvbUVycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0YWNrVHJhY2VGcm9tRXJyb3IgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvZXhjZXB0aW9ucy9zcmMvc3RhY2tUcmFjZUZyb21FcnJvci5qc1wiKSk7XG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5mdW5jdGlvbiBjYXB0dXJlTWVzc2FnZShsb2dnZXIsIG1lc3NhZ2UsIG1lc3NhZ2VBcmdzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgdmFyIGlzQ29uc29sZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gIHZhciBkYXRhID0ge1xuICAgIGV4Y2VwdGlvblR5cGU6IGlzQ29uc29sZSA/ICdDT05TT0xFJyA6ICdNRVNTQUdFJyxcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIG1lc3NhZ2VBcmdzOiBtZXNzYWdlQXJncyxcbiAgICBicm93c2VySHJlZjogd2luZG93LmxvY2F0aW9uID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiAnJ1xuICB9O1xuICAoMCwgX3V0aWxzLnNjcnViRXhjZXB0aW9uKShkYXRhLCBvcHRpb25zKTtcbiAgbG9nZ2VyLmFkZEV2ZW50KCdsci5jb3JlLkV4Y2VwdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjYXB0dXJlRXhjZXB0aW9uKGxvZ2dlciwgZXhjZXB0aW9uKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHByZXBwZWRUcmFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgdmFyIHRyYWNlID0gcHJlcHBlZFRyYWNlIHx8IF9UcmFjZUtpdC5kZWZhdWx0LmNvbXB1dGVTdGFja1RyYWNlKGV4Y2VwdGlvbik7XG4gIHZhciBkYXRhID0ge1xuICAgIGV4Y2VwdGlvblR5cGU6ICdXSU5ET1cnLFxuICAgIGVycm9yVHlwZTogdHJhY2UubmFtZSxcbiAgICBtZXNzYWdlOiB0cmFjZS5tZXNzYWdlLFxuICAgIGJyb3dzZXJIcmVmOiB3aW5kb3cubG9jYXRpb24gPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICcnXG4gIH07XG4gICgwLCBfdXRpbHMuc2NydWJFeGNlcHRpb24pKGRhdGEsIG9wdGlvbnMpO1xuICB2YXIgYWRkRXZlbnRPcHRpb25zID0ge1xuICAgIF9zdGFja1RyYWNlOiAoMCwgX3N0YWNrVHJhY2VGcm9tRXJyb3IuZGVmYXVsdCkodHJhY2UpXG4gIH07XG4gIGxvZ2dlci5hZGRFdmVudCgnbHIuY29yZS5FeGNlcHRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sIGFkZEV2ZW50T3B0aW9ucyk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9leGNlcHRpb25zL3NyYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2V4Y2VwdGlvbnMvc3JjL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG52YXIgX3R5cGVvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlckV4Y2VwdGlvbnNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWdpc3RlckV4Y2VwdGlvbnMuZGVmYXVsdDtcbiAgfVxufSkpO1xuZXhwb3J0cy5DYXB0dXJlID0gdm9pZCAwO1xudmFyIF9yZWdpc3RlckV4Y2VwdGlvbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVnaXN0ZXJFeGNlcHRpb25zICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2V4Y2VwdGlvbnMvc3JjL3JlZ2lzdGVyRXhjZXB0aW9ucy5qc1wiKSk7XG52YXIgQ2FwdHVyZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQ2FwdHVyZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9leGNlcHRpb25zL3NyYy9DYXB0dXJlLmpzXCIpKTtcbmV4cG9ydHMuQ2FwdHVyZSA9IENhcHR1cmU7XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvZXhjZXB0aW9ucy9zcmMvcmF2ZW4vcmF2ZW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC9leGNlcHRpb25zL3NyYy9yYXZlbi9yYXZlbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjayAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanNcIikpO1xudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXCIpKTtcbnZhciBfVHJhY2VLaXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBsb2dyb2NrZXQvdXRpbHMvc3JjL1RyYWNlS2l0ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9UcmFjZUtpdC5qc1wiKSk7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKlxuU29tZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgd2VyZSBvcmlnaW5hbHkgZnJvbSByYXZlbi1qcywgQlNELTIgQ2xhdXNlXG5cbkNvcHlyaWdodCAoYykgMjAxOCBTZW50cnkgKGh0dHBzOi8vc2VudHJ5LmlvKSBhbmQgaW5kaXZpZHVhbCBjb250cmlidXRvcnMuXG5BbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaXNVbmRlZmluZWQod2hhdCkge1xuICByZXR1cm4gd2hhdCA9PT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih3aGF0KSB7XG4gIHJldHVybiB0eXBlb2Ygd2hhdCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYWxsYmFjaykge1xuICB2YXIgaSwgajtcbiAgaWYgKGlzVW5kZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgZm9yIChpIGluIG9iaikge1xuICAgICAgaWYgKGhhc0tleShvYmosIGkpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgaSwgb2JqW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaiA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGopIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBpLCBvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGhhc0tleSwgYSBiZXR0ZXIgZm9ybSBvZiBoYXNPd25Qcm9wZXJ0eVxuICogRXhhbXBsZTogaGFzS2V5KE1haW5Ib3N0T2JqZWN0LCBwcm9wZXJ0eSkgPT09IHRydWUvZmFsc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaG9zdCBvYmplY3QgdG8gY2hlY2sgcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaGFzS2V5KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbi8qKlxuICogUG9seWZpbGwgYSBtZXRob2RcbiAqIEBwYXJhbSBvYmogb2JqZWN0IGUuZy4gYGRvY3VtZW50YFxuICogQHBhcmFtIG5hbWUgbWV0aG9kIG5hbWUgcHJlc2VudCBvbiBvYmplY3QgZS5nLiBgYWRkRXZlbnRMaXN0ZW5lcmBcbiAqIEBwYXJhbSByZXBsYWNlbWVudCByZXBsYWNlbWVudCBmdW5jdGlvblxuICogQHBhcmFtIHRyYWNrIHtvcHRpb25hbH0gcmVjb3JkIGluc3RydW1lbnRhdGlvbiB0byBhbiBhcnJheVxuICovXG5mdW5jdGlvbiBmaWxsKG9iaiwgbmFtZSwgcmVwbGFjZW1lbnQsIHRyYWNrKSB7XG4gIHZhciBvcmlnID0gb2JqW25hbWVdO1xuICBvYmpbbmFtZV0gPSByZXBsYWNlbWVudChvcmlnKTtcbiAgaWYgKHRyYWNrKSB7XG4gICAgdHJhY2sucHVzaChbb2JqLCBuYW1lLCBvcmlnXSk7XG4gIH1cbn1cbnZhciBfd2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcbnZhciBfZG9jdW1lbnQgPSBfd2luZG93LmRvY3VtZW50O1xudmFyIEhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIYW5kbGVyKF9yZWYpIHtcbiAgICB2YXIgY2FwdHVyZUV4Y2VwdGlvbiA9IF9yZWYuY2FwdHVyZUV4Y2VwdGlvbjtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBIYW5kbGVyKTtcbiAgICB0aGlzLl9lcnJvckhhbmRsZXIgPSB0aGlzLl9lcnJvckhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9pZ25vcmVPbkVycm9yID0gMDtcbiAgICB0aGlzLl93cmFwcGVkQnVpbHRJbnMgPSBbXTtcbiAgICB0aGlzLmNhcHR1cmVFeGNlcHRpb24gPSBjYXB0dXJlRXhjZXB0aW9uO1xuICAgIF9UcmFjZUtpdC5kZWZhdWx0LnJlcG9ydC5zdWJzY3JpYmUodGhpcy5fZXJyb3JIYW5kbGVyKTtcbiAgICB0aGlzLl9pbnN0cnVtZW50VHJ5Q2F0Y2goKTtcbiAgfVxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShIYW5kbGVyLCBbe1xuICAgIGtleTogXCJ1bmluc3RhbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5pbnN0YWxsKCkge1xuICAgICAgX1RyYWNlS2l0LmRlZmF1bHQucmVwb3J0LnVuc3Vic2NyaWJlKHRoaXMuX2Vycm9ySGFuZGxlcik7XG5cbiAgICAgIC8vIHJlc3RvcmUgYW55IHdyYXBwZWQgYnVpbHRpbnNcbiAgICAgIHZhciBidWlsdGluO1xuICAgICAgd2hpbGUgKHRoaXMuX3dyYXBwZWRCdWlsdElucy5sZW5ndGgpIHtcbiAgICAgICAgYnVpbHRpbiA9IHRoaXMuX3dyYXBwZWRCdWlsdElucy5zaGlmdCgpO1xuICAgICAgICB2YXIgb2JqID0gYnVpbHRpblswXSxcbiAgICAgICAgICBuYW1lID0gYnVpbHRpblsxXSxcbiAgICAgICAgICBvcmlnID0gYnVpbHRpblsyXTtcbiAgICAgICAgb2JqW25hbWVdID0gb3JpZztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Vycm9ySGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXJyb3JIYW5kbGVyKHJlcG9ydCkge1xuICAgICAgaWYgKCF0aGlzLl9pZ25vcmVPbkVycm9yKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZUV4Y2VwdGlvbihyZXBvcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaWdub3JlTmV4dE9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lnbm9yZU5leHRPbkVycm9yKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuX2lnbm9yZU9uRXJyb3IgKz0gMTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBvbmVycm9yIHNob3VsZCB0cmlnZ2VyIGJlZm9yZSBzZXRUaW1lb3V0XG4gICAgICAgIF90aGlzLl9pZ25vcmVPbkVycm9yIC09IDE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFdyYXAgY29kZSB3aXRoaW4gYSBjb250ZXh0IHNvIEhhbmRsZXIgY2FuIGNhcHR1cmUgZXJyb3JzXG4gICAgICogcmVsaWFibHkgYWNyb3NzIGRvbWFpbnMgdGhhdCBpcyBleGVjdXRlZCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEEgc3BlY2lmaWMgc2V0IG9mIG9wdGlvbnMgZm9yIHRoaXMgY29udGV4dCBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgY2FsbGJhY2sgdG8gYmUgaW1tZWRpYXRlbHkgZXhlY3V0ZWQgd2l0aGluIHRoZSBjb250ZXh0XG4gICAgICogQHBhcmFtIHthcnJheX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGNhbGxiYWNrIFtvcHRpb25hbF1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRleHQob3B0aW9ucywgZnVuYywgYXJncykge1xuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgYXJncyA9IGZ1bmMgfHwgW107XG4gICAgICAgIGZ1bmMgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcChvcHRpb25zLCBmdW5jKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid3JhcFwiLFxuICAgIHZhbHVlOlxuICAgIC8qXG4gICAgICogV3JhcCBjb2RlIHdpdGhpbiBhIGNvbnRleHQgYW5kIHJldHVybnMgYmFjayBhIG5ldyBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQSBzcGVjaWZpYyBzZXQgb2Ygb3B0aW9ucyBmb3IgdGhpcyBjb250ZXh0IFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiZSB3cmFwcGVkIGluIGEgbmV3IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIEEgZnVuY3Rpb24gdG8gY2FsbCBiZWZvcmUgdGhlIHRyeS9jYXRjaCB3cmFwcGVyIFtvcHRpb25hbCwgcHJpdmF0ZV1cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIG5ld2x5IHdyYXBwZWQgZnVuY3Rpb25zIHdpdGggYSBjb250ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcChvcHRpb25zLCBmdW5jLCBfYmVmb3JlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvLyAxIGFyZ3VtZW50IGhhcyBiZWVuIHBhc3NlZCwgYW5kIGl0J3Mgbm90IGEgZnVuY3Rpb25cbiAgICAgIC8vIHNvIGp1c3QgcmV0dXJuIGl0XG4gICAgICBpZiAoaXNVbmRlZmluZWQoZnVuYykgJiYgIWlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8vIG9wdGlvbnMgaXMgb3B0aW9uYWxcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIGZ1bmMgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSd2ZSBwYXNzZWQgYWxvbmcgMiBhcmd1bWVudHMsIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAgICAgLy8gaXMgbm90IGEgZnVuY3Rpb24gZWl0aGVyLCBzbyB3ZSdsbCBqdXN0IHJldHVybiB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBkb24ndCB3YW5uYSB3cmFwIGl0IHR3aWNlIVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGZ1bmMuX19scl9fKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGhhcyBhbHJlYWR5IGJlZW4gd3JhcHBlZCBpbiB0aGUgcGFzdCwgcmV0dXJuIHRoYXRcbiAgICAgICAgaWYgKGZ1bmMuX19scl93cmFwcGVyX18pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5fX2xyX3dyYXBwZXJfXztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGZ1bmMgaXMgbm90IGV4dGVuc2libGUsIHJldHVybiB0aGUgZnVuY3Rpb24gYXMtaXMgdG8gcHJldmVudCBUeXBlRXJyb3JzXG4gICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGFkZCBuZXcgcHJvcHMgJiB0byBhc3N1cmUgaW1tdXRhYmxlIGZ1bmNzIGFyZW4ndCBjaGFuZ2VkXG4gICAgICAgIGlmICghT2JqZWN0LmlzRXh0ZW5zaWJsZShmdW5jKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEp1c3QgYWNjZXNzaW5nIGN1c3RvbSBwcm9wcyBpbiBzb21lIFNlbGVuaXVtIGVudmlyb25tZW50c1xuICAgICAgICAvLyBjYW4gY2F1c2UgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXhjZXB0aW9uIChzZWUgbHItanMjNDk1KS5cbiAgICAgICAgLy8gQmFpbCBvbiB3cmFwcGluZyBhbmQgcmV0dXJuIHRoZSBmdW5jdGlvbiBhcy1pcyAoZGVmZXJzIHRvIHdpbmRvdy5vbmVycm9yKS5cbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3cmFwcGVkKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGRlZXAgPSAhb3B0aW9ucyB8fCBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCAhPT0gZmFsc2U7XG4gICAgICAgIGlmIChfYmVmb3JlICYmIGlzRnVuY3Rpb24oX2JlZm9yZSkpIHtcbiAgICAgICAgICBfYmVmb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWN1cnNpdmVseSB3cmFwIGFsbCBvZiBhIGZ1bmN0aW9uJ3MgYXJndW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vIGZ1bmN0aW9ucyB0aGVtc2VsdmVzLlxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGRlZXAgPyBzZWxmLndyYXAob3B0aW9ucywgYXJndW1lbnRzW2ldKSA6IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEF0dGVtcHQgdG8gaW52b2tlIHVzZXItbGFuZCBmdW5jdGlvbi4gVGhpcyBpcyBwYXJ0IG9mIHRoZSBMb2dSb2NrZXQgU0RLLlxuICAgICAgICAgIC8vIElmIHlvdSdyZSBzZWVpbmcgdGhpcyBmcmFtZSBpbiBhIHN0YWNrIHRyYWNlLCBpdCBtZWFucyB0aGF0IExvZ1JvY2tldCBjYXVnaHRcbiAgICAgICAgICAvLyBhbiB1bmhhbmRsZWQgZXJyb3IgdGhyb3duIGJ5IHlvdXIgYXBwbGljYXRpb24gY29kZSwgcmVwb3J0ZWQgaXQsIHRoZW4gYnViYmxlZFxuICAgICAgICAgIC8vIGl0IHVwLiBUaGlzIGlzIGV4cGVjdGVkIGJlaGF2aW9yIGFuZCBpcyBub3QgYSBidWcgd2l0aCBMb2dSb2NrZXQuXG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzZWxmLl9pZ25vcmVOZXh0T25FcnJvcigpO1xuICAgICAgICAgIHNlbGYuY2FwdHVyZUV4Y2VwdGlvbihfVHJhY2VLaXQuZGVmYXVsdC5jb21wdXRlU3RhY2tUcmFjZShlKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb3B5IG92ZXIgcHJvcGVydGllcyBvZiB0aGUgb2xkIGZ1bmN0aW9uXG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmdW5jKSB7XG4gICAgICAgIGlmIChoYXNLZXkoZnVuYywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgd3JhcHBlZFtwcm9wZXJ0eV0gPSBmdW5jW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd3JhcHBlZC5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgIGZ1bmMuX19scl93cmFwcGVyX18gPSB3cmFwcGVkO1xuICAgICAgLy8gU2lnbmFsIHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiB3cmFwcGVkIGFscmVhZHlcbiAgICAgIC8vIGZvciBib3RoIGRlYnVnZ2luZyBhbmQgdG8gcHJldmVudCBpdCB0byBiZWluZyB3cmFwcGVkIHR3aWNlXG4gICAgICB3cmFwcGVkLl9fbHJfXyA9IHRydWU7XG4gICAgICB3cmFwcGVkLl9faW5uZXJfXyA9IGZ1bmM7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luc3RydW1lbnRUcnlDYXRjaFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEluc3RhbGwgYW55IHF1ZXVlZCBwbHVnaW5zXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2luc3RydW1lbnRUcnlDYXRjaCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB3cmFwcGVkQnVpbHRJbnMgPSBzZWxmLl93cmFwcGVkQnVpbHRJbnM7XG4gICAgICBmdW5jdGlvbiB3cmFwVGltZUZuKG9yaWcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdCkge1xuICAgICAgICAgIC8vIHByZXNlcnZlIGFyaXR5XG4gICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50cyB0byBwcmV2ZW50IGRlb3B0aW1pemF0aW9uXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMyLWxlYWtpbmctYXJndW1lbnRzXG4gICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JpZ2luYWxDYWxsYmFjayA9IGFyZ3NbMF07XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3JpZ2luYWxDYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBzZWxmLndyYXAob3JpZ2luYWxDYWxsYmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSUUgPCA5IGRvZXNuJ3Qgc3VwcG9ydCAuY2FsbC8uYXBwbHkgb24gc2V0SW50ZXJ2YWwvc2V0VGltZW91dCwgYnV0IGl0XG4gICAgICAgICAgLy8gYWxzbyBzdXBwb3J0cyBvbmx5IHR3byBhcmd1bWVudHMgYW5kIGRvZXNuJ3QgY2FyZSB3aGF0IHRoaXMgaXMsIHNvIHdlXG4gICAgICAgICAgLy8gY2FuIGp1c3QgY2FsbCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGlyZWN0bHkuXG4gICAgICAgICAgaWYgKG9yaWcuYXBwbHkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZyhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3cmFwRXZlbnRUYXJnZXQoZ2xvYmFsKSB7XG4gICAgICAgIHZhciBwcm90byA9IF93aW5kb3dbZ2xvYmFsXSAmJiBfd2luZG93W2dsb2JhbF0ucHJvdG90eXBlO1xuICAgICAgICBpZiAocHJvdG8gJiYgcHJvdG8uaGFzT3duUHJvcGVydHkgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJ2FkZEV2ZW50TGlzdGVuZXInKSkge1xuICAgICAgICAgIGZpbGwocHJvdG8sICdhZGRFdmVudExpc3RlbmVyJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZ0TmFtZSwgZm4sIGNhcHR1cmUsIHNlY3VyZSkge1xuICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBhcml0eVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChmbiAmJiBmbi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgZm4uaGFuZGxlRXZlbnQgPSBzZWxmLndyYXAoZm4uaGFuZGxlRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuIHNvbWV0aW1lcyBnZXQgJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBwcm9wZXJ0eSBcImhhbmRsZSBFdmVudCdcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE1vcmUgYnJlYWRjcnVtYiBET00gY2FwdHVyZSAuLi4gZG9uZSBoZXJlIGFuZCBub3QgaW4gYF9pbnN0cnVtZW50QnJlYWRjcnVtYnNgXG4gICAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSBtb3JlIHRoYW4gb25lIHdyYXBwZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgdmFyIGJlZm9yZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuY2FsbCh0aGlzLCBldnROYW1lLCBzZWxmLndyYXAoZm4sIHVuZGVmaW5lZCwgYmVmb3JlKSwgY2FwdHVyZSwgc2VjdXJlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSwgd3JhcHBlZEJ1aWx0SW5zKTtcbiAgICAgICAgICBmaWxsKHByb3RvLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZm4sIGNhcHR1cmUsIHNlY3VyZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZuID0gZm4gJiYgKGZuLl9fbHJfd3JhcHBlcl9fID8gZm4uX19scl93cmFwcGVyX18gOiBmbik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUsIGFjY2Vzc2luZyBfX2xyX3dyYXBwZXJfXyB3aWxsIHRocm93IGluIHNvbWUgU2VsZW5pdW0gZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuY2FsbCh0aGlzLCBldnQsIGZuLCBjYXB0dXJlLCBzZWN1cmUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LCB3cmFwcGVkQnVpbHRJbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaWxsKF93aW5kb3csICdzZXRUaW1lb3V0Jywgd3JhcFRpbWVGbiwgd3JhcHBlZEJ1aWx0SW5zKTtcbiAgICAgIGZpbGwoX3dpbmRvdywgJ3NldEludGVydmFsJywgd3JhcFRpbWVGbiwgd3JhcHBlZEJ1aWx0SW5zKTtcbiAgICAgIGlmIChfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICBmaWxsKF93aW5kb3csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnKHNlbGYud3JhcChjYikpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIHdyYXBwZWRCdWlsdElucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGV2ZW50IHRhcmdldHMgYm9ycm93ZWQgZnJvbSBidWdzbmFnLWpzOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2J1Z3NuYWcvYnVnc25hZy1qcy9ibG9iL21hc3Rlci9zcmMvYnVnc25hZy5qcyNMNjY2XG4gICAgICB2YXIgZXZlbnRUYXJnZXRzID0gWydFdmVudFRhcmdldCcsICdXaW5kb3cnLCAnTm9kZScsICdBcHBsaWNhdGlvbkNhY2hlJywgJ0F1ZGlvVHJhY2tMaXN0JywgJ0NoYW5uZWxNZXJnZXJOb2RlJywgJ0NyeXB0b09wZXJhdGlvbicsICdFdmVudFNvdXJjZScsICdGaWxlUmVhZGVyJywgJ0hUTUxVbmtub3duRWxlbWVudCcsICdJREJEYXRhYmFzZScsICdJREJSZXF1ZXN0JywgJ0lEQlRyYW5zYWN0aW9uJywgJ0tleU9wZXJhdGlvbicsICdNZWRpYUNvbnRyb2xsZXInLCAnTWVzc2FnZVBvcnQnLCAnTW9kYWxXaW5kb3cnLCAnTm90aWZpY2F0aW9uJywgJ1NWR0VsZW1lbnRJbnN0YW5jZScsICdTY3JlZW4nLCAnVGV4dFRyYWNrJywgJ1RleHRUcmFja0N1ZScsICdUZXh0VHJhY2tMaXN0JywgJ1dlYlNvY2tldCcsICdXZWJTb2NrZXRXb3JrZXInLCAnV29ya2VyJywgJ1hNTEh0dHBSZXF1ZXN0JywgJ1hNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQnLCAnWE1MSHR0cFJlcXVlc3RVcGxvYWQnXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyYXBFdmVudFRhcmdldChldmVudFRhcmdldHNbaV0pO1xuICAgICAgfVxuICAgICAgdmFyICQgPSBfd2luZG93LmpRdWVyeSB8fCBfd2luZG93LiQ7XG4gICAgICBpZiAoJCAmJiAkLmZuICYmICQuZm4ucmVhZHkpIHtcbiAgICAgICAgZmlsbCgkLmZuLCAncmVhZHknLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnLmNhbGwodGhpcywgc2VsZi53cmFwKGZuKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgd3JhcHBlZEJ1aWx0SW5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhhbmRsZXI7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEhhbmRsZXI7XG47XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9leGNlcHRpb25zL3NyYy9yZWdpc3RlckV4Y2VwdGlvbnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvZXhjZXB0aW9ucy9zcmMvcmVnaXN0ZXJFeGNlcHRpb25zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xudmFyIF90eXBlb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZiAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSByZWdpc3RlckNvcmU7XG52YXIgX3JhdmVuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhdmVuL3JhdmVuICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2V4Y2VwdGlvbnMvc3JjL3JhdmVuL3JhdmVuLmpzXCIpKTtcbnZhciBDYXB0dXJlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9DYXB0dXJlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2V4Y2VwdGlvbnMvc3JjL0NhcHR1cmUuanNcIikpO1xuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29yZShsb2dnZXIpIHtcbiAgdmFyIHJhdmVuID0gbmV3IF9yYXZlbi5kZWZhdWx0KHtcbiAgICBjYXB0dXJlRXhjZXB0aW9uOiBmdW5jdGlvbiBjYXB0dXJlRXhjZXB0aW9uKGVycm9yUmVwb3J0KSB7XG4gICAgICBDYXB0dXJlLmNhcHR1cmVFeGNlcHRpb24obG9nZ2VyLCBudWxsLCBudWxsLCBlcnJvclJlcG9ydCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHJlamVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiByZWplY3Rpb25IYW5kbGVyKGV2dCkge1xuICAgIC8vIGh0dHA6Ly8yYWxpdHkuY29tLzIwMTYvMDQvdW5oYW5kbGVkLXJlamVjdGlvbnMuaHRtbFxuICAgIGxvZ2dlci5hZGRFdmVudCgnbHIuY29yZS5FeGNlcHRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleGNlcHRpb25UeXBlOiAnVU5IQU5ETEVEX1JFSkVDVElPTicsXG4gICAgICAgIG1lc3NhZ2U6IGV2dC5yZWFzb24gfHwgJ1VuaGFuZGxlZCBQcm9taXNlIHJlamVjdGlvbidcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgcmF2ZW4udW5pbnN0YWxsKCk7XG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9leGNlcHRpb25zL3NyYy9zdGFja1RyYWNlRnJvbUVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC9leGNlcHRpb25zL3NyYy9zdGFja1RyYWNlRnJvbUVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc3RhY2tUcmFjZUZyb21FcnJvcjtcbmZ1bmN0aW9uIHN0YWNrVHJhY2VGcm9tRXJyb3IoZXJyb3JSZXBvcnQpIHtcbiAgZnVuY3Rpb24gbWFrZU5vdE51bGwodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbDtcbiAgfVxuICByZXR1cm4gZXJyb3JSZXBvcnQuc3RhY2sgPyBlcnJvclJlcG9ydC5zdGFjay5tYXAoZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVOdW1iZXI6IG1ha2VOb3ROdWxsKGZyYW1lLmxpbmUpLFxuICAgICAgY29sdW1uTnVtYmVyOiBtYWtlTm90TnVsbChmcmFtZS5jb2x1bW4pLFxuICAgICAgZmlsZU5hbWU6IG1ha2VOb3ROdWxsKGZyYW1lLnVybCksXG4gICAgICBmdW5jdGlvbk5hbWU6IG1ha2VOb3ROdWxsKGZyYW1lLmZ1bmMpXG4gICAgfTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9uZXR3b3JrL3NyYy9mZXRjaEludGVyY2VwdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L25ldHdvcmsvc3JjL2ZldGNoSW50ZXJjZXB0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBfdG9Db25zdW1hYmxlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qc1wiKSk7XG52YXIgX3JlZ2lzdGVyWEhSID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWdpc3RlclhIUiAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9uZXR3b3JrL3NyYy9yZWdpc3RlclhIUi5qc1wiKTtcbnZhciBpbnRlcmNlcHRvcnMgPSBbXTtcbmZ1bmN0aW9uIG1ha2VJbnRlcmNlcHRvcihmZXRjaCwgZmV0Y2hJZCkge1xuICB2YXIgcmV2ZXJzZWRJbnRlcmNlcHRvcnMgPSBpbnRlcmNlcHRvcnMucmVkdWNlKGZ1bmN0aW9uIChhcnJheSwgaW50ZXJjZXB0b3IpIHtcbiAgICByZXR1cm4gW2ludGVyY2VwdG9yXS5jb25jYXQoYXJyYXkpO1xuICB9LCBbXSk7XG4gIC8vIGlmIGEgYnJvd3NlciBzdXBwb3J0cyBmZXRjaCwgaXQgc3VwcG9ydHMgcHJvbWlzZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYXJncyk7XG5cbiAgLy8gUmVnaXN0ZXIgcmVxdWVzdCBpbnRlcmNlcHRvcnNcbiAgcmV2ZXJzZWRJbnRlcmNlcHRvcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciByZXF1ZXN0ID0gX3JlZi5yZXF1ZXN0LFxuICAgICAgcmVxdWVzdEVycm9yID0gX3JlZi5yZXF1ZXN0RXJyb3I7XG4gICAgaWYgKHJlcXVlc3QgfHwgcmVxdWVzdEVycm9yKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0LmFwcGx5KHZvaWQgMCwgW2ZldGNoSWRdLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShhcmdzKSkpO1xuICAgICAgfSwgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RFcnJvci5hcHBseSh2b2lkIDAsIFtmZXRjaElkXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoYXJncykpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAoMCwgX3JlZ2lzdGVyWEhSLnNldEFjdGl2ZSkoZmFsc2UpO1xuICAgIHZhciByZXM7XG4gICAgdmFyIGVycjtcbiAgICB0cnkge1xuICAgICAgcmVzID0gZmV0Y2guYXBwbHkodm9pZCAwLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShhcmdzKSk7XG4gICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgZXJyID0gX2VycjtcbiAgICB9XG4gICAgKDAsIF9yZWdpc3RlclhIUi5zZXRBY3RpdmUpKHRydWUpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSk7XG4gIHJldmVyc2VkSW50ZXJjZXB0b3JzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gX3JlZjIucmVzcG9uc2UsXG4gICAgICByZXNwb25zZUVycm9yID0gX3JlZjIucmVzcG9uc2VFcnJvcjtcbiAgICBpZiAocmVzcG9uc2UgfHwgcmVzcG9uc2VFcnJvcikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZShmZXRjaElkLCByZXMpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VFcnJvciAmJiByZXNwb25zZUVycm9yKGZldGNoSWQsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGF0dGFjaChlbnYpIHtcbiAgaWYgKCFlbnYuZmV0Y2ggfHwgIWVudi5Qcm9taXNlKSB7XG4gICAgLy8gTWFrZSBzdXJlIGZldGNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuIElmIGl0J3Mgbm90LCB0aGVuXG4gICAgLy8gZGVmYXVsdCB0byB1c2luZyBYSFIgaW50ZXJjZXB0LlxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaXNQb2x5ZmlsbCA9IGVudi5mZXRjaC5wb2x5ZmlsbDtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZW52LmZldGNoID0gZnVuY3Rpb24gKGZldGNoKSB7XG4gICAgdmFyIGZldGNoSWQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VJbnRlcmNlcHRvci5hcHBseSh2b2lkIDAsIFtmZXRjaCwgZmV0Y2hJZCsrXS5jb25jYXQoYXJncykpO1xuICAgIH07XG4gIH0oZW52LmZldGNoKTtcblxuICAvLyBGb3J3YXJkIHRoZSBwb2x5ZmlsbCBwcm9wZXJseSBmcm9tIGZldGNoIChzZXQgYnkgZ2l0aHViL3doYXR3Zy1mZXRjaCkuXG4gIGlmIChpc1BvbHlmaWxsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgZW52LmZldGNoLnBvbHlmaWxsID0gaXNQb2x5ZmlsbDtcbiAgfVxufVxuXG4vLyBUT0RPOiBSZWFjdCBOYXRpdmVcbi8vICAgYXR0YWNoKGdsb2JhbCk7XG5cbnZhciBkaWRBdHRhY2ggPSBmYWxzZTtcbnZhciBfZGVmYXVsdCA9IHtcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKCFkaWRBdHRhY2gpIHtcbiAgICAgIGRpZEF0dGFjaCA9IHRydWU7XG4gICAgICBhdHRhY2god2luZG93KTtcbiAgICB9XG4gICAgaW50ZXJjZXB0b3JzLnB1c2goaW50ZXJjZXB0b3IpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbnRlcmNlcHRvcnMuaW5kZXhPZihpbnRlcmNlcHRvcik7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBpbnRlcmNlcHRvcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaW50ZXJjZXB0b3JzID0gW107XG4gIH1cbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvbmV0d29yay9zcmMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC9uZXR3b3JrL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSByZWdpc3Rlck5ldHdvcms7XG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcIikpO1xudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZiAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXCIpKTtcbnZhciBfcmVnaXN0ZXJGZXRjaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWdpc3RlckZldGNoICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L25ldHdvcmsvc3JjL3JlZ2lzdGVyRmV0Y2guanNcIikpO1xudmFyIF9yZWdpc3RlcklvbmljID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWdpc3RlcklvbmljICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L25ldHdvcmsvc3JjL3JlZ2lzdGVySW9uaWMudHNcIik7XG52YXIgX3JlZ2lzdGVyTmV0d29ya0luZm9ybWF0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlZ2lzdGVyTmV0d29ya0luZm9ybWF0aW9uICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L25ldHdvcmsvc3JjL3JlZ2lzdGVyTmV0d29ya0luZm9ybWF0aW9uLmpzXCIpKTtcbnZhciBfcmVnaXN0ZXJYSFIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVnaXN0ZXJYSFIgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvbmV0d29yay9zcmMvcmVnaXN0ZXJYSFIuanNcIikpO1xudmFyIF9tYXBWYWx1ZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBsb2dyb2NrZXQvdXRpbHMvc3JjL21hcFZhbHVlcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvbWFwVmFsdWVzLmpzXCIpKTtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5mdW5jdGlvbiByZWdpc3Rlck5ldHdvcmsobG9nZ2VyKSB7XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICBpc1JlYWN0TmF0aXZlOiBmYWxzZVxuICB9O1xuICB2YXIgaXNSZWFjdE5hdGl2ZSA9IGNvbmZpZy5pc1JlYWN0TmF0aXZlLFxuICAgIHNob3VsZEF1Z21lbnROUFMgPSBjb25maWcuc2hvdWxkQXVnbWVudE5QUyxcbiAgICBzaG91bGRQYXJzZVhIUkJsb2IgPSBjb25maWcuc2hvdWxkUGFyc2VYSFJCbG9iO1xuICB2YXIgaWdub3JlZE5ldHdvcmsgPSB7fTtcblxuICAvLyB0cnVuY2F0ZSBpZiA+IDRNQiBpbiBzaXplXG4gIHZhciB0cnVuY2F0ZSA9IGZ1bmN0aW9uIHRydW5jYXRlKGRhdGEpIHtcbiAgICB2YXIgbGltaXQgPSAxMDI0ICogMTAwMCAqIDQ7XG4gICAgdmFyIHN0ciA9IGRhdGE7XG4gICAgaWYgKCgwLCBfdHlwZW9mMi5kZWZhdWx0KShkYXRhKSA9PT0gJ29iamVjdCcgJiYgZGF0YSAhPSBudWxsKSB7XG4gICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZGF0YSk7XG4gICAgICBpZiAocHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgLy8gcGxhaW4gb2JqZWN0IC0ganNvbmlmeSBmb3IgdGhlIHNpemUgY2hlY2tcbiAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHIgJiYgc3RyLmxlbmd0aCAmJiBzdHIubGVuZ3RoID4gbGltaXQgJiYgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBiZWdpbm5pbmcgPSBzdHIuc3Vic3RyaW5nKDAsIDEwMDApO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGJlZ2lubmluZywgXCIgLi4uIExvZ1JvY2tldCB0cnVuY2F0aW5nIHRvIGZpcnN0IDEwMDAgY2hhcmFjdGVycy5cXG4gICAgICBLZWVwIGRhdGEgdW5kZXIgNE1CIHRvIHByZXZlbnQgdHJ1bmNhdGlvbi4gaHR0cHM6Ly9kb2NzLmxvZ3JvY2tldC5jb20vcmVmZXJlbmNlL25ldHdvcmtcIik7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuICB2YXIgYWRkUmVxdWVzdCA9IGZ1bmN0aW9uIGFkZFJlcXVlc3QocmVxSWQsIHJlcXVlc3QpIHtcbiAgICB2YXIgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbG9nZ2VyLmFkZEV2ZW50KCdsci5uZXR3b3JrLlJlcXVlc3RFdmVudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRpc0VuYWJsZWQgPSBfcmVmLmlzRW5hYmxlZCxcbiAgICAgICAgaXNFbmFibGVkID0gX3JlZiRpc0VuYWJsZWQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJGlzRW5hYmxlZCxcbiAgICAgICAgX3JlZiRyZXF1ZXN0U2FuaXRpemVyID0gX3JlZi5yZXF1ZXN0U2FuaXRpemVyLFxuICAgICAgICByZXF1ZXN0U2FuaXRpemVyID0gX3JlZiRyZXF1ZXN0U2FuaXRpemVyID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9IDogX3JlZiRyZXF1ZXN0U2FuaXRpemVyO1xuICAgICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc2FuaXRpemVkID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIG9ubHkgdHJ5IGNhdGNoIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnNcbiAgICAgICAgc2FuaXRpemVkID0gcmVxdWVzdFNhbml0aXplcihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlcXVlc3QpLCB7fSwge1xuICAgICAgICAgIHJlcUlkOiByZXFJZFxuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKHNhbml0aXplZCkge1xuICAgICAgICB2YXIgdXJsID0gc2FuaXRpemVkLnVybDtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBXcml0aW5nIGFuZCB0aGVuIHJlYWRpbmcgZnJvbSBhbiBhIHRhZyB0dXJucyBhIHJlbGF0aXZlXG4gICAgICAgICAgLy8gdXJsIGludG8gYW4gYWJzb2x1dGUgb25lLlxuICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgIGEuaHJlZiA9IHNhbml0aXplZC51cmw7XG4gICAgICAgICAgdXJsID0gYS5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVxSWQ6IHJlcUlkLFxuICAgICAgICAgIC8vIGRlZmF1bHRcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAvLyBzYW5pdGl6ZWRcbiAgICAgICAgICBoZWFkZXJzOiAoMCwgX21hcFZhbHVlcy5kZWZhdWx0KShzYW5pdGl6ZWQuaGVhZGVycywgZnVuY3Rpb24gKGhlYWRlclZhbHVlKSB7XG4gICAgICAgICAgICAvLyBzYW5pdGl6ZWRcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgYm9keTogdHJ1bmNhdGUoc2FuaXRpemVkLmJvZHkpLFxuICAgICAgICAgIC8vIHNhbml0aXplZFxuICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgIC8vIGRlZmF1bHRcbiAgICAgICAgICByZWZlcnJlcjogc2FuaXRpemVkLnJlZmVycmVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAvLyBzYW5pdGl6ZWRcbiAgICAgICAgICBtb2RlOiBzYW5pdGl6ZWQubW9kZSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgLy8gc2FuaXRpemVkXG4gICAgICAgICAgY3JlZGVudGlhbHM6IHNhbml0aXplZC5jcmVkZW50aWFscyB8fCB1bmRlZmluZWQgLy8gc2FuaXRpemVkXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlnbm9yZWROZXR3b3JrW3JlcUlkXSA9IHRydWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIGFkZFJlc3BvbnNlID0gZnVuY3Rpb24gYWRkUmVzcG9uc2UocmVxSWQsIHJlc3BvbnNlKSB7XG4gICAgdmFyIG1ldGhvZCA9IHJlc3BvbnNlLm1ldGhvZCxcbiAgICAgIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBsb2dnZXIuYWRkRXZlbnQoJ2xyLm5ldHdvcmsuUmVzcG9uc2VFdmVudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYyJGlzRW5hYmxlZCA9IF9yZWYyLmlzRW5hYmxlZCxcbiAgICAgICAgaXNFbmFibGVkID0gX3JlZjIkaXNFbmFibGVkID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIkaXNFbmFibGVkLFxuICAgICAgICBfcmVmMiRyZXNwb25zZVNhbml0aXogPSBfcmVmMi5yZXNwb25zZVNhbml0aXplcixcbiAgICAgICAgcmVzcG9uc2VTYW5pdGl6ZXIgPSBfcmVmMiRyZXNwb25zZVNhbml0aXogPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0gOiBfcmVmMiRyZXNwb25zZVNhbml0aXo7XG4gICAgICBpZiAoIWlzRW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoaWdub3JlZE5ldHdvcmtbcmVxSWRdKSB7XG4gICAgICAgIGRlbGV0ZSBpZ25vcmVkTmV0d29ya1tyZXFJZF07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHNhbml0aXplZCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBvbmx5IHRyeSBjYXRjaCB1c2VyIGRlZmluZWQgZnVuY3Rpb25zXG4gICAgICAgIHNhbml0aXplZCA9IHJlc3BvbnNlU2FuaXRpemVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzcG9uc2UpLCB7fSwge1xuICAgICAgICAgIHJlcUlkOiByZXFJZFxuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAvLyBmYWxsIHRocm91Z2ggdG8gcmVkYWN0ZWQgbG9nXG4gICAgICB9XG5cbiAgICAgIGlmIChzYW5pdGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXFJZDogcmVxSWQsXG4gICAgICAgICAgLy8gZGVmYXVsdFxuICAgICAgICAgIHN0YXR1czogc2FuaXRpemVkLnN0YXR1cyxcbiAgICAgICAgICAvLyBzYW5pdGl6ZWRcbiAgICAgICAgICBoZWFkZXJzOiAoMCwgX21hcFZhbHVlcy5kZWZhdWx0KShzYW5pdGl6ZWQuaGVhZGVycywgZnVuY3Rpb24gKGhlYWRlclZhbHVlKSB7XG4gICAgICAgICAgICAvLyBzYW5pdGl6ZWRcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgYm9keTogdHJ1bmNhdGUoc2FuaXRpemVkLmJvZHkpLFxuICAgICAgICAgIC8vIHNhbml0aXplZFxuICAgICAgICAgIG1ldGhvZDogbWV0aG9kIC8vIGRlZmF1bHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVxSWQ6IHJlcUlkLFxuICAgICAgICAvLyBkZWZhdWx0XG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAvLyBkZWZhdWx0XG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAvLyByZWRhY3RlZFxuICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICAvLyByZWRhY3RlZFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCAvLyBkZWZhdWx0XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBpc0lnbm9yZWQgPSBmdW5jdGlvbiBpc0lnbm9yZWQocmVxSWQpIHtcbiAgICByZXR1cm4gbG9nZ2VyLmlzRGlzYWJsZWQgfHwgaWdub3JlZE5ldHdvcmtbcmVxSWRdID09PSB0cnVlO1xuICB9O1xuICB2YXIgdW5zdWJGZXRjaCA9ICgwLCBfcmVnaXN0ZXJGZXRjaC5kZWZhdWx0KSh7XG4gICAgYWRkUmVxdWVzdDogYWRkUmVxdWVzdCxcbiAgICBhZGRSZXNwb25zZTogYWRkUmVzcG9uc2UsXG4gICAgaXNJZ25vcmVkOiBpc0lnbm9yZWRcbiAgfSk7XG4gIHZhciB1bnN1YlhIUiA9ICgwLCBfcmVnaXN0ZXJYSFIuZGVmYXVsdCkoe1xuICAgIGFkZFJlcXVlc3Q6IGFkZFJlcXVlc3QsXG4gICAgYWRkUmVzcG9uc2U6IGFkZFJlc3BvbnNlLFxuICAgIGlzSWdub3JlZDogaXNJZ25vcmVkLFxuICAgIGxvZ2dlcjogbG9nZ2VyLFxuICAgIHNob3VsZEF1Z21lbnROUFM6IHNob3VsZEF1Z21lbnROUFMsXG4gICAgc2hvdWxkUGFyc2VYSFJCbG9iOiBzaG91bGRQYXJzZVhIUkJsb2JcbiAgfSk7XG4gIHZhciB1bnN1YklvbmljID0gKDAsIF9yZWdpc3RlcklvbmljLnJlZ2lzdGVySW9uaWMpKHtcbiAgICBhZGRSZXF1ZXN0OiBhZGRSZXF1ZXN0LFxuICAgIGFkZFJlc3BvbnNlOiBhZGRSZXNwb25zZSxcbiAgICBpc0lnbm9yZWQ6IGlzSWdub3JlZFxuICB9KTtcbiAgdmFyIHVuc3ViTmV0d29ya0luZm9ybWF0aW9uID0gaXNSZWFjdE5hdGl2ZSA/IGZ1bmN0aW9uICgpIHt9IDogKDAsIF9yZWdpc3Rlck5ldHdvcmtJbmZvcm1hdGlvbi5kZWZhdWx0KShsb2dnZXIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHVuc3ViTmV0d29ya0luZm9ybWF0aW9uKCk7XG4gICAgdW5zdWJGZXRjaCgpO1xuICAgIHVuc3ViWEhSKCk7XG4gICAgdW5zdWJJb25pYygpO1xuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvbmV0d29yay9zcmMvcmVnaXN0ZXJGZXRjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvbmV0d29yay9zcmMvcmVnaXN0ZXJGZXRjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHJlZ2lzdGVyRmV0Y2g7XG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcIikpO1xudmFyIF9tYXBWYWx1ZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBsb2dyb2NrZXQvdXRpbHMvc3JjL21hcFZhbHVlcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvbWFwVmFsdWVzLmpzXCIpKTtcbnZhciBfZmV0Y2hJbnRlcmNlcHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmV0Y2hJbnRlcmNlcHQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvbmV0d29yay9zcmMvZmV0Y2hJbnRlcmNlcHQuanNcIikpO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIG1ha2VPYmplY3RGcm9tSGVhZGVycyhoZWFkZXJzKSB7XG4gIC8vIElmIHVzaW5nIHJlYWwgZmV0Y2gsIHdlIG11c3Qgc3RyaW5naWZ5IHRoZSBIZWFkZXJzIG9iamVjdC5cbiAgaWYgKGhlYWRlcnMgPT0gbnVsbCB8fCB0eXBlb2YgaGVhZGVycy5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBpZiAocmVzdWx0W2tleV0pIHtcbiAgICAgIHJlc3VsdFtrZXldID0gXCJcIi5jb25jYXQocmVzdWx0W2tleV0sIFwiLFwiKS5jb25jYXQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IFwiXCIuY29uY2F0KHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBYSFIgc3BlY2lmaWNhdGlvbiBpcyB1bmNsZWFyIG9mIHdoYXQgdHlwZXMgdG8gYWxsb3cgaW4gdmFsdWUgc28gdXNpbmcgdG9TdHJpbmcgbWV0aG9kIGZvciBub3dcbnZhciBzdHJpbmdpZnlIZWFkZXJzID0gZnVuY3Rpb24gc3RyaW5naWZ5SGVhZGVycyhoZWFkZXJzKSB7XG4gIHJldHVybiAoMCwgX21hcFZhbHVlcy5kZWZhdWx0KShtYWtlT2JqZWN0RnJvbUhlYWRlcnMoaGVhZGVycyksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWx1ZSk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIHBsdWNrRmV0Y2hGaWVsZHMoKSB7XG4gIHZhciBhcmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4ge1xuICAgIHVybDogYXJnLnVybCxcbiAgICBoZWFkZXJzOiBzdHJpbmdpZnlIZWFkZXJzKGFyZy5oZWFkZXJzKSxcbiAgICBtZXRob2Q6IGFyZy5tZXRob2QgJiYgYXJnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgIHJlZmVycmVyOiBhcmcucmVmZXJyZXIgfHwgdW5kZWZpbmVkLFxuICAgIG1vZGU6IGFyZy5tb2RlIHx8IHVuZGVmaW5lZCxcbiAgICBjcmVkZW50aWFsczogYXJnLmNyZWRlbnRpYWxzIHx8IHVuZGVmaW5lZFxuICB9O1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJGZXRjaChfcmVmKSB7XG4gIHZhciBhZGRSZXF1ZXN0ID0gX3JlZi5hZGRSZXF1ZXN0LFxuICAgIGFkZFJlc3BvbnNlID0gX3JlZi5hZGRSZXNwb25zZSxcbiAgICBpc0lnbm9yZWQgPSBfcmVmLmlzSWdub3JlZDtcbiAgdmFyIExPR1JPQ0tFVF9GRVRDSF9MQUJFTCA9ICdmZXRjaC0nO1xuICB2YXIgZmV0Y2hNZXRob2RNYXAgPSB7fTtcbiAgdmFyIHVucmVnaXN0ZXIgPSBfZmV0Y2hJbnRlcmNlcHQuZGVmYXVsdC5yZWdpc3Rlcih7XG4gICAgcmVxdWVzdDogZnVuY3Rpb24gcmVxdWVzdChmZXRjaElkKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgdmFyIHA7XG4gICAgICBpZiAodHlwZW9mIFJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmIGFyZ3NbMF0gaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgIHZhciBjbG9uZWRUZXh0O1xuXG4gICAgICAgIC8vIFJlcXVlc3QuY2xvbmUoKSBhbmQgUmVxdWVzdC50ZXh0KCkgbWF5IHRocm93IGluIFNhZmFyaSAoZS5nLiwgd2hlblxuICAgICAgICAvLyByZXF1ZXN0IGJvZHkgY29udGFpbnMgRm9ybURhdGEpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvbmVkVGV4dCA9IGFyZ3NbMF0uY2xvbmUoKS50ZXh0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGlmIGEgYnJvd3NlciBzdXBwb3J0cyBmZXRjaCwgaXQgc3VwcG9ydHMgcHJvbWlzZVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgICAgY2xvbmVkVGV4dCA9IFByb21pc2UucmVzb2x2ZShcIkxvZ1JvY2tldCBmZXRjaCBlcnJvcjogXCIuY29uY2F0KGVyci5tZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IGNsb25lZFRleHQudGhlbihmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBsdWNrRmV0Y2hGaWVsZHMoYXJnc1swXSkpLCB7fSwge1xuICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGx1Y2tGZXRjaEZpZWxkcyhhcmdzWzBdKSksIHt9LCB7XG4gICAgICAgICAgICBib2R5OiBcIkxvZ1JvY2tldCBmZXRjaCBlcnJvcjogXCIuY29uY2F0KGVyci5tZXNzYWdlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGEgYnJvd3NlciBzdXBwb3J0cyBmZXRjaCwgaXQgc3VwcG9ydHMgcHJvbWlzZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgICAgICBwID0gUHJvbWlzZS5yZXNvbHZlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGx1Y2tGZXRjaEZpZWxkcyhhcmdzWzFdKSksIHt9LCB7XG4gICAgICAgICAgdXJsOiBcIlwiLmNvbmNhdChhcmdzWzBdKSxcbiAgICAgICAgICBib2R5OiAoYXJnc1sxXSB8fCB7fSkuYm9keVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcC50aGVuKGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgZmV0Y2hNZXRob2RNYXBbZmV0Y2hJZF0gPSByZXEubWV0aG9kO1xuICAgICAgICBhZGRSZXF1ZXN0KFwiXCIuY29uY2F0KExPR1JPQ0tFVF9GRVRDSF9MQUJFTCkuY29uY2F0KGZldGNoSWQpLCByZXEpO1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVxdWVzdEVycm9yOiBmdW5jdGlvbiByZXF1ZXN0RXJyb3IoZmV0Y2hJZCwgZXJyb3IpIHtcbiAgICAgIC8vIGlmIGEgYnJvd3NlciBzdXBwb3J0cyBmZXRjaCwgaXQgc3VwcG9ydHMgcHJvbWlzZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfSxcbiAgICByZXNwb25zZTogZnVuY3Rpb24gcmVzcG9uc2UoZmV0Y2hJZCwgX3Jlc3BvbnNlKSB7XG4gICAgICB2YXIgcmVzcG9uc2VDbG9uZTtcbiAgICAgIHZhciByZXNwb25zZVRleHRQcm9taXNlO1xuICAgICAgaWYgKGlzSWdub3JlZChcIlwiLmNvbmNhdChMT0dST0NLRVRfRkVUQ0hfTEFCRUwpLmNvbmNhdChmZXRjaElkKSkpIHtcbiAgICAgICAgLy8gRG9uJ3QgZXZlbiB0cnkgdG8gcmVhZCBpZ25vcmVkIHJlcXVlc3RzXG4gICAgICAgIHJldHVybiBfcmVzcG9uc2U7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUT0RPOiBlbmhhbmNlIGZ1bmN0aW9uIG9uIG9yaWdpbmFsIHJlc3BvbnNlIGFuZCBmdXR1cmUgY2xvbmVzIGZvcjpcbiAgICAgICAgLy8gdGV4dCgpLCBqc29uKCksIGJsb2IoKSwgZm9ybWRhdGEoKSwgYXJyYXlidWZmZXIoKVxuICAgICAgICByZXNwb25zZUNsb25lID0gX3Jlc3BvbnNlLmNsb25lKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gc2FmYXJpIGhhcyBhIGJ1ZyB3aGVyZSBjbG9uaW5nIGNhbiBmYWlsXG4gICAgICAgIHZhciByZXNwb25zZUhhc2ggPSB7XG4gICAgICAgICAgdXJsOiBfcmVzcG9uc2UudXJsLFxuICAgICAgICAgIHN0YXR1czogX3Jlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzOiBzdHJpbmdpZnlIZWFkZXJzKF9yZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgICBib2R5OiBcIkxvZ1JvY2tldCBmZXRjaCBlcnJvcjogXCIuY29uY2F0KGVyci5tZXNzYWdlKSxcbiAgICAgICAgICBtZXRob2Q6IGZldGNoTWV0aG9kTWFwW2ZldGNoSWRdXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBmZXRjaE1ldGhvZE1hcFtmZXRjaElkXTtcbiAgICAgICAgYWRkUmVzcG9uc2UoXCJcIi5jb25jYXQoTE9HUk9DS0VUX0ZFVENIX0xBQkVMKS5jb25jYXQoZmV0Y2hJZCksIHJlc3BvbnNlSGFzaCk7XG4gICAgICAgIHJldHVybiBfcmVzcG9uc2U7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAod2luZG93LlRleHREZWNvZGVyICYmIHJlc3BvbnNlQ2xvbmUuYm9keSkge1xuICAgICAgICAgIC8vIHVzZSBhIHJlYWRlciB0byBtYW51YWxseSByZWFkIHRoZSByZXNwb25zZSBib2R5IHJhdGhlciB0aGFuIGNhbGxpbmcgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgICAgLy8gcmVzcG9uc2UudGV4dCgpIHdhcyB0aW1pbmcgb3V0IGZvciBzb21lIHJlc3BvbnNlcywgaW4gc29tZSBjYXNlcyBiZWNhdXNlIEFwb2xsbyBzZW5kc1xuICAgICAgICAgIC8vICAgYW4gYWJvcnQgc2lnbmFsIG9yIGJlY2F1c2UgdGhlIHN0cmVhbSB3YXNuJ3QgZ2V0dGluZyB0ZXJtaW5hdGVkIGNsZWFubHlcbiAgICAgICAgICAvLyB1c2luZyBhIHJlYWRlciBhbGxvd3MgdXMgdG8gY2FwdHVyZSB3aGF0IHdlIGNhbiBmcm9tIHJlc3BvbnNlIGJvZGllcyBiZWZvcmUgdGhlXG4gICAgICAgICAgLy8gICByZXNwb25zZSByZWNlaXZlcyBhbiBhYm9ydCBzaWduYWxcbiAgICAgICAgICB2YXIgcmVhZGVyID0gcmVzcG9uc2VDbG9uZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICAgIC8vIHJlc3BvbnNlIGJvZGllcyBhbHdheXMgZGVjb2RlIHdpdGggVVRGLThcbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzcG9uc2UvdGV4dFxuICAgICAgICAgIHZhciB1dGY4RGVjb2RlciA9IG5ldyB3aW5kb3cuVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgICAgICAgdmFyIGJvZHlDb250ZW50cyA9ICcnO1xuICAgICAgICAgIHJlc3BvbnNlVGV4dFByb21pc2UgPSByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gcmVhZFJlc3BvbnNlQm9keShfcmVmMikge1xuICAgICAgICAgICAgdmFyIGRvbmUgPSBfcmVmMi5kb25lLFxuICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJvZHlDb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaHVuayA9IHZhbHVlID8gdXRmOERlY29kZXIuZGVjb2RlKHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0cmVhbTogdHJ1ZVxuICAgICAgICAgICAgfSkgOiAnJztcbiAgICAgICAgICAgIGJvZHlDb250ZW50cyArPSBjaHVuaztcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4ocmVhZFJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGV4dERlY29kZXIgZG9lc24ndCBoYXZlIHN1cHBvcnQgYWNyb3NzIGFsbCBicm93c2VycyB0aGF0IExSIHN1cHBvcnRzLCBzbyBpZiB0aGVyZSdzXG4gICAgICAgICAgLy8gIG5vIFRleHREZWNvZGVyLCBmYWxsIGJhY2sgdG8gdGhlIG9sZCBhcHByb2FjaFxuICAgICAgICAgIHJlc3BvbnNlVGV4dFByb21pc2UgPSByZXNwb25zZUNsb25lLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgcmVzcG9uc2VUZXh0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShcIkxvZ1JvY2tldCBlcnJvciByZWFkaW5nIGJvZHk6IFwiLmNvbmNhdChlcnJvci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgICByZXNwb25zZVRleHRQcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBkb24ndCBkcm9wIHJlcXVlc3QgJiBsb2cgdG8gY29uc29sZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGFib3J0ZWQsXG4gICAgICAgIC8vIGFzIGl0IG1heSBoYXZlIGFscmVhZHkgY29tcGxldGVkXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Mb2dSb2NrZXQvbG9ncm9ja2V0L2lzc3Vlcy8zNFxuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InICYmIGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkxvZ1JvY2tldCBlcnJvciByZWFkaW5nIGJvZHk6IFwiLmNvbmNhdChlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlSGFzaCA9IHtcbiAgICAgICAgICB1cmw6IF9yZXNwb25zZS51cmwsXG4gICAgICAgICAgc3RhdHVzOiBfcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnM6IHN0cmluZ2lmeUhlYWRlcnMoX3Jlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgICAgbWV0aG9kOiBmZXRjaE1ldGhvZE1hcFtmZXRjaElkXVxuICAgICAgICB9O1xuICAgICAgICBkZWxldGUgZmV0Y2hNZXRob2RNYXBbZmV0Y2hJZF07XG4gICAgICAgIGFkZFJlc3BvbnNlKFwiXCIuY29uY2F0KExPR1JPQ0tFVF9GRVRDSF9MQUJFTCkuY29uY2F0KGZldGNoSWQpLCByZXNwb25zZUhhc2gpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3Jlc3BvbnNlO1xuICAgIH0sXG4gICAgcmVzcG9uc2VFcnJvcjogZnVuY3Rpb24gcmVzcG9uc2VFcnJvcihmZXRjaElkLCBlcnJvcikge1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICB1cmw6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgYm9keTogXCJcIi5jb25jYXQoZXJyb3IpXG4gICAgICB9O1xuICAgICAgYWRkUmVzcG9uc2UoXCJcIi5jb25jYXQoTE9HUk9DS0VUX0ZFVENIX0xBQkVMKS5jb25jYXQoZmV0Y2hJZCksIHJlc3BvbnNlKTtcbiAgICAgIC8vIGlmIGEgYnJvd3NlciBzdXBwb3J0cyBmZXRjaCwgaXQgc3VwcG9ydHMgcHJvbWlzZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVucmVnaXN0ZXI7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9uZXR3b3JrL3NyYy9yZWdpc3RlcklvbmljLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC9uZXR3b3JrL3NyYy9yZWdpc3RlcklvbmljLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMubWVyZ2VIZWFkZXJzID0gbWVyZ2VIZWFkZXJzO1xuZXhwb3J0cy5zZXJpYWxpemVRdWVyeVBhcmFtcyA9IHNlcmlhbGl6ZVF1ZXJ5UGFyYW1zO1xuZXhwb3J0cy5hcHBlbmRRdWVyeVBhcmFtc1N0cmluZyA9IGFwcGVuZFF1ZXJ5UGFyYW1zU3RyaW5nO1xuZXhwb3J0cy5wcm9jZXNzRGF0YSA9IHByb2Nlc3NEYXRhO1xuZXhwb3J0cy5yZWdpc3RlcklvbmljID0gcmVnaXN0ZXJJb25pYztcbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1wiKSk7XG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanNcIikpO1xudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzXCIpKTtcbnZhciBfcHJvdGVjdEZ1bmMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBsb2dyb2NrZXQvdXRpbHMvc3JjL3Byb3RlY3RGdW5jICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9wcm90ZWN0RnVuYy5qc1wiKSk7XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgVkFMSURfSFRUUF9NRVRIT0RTID0gbmV3IFNldChbJ2dldCcsICdwdXQnLCAncG9zdCcsICdwYXRjaCcsICdoZWFkJywgJ2RlbGV0ZScsICdvcHRpb25zJywgJ3VwbG9hZCcsICdkb3dubG9hZCddKTtcbnZhciBWQUxJRF9TRVJJQUxJWkVSUyA9IG5ldyBTZXQoWyd1cmxlbmNvZGVkJywgJ2pzb24nLCAndXRmOCddKTtcbnZhciBVTlNVUFBPUlRFRF9TRVJJQUxJWkVSUyA9IG5ldyBTZXQoWydyYXcnLCAnbXVsdGlwYXJ0J10pO1xudmFyIExPR1JPQ0tFVF9JT05JQ19MQUJFTCA9ICdpb25pYy0nO1xudmFyIFVOU1VQUE9SVEVEX1BMQVRGT1JNUyA9IG5ldyBTZXQoWydkZXNrdG9wJywgJ21vYmlsZXdlYicsICdwd2EnXSk7XG52YXIgRk9STV9EQVRBID0gbmV3IFNldChbJ0Zvcm1EYXRhJ10pO1xudmFyIEVNUFRZX1NFVCA9IG5ldyBTZXQoKTtcbnZhciBTVFJJTkdfU0VUID0gbmV3IFNldChbJ3N0cmluZyddKTtcbnZhciBTVFJJTkdfQVJSQVlfU0VUID0gbmV3IFNldChbJ3N0cmluZycsICdhcnJheSddKTtcbnZhciBBTExPV0VEX0RBVEFfVFlQRVMgPSB7XG4gIHV0Zjg6IFNUUklOR19TRVQsXG4gIHVybGVuY29kZWQ6IG5ldyBTZXQoWydvYmplY3QnXSksXG4gIGpzb246IG5ldyBTZXQoWydhcnJheScsICdvYmplY3QnXSksXG4gIHJhdzogbmV3IFNldChbJ1VpbnQ4QXJyYXknLCAnQXJyYXlCdWZmZXInXSksXG4gIGRlZmF1bHQ6IEVNUFRZX1NFVFxufTtcblxuLy8gVXNlZCBpbiBpbnRlcmNlcHRpbmcgSW9uaWMgcHVnaW4gcmVxdWVzdHMgZm91bmQgaGVyZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9AaW9uaWMtbmF0aXZlL2h0dHBcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zaWxraW1lbi9jb3Jkb3ZhLXBsdWdpbi1hZHZhbmNlZC1odHRwL2Jsb2IvbWFzdGVyL3d3dy9wdWJsaWMtaW50ZXJmYWNlLmpzXG5cbmZ1bmN0aW9uIGNoZWNrRm9yVmFsaWRTdHJpbmdWYWx1ZShsaXN0LCB2YWx1ZSwgZmllbGROYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGZpZWxkTmFtZSwgXCIgbXVzdCBiZSBvbmUgb2Y6IFwiKS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobGlzdCkuam9pbignLCAnKSkpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIHZhbHVlID0gdmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghbGlzdC5oYXModmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGZpZWxkTmFtZSwgXCIgbXVzdCBiZSBvbmUgb2Y6IFwiKS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobGlzdCkuam9pbignLCAnKSkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5VmFsdWVQYWlyT2JqZWN0KG9iaiwgYWxsb3dlZENoaWxkcmVuLCBvbkludmFsaWRWYWx1ZU1lc3NhZ2UpIHtcbiAgaWYgKCgwLCBfdHlwZW9mMi5kZWZhdWx0KShvYmopICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihvbkludmFsaWRWYWx1ZU1lc3NhZ2UpO1xuICB9XG4gIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMob2JqKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGtleSA9IF9PYmplY3Qka2V5c1tfaV07XG4gICAgaWYgKCFhbGxvd2VkQ2hpbGRyZW4uaGFzKCgwLCBfdHlwZW9mMi5kZWZhdWx0KShvYmpba2V5XSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iob25JbnZhbGlkVmFsdWVNZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGdldE1hdGNoaW5nSG9zdEhlYWRlcnModXJsLCBpb25pY0h0dHApIHtcbiAgdmFyIF9VUkwgPSBuZXcgVVJMKHVybCksXG4gICAgaG9zdCA9IF9VUkwuaG9zdDtcbiAgcmV0dXJuIGlvbmljSHR0cC5nZXRIZWFkZXJzKGhvc3QpIHx8IG51bGw7XG59XG5mdW5jdGlvbiBtZXJnZUhlYWRlcnMoZGVmYXVsdEhlYWRlcnMsIGhlYWRlcnMpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdEhlYWRlcnMpLCBoZWFkZXJzKTtcbn1cbmZ1bmN0aW9uIGdldE1lcmdlZEhlYWRlcnModXJsLCByZXF1ZXN0SGVhZGVycywgaW9uaWNIdHRwKSB7XG4gIC8vIGdldCBnbG9iYWwgaGVhZGVycyB2aWEgcHVibGljIG1ldGhvZFxuICB2YXIgZ2xvYmFsSGVhZGVycyA9IGlvbmljSHR0cC5nZXRIZWFkZXJzKCcqJykgfHwge307XG4gIHZhciBob3N0SGVhZGVycyA9IGdldE1hdGNoaW5nSG9zdEhlYWRlcnModXJsLCBpb25pY0h0dHApIHx8IHt9O1xuICByZXR1cm4gbWVyZ2VIZWFkZXJzKG1lcmdlSGVhZGVycyhnbG9iYWxIZWFkZXJzLCBob3N0SGVhZGVycyksIHJlcXVlc3RIZWFkZXJzKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBlbmNvZGUpIHtcbiAgaWYgKGVuY29kZSkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2VyaWFsaXplSWRlbnRpZmllcihwYXJlbnRLZXksIGtleSwgZW5jb2RlKSB7XG4gIGlmICghcGFyZW50S2V5Lmxlbmd0aCkge1xuICAgIHJldHVybiBlbmNvZGUgPyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSA6IGtleTtcbiAgfVxuICBpZiAoZW5jb2RlKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChwYXJlbnRLZXkpLCBcIltcIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChrZXkpLCBcIl1cIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHBhcmVudEtleSwgXCJbXCIpLmNvbmNhdChrZXksIFwiXVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkocGFyZW50S2V5LCBhcnJheSwgZW5jb2RlKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXJyYXkpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgcGFydHMucHVzaChzZXJpYWxpemVBcnJheShcIlwiLmNvbmNhdChwYXJlbnRLZXksIFwiW11cIiksIGUsIGVuY29kZSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF90eXBlb2YyLmRlZmF1bHQpKGUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvKiBUaGlzIHJlcGxpY2F0ZXMgd2hhdCBhcHBlYXJzIHRvIGJlIGEgYnVnIGluIHRoZSBJb25pYyBjb2RlIGluIG9yZGVyIHRvIGNhcHR1cmUgZXZlcnl0aGluZyBpZGVudGljYWxseVxuICAgICAgICAgICBwYXJ0cy5wdXNoKHNlcmlhbGl6ZU9iamVjdChgJHtwYXJlbnRLZXl9W10ke2FycmF5W2ldfWAsIGVuY29kZSkpO1xuICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vc2lsa2ltZW4vY29yZG92YS1wbHVnaW4tYWR2YW5jZWQtaHR0cC9ibG9iL21hc3Rlci93d3cvdXJsLXV0aWwuanMjTDczXG4gICAgICAgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcGFydHMucHVzaChzZXJpYWxpemVPYmplY3QoXCJcIi5jb25jYXQocGFyZW50S2V5LCBcIltdXCIpLmNvbmNhdChlKSwgZW5jb2RlLCB1bmRlZmluZWQpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFwiXCIuY29uY2F0KHNlcmlhbGl6ZUlkZW50aWZpZXIocGFyZW50S2V5LCAnJywgZW5jb2RlKSwgXCI9XCIpLmNvbmNhdChzZXJpYWxpemVWYWx1ZShlLCBlbmNvZGUpKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJyYnKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChwYXJlbnRLZXksIG9iamVjdCwgZW5jb2RlKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpZGVudGlmaWVyID0gcGFyZW50S2V5Lmxlbmd0aCA/IFwiXCIuY29uY2F0KHBhcmVudEtleSwgXCJbXCIpLmNvbmNhdChrZXksIFwiXVwiKSA6IGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Rba2V5XSkpIHtcbiAgICAgIHBhcnRzLnB1c2goc2VyaWFsaXplQXJyYXkoaWRlbnRpZmllciwgb2JqZWN0W2tleV0sIGVuY29kZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgoMCwgX3R5cGVvZjIuZGVmYXVsdCkob2JqZWN0W2tleV0pID09PSAnb2JqZWN0JyAmJiBvYmplY3Rba2V5XSAhPT0gbnVsbCkge1xuICAgICAgcGFydHMucHVzaChzZXJpYWxpemVPYmplY3QoaWRlbnRpZmllciwgb2JqZWN0W2tleV0sIGVuY29kZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBhcnRzLnB1c2goXCJcIi5jb25jYXQoc2VyaWFsaXplSWRlbnRpZmllcihwYXJlbnRLZXksIGtleSwgZW5jb2RlKSwgXCI9XCIpLmNvbmNhdChzZXJpYWxpemVWYWx1ZShvYmplY3Rba2V5XSwgZW5jb2RlKSkpO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCcmJyk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVRdWVyeVBhcmFtcyhwYXJhbXMsIGVuY29kZSkge1xuICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KCcnLCBwYXJhbXMsIGVuY29kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRRdWVyeVBhcmFtc1N0cmluZyh1cmwsIHBhcmFtcykge1xuICBpZiAoIXVybC5sZW5ndGggfHwgIXBhcmFtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHZhciBfVVJMMiA9IG5ldyBVUkwodXJsKSxcbiAgICBob3N0ID0gX1VSTDIuaG9zdCxcbiAgICBwYXRobmFtZSA9IF9VUkwyLnBhdGhuYW1lLFxuICAgIHNlYXJjaCA9IF9VUkwyLnNlYXJjaCxcbiAgICBoYXNoID0gX1VSTDIuaGFzaCxcbiAgICBwcm90b2NvbCA9IF9VUkwyLnByb3RvY29sO1xuICByZXR1cm4gXCJcIi5jb25jYXQocHJvdG9jb2wsIFwiLy9cIikuY29uY2F0KGhvc3QpLmNvbmNhdChwYXRobmFtZSkuY29uY2F0KHNlYXJjaC5sZW5ndGggPyBcIlwiLmNvbmNhdChzZWFyY2gsIFwiJlwiKS5jb25jYXQocGFyYW1zKSA6IFwiP1wiLmNvbmNhdChwYXJhbXMpKS5jb25jYXQoaGFzaCk7XG59XG5mdW5jdGlvbiBnZXRBbGxvd2VkRGF0YVR5cGVzKGRhdGFTZXJpYWxpemVyKSB7XG4gIHJldHVybiBBTExPV0VEX0RBVEFfVFlQRVNbZGF0YVNlcmlhbGl6ZXJdIHx8IEFMTE9XRURfREFUQV9UWVBFUy5kZWZhdWx0O1xufVxuZnVuY3Rpb24gZ2V0QWxsb3dlZEluc3RhbmNlVHlwZXMoZGF0YVNlcmlhbGl6ZXIpIHtcbiAgcmV0dXJuIGRhdGFTZXJpYWxpemVyID09PSAnbXVsdGlwYXJ0JyA/IEZPUk1fREFUQSA6IEVNUFRZX1NFVDtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NEYXRhKGRhdGEsIGRhdGFTZXJpYWxpemVyKSB7XG4gIHZhciBjdXJyZW50RGF0YVR5cGUgPSAoMCwgX3R5cGVvZjIuZGVmYXVsdCkoZGF0YSk7XG4gIHZhciBhbGxvd2VkRGF0YVR5cGVzID0gZ2V0QWxsb3dlZERhdGFUeXBlcyhkYXRhU2VyaWFsaXplcik7XG4gIHZhciBhbGxvd2VkSW5zdGFuY2VUeXBlcyA9IGdldEFsbG93ZWRJbnN0YW5jZVR5cGVzKGRhdGFTZXJpYWxpemVyKTtcbiAgaWYgKGFsbG93ZWRJbnN0YW5jZVR5cGVzLnNpemUgPiAwKSB7XG4gICAgdmFyIGlzQ29ycmVjdEluc3RhbmNlVHlwZSA9IGZhbHNlO1xuICAgIGFsbG93ZWRJbnN0YW5jZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmdbdHlwZV0gJiYgZGF0YSBpbnN0YW5jZW9mIF9fd2VicGFja19yZXF1aXJlX18uZ1t0eXBlXSkge1xuICAgICAgICBpc0NvcnJlY3RJbnN0YW5jZVR5cGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaXNDb3JyZWN0SW5zdGFuY2VUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlNUQU5DRV9UWVBFX01JU01BVENIX0RBVEEgXCIuY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGFsbG93ZWRJbnN0YW5jZVR5cGVzKS5qb2luKCcsICcpKSk7XG4gICAgfVxuICB9XG4gIGlmIChhbGxvd2VkSW5zdGFuY2VUeXBlcy5zaXplID09PSAwICYmICFhbGxvd2VkRGF0YVR5cGVzLmhhcyhjdXJyZW50RGF0YVR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRV9NSVNNQVRDSF9EQVRBIFwiLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShhbGxvd2VkRGF0YVR5cGVzKS5qb2luKCcsICcpKSk7XG4gIH1cbiAgc3dpdGNoIChkYXRhU2VyaWFsaXplcikge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gYWxyZWFkeSBhIHN0cmluZ1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIG9iamVjdCBvZiBzb21lIHNvcnQgKHVybGVuY29kZWQgb3IganNvbilcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhLCB1bmRlZmluZWQsIDIpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVNaXNzaW5nT3B0aW9ucyhvcHRpb25zLCBpb25pY0h0dHApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VyaWFsaXplcjtcbiAgdmFyIGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gIHRyeSB7XG4gICAgLy8gbmVlZCB0byBjaGVjayBzcGVjaWFsIGNhc2UgaWYgZGF0YSB0eXBlIGlzIG5vdCBoYW5kbGVkIGJ5IExSIGJ1dCBvdGhlcndpc2UgdmFsaWRcbiAgICBzZXJpYWxpemVyID0gY2hlY2tGb3JWYWxpZFN0cmluZ1ZhbHVlKFZBTElEX1NFUklBTElaRVJTLCBvcHRpb25zLnNlcmlhbGl6ZXIgfHwgaW9uaWNIdHRwLmdldERhdGFTZXJpYWxpemVyKCksICdzZXJpYWxpemVyIC8gZGF0YSBwYXlsb2FkIHR5cGUnKTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgIC8vIGlmIHRoaXMgZmFpbHMgaXQncyBvZiBlbnRpcmVseSBpbnZhbGlkIHR5cGUsIGxldCBpdCBmYWlsXG4gICAgc2VyaWFsaXplciA9IGNoZWNrRm9yVmFsaWRTdHJpbmdWYWx1ZShVTlNVUFBPUlRFRF9TRVJJQUxJWkVSUywgb3B0aW9ucy5zZXJpYWxpemVyIHx8IGlvbmljSHR0cC5nZXREYXRhU2VyaWFsaXplcigpLCAnc2VyaWFsaXplciAvIGRhdGEgcGF5bG9hZCB0eXBlJyk7XG4gICAgLy8gaXMgb2YgYSB2YWxpZCBidXQgdW5zdXBwb3J0ZWQgdG8gTFIgdHlwZSwgc2V0IGRhdGEgdG8gZW1wdHlcbiAgICBkYXRhID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIGZpbGVQYXRoOiBvcHRpb25zLmZpbGVQYXRoLFxuICAgIGZvbGxvd1JlZGlyZWN0OiBvcHRpb25zLmZvbGxvd1JlZGlyZWN0LFxuICAgIGhlYWRlcnM6IGNoZWNrS2V5VmFsdWVQYWlyT2JqZWN0KG9wdGlvbnMuaGVhZGVycyB8fCB7fSwgU1RSSU5HX1NFVCwgJ0ludmFsaWQgaGVhZGVyIHR5cGUsIG11c3QgYmUgc3RyaW5nJyksXG4gICAgbWV0aG9kOiBjaGVja0ZvclZhbGlkU3RyaW5nVmFsdWUoVkFMSURfSFRUUF9NRVRIT0RTLCBvcHRpb25zLm1ldGhvZCB8fCBWQUxJRF9IVFRQX01FVEhPRFNbMF0sICdtZXRob2QnKSxcbiAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgcGFyYW1zOiBjaGVja0tleVZhbHVlUGFpck9iamVjdChvcHRpb25zLnBhcmFtcyB8fCB7fSwgU1RSSU5HX0FSUkFZX1NFVCwgJ0ludmFsaWQgcGFyYW0sIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXknKSxcbiAgICByZXNwb25zZVR5cGU6IG9wdGlvbnMucmVzcG9uc2VUeXBlLFxuICAgIHNlcmlhbGl6ZXI6IHNlcmlhbGl6ZXIsXG4gICAgY29ubmVjdFRpbWVvdXQ6IG9wdGlvbnMuY29ubmVjdFRpbWVvdXQsXG4gICAgcmVhZFRpbWVvdXQ6IG9wdGlvbnMucmVhZFRpbWVvdXQsXG4gICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0XG4gIH07XG59XG52YXIgaW9uaWNJZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gcmVnaXN0ZXJJb25pYyhfcmVmKSB7XG4gIHZhciBfY29yZG92YSwgX2NvcmRvdmEkcGx1Z2luLCBfd2luZG93JGlvbmljO1xuICB2YXIgYWRkUmVxdWVzdCA9IF9yZWYuYWRkUmVxdWVzdCxcbiAgICBhZGRSZXNwb25zZSA9IF9yZWYuYWRkUmVzcG9uc2UsXG4gICAgaXNJZ25vcmVkID0gX3JlZi5pc0lnbm9yZWQ7XG4gIHZhciBpb25pY0h0dHAgPSAoX2NvcmRvdmEgPSB3aW5kb3cuY29yZG92YSkgPT09IG51bGwgfHwgX2NvcmRvdmEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfY29yZG92YSRwbHVnaW4gPSBfY29yZG92YS5wbHVnaW4pID09PSBudWxsIHx8IF9jb3Jkb3ZhJHBsdWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvcmRvdmEkcGx1Z2luLmh0dHA7XG4gIHZhciBpb25pY01hcCA9IHt9O1xuICB2YXIgdW5zdWJzY3JpYmVkRnJvbUlvbmljID0gZmFsc2U7XG4gIGlmICh0eXBlb2YgaW9uaWNIdHRwID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFBsdWdpbiBkb2VzIG5vdCBleGlzdCEgRW1wdHkgdW5pbnN0YWxsIGhvb2suXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICB9XG4gIHZhciBwbGF0Zm9ybXMgPSAoX3dpbmRvdyRpb25pYyA9IHdpbmRvdy5pb25pYykgPT09IG51bGwgfHwgX3dpbmRvdyRpb25pYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdyRpb25pYy5wbGF0Zm9ybXM7XG4gIGlmICh0eXBlb2YgcGxhdGZvcm1zICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGxhdGZvcm1zLnNvbWUgPT09ICdmdW5jdGlvbicgJiYgcGxhdGZvcm1zLnNvbWUoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gVU5TVVBQT1JURURfUExBVEZPUk1TLmhhcyhlKTtcbiAgfSkpIHtcbiAgICAvLyBXZSBhcHBlYXIgdG8gYmUgcnVubmluZyBpbiBhIHdlYiBicm93c2VyLCBkbyBub3QgaG9vayBhbmQgbGV0IFhIUiB3cmFwIGluc3RlYWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICB9XG4gIHZhciBvcmlnaW5hbFNlbmRSZXF1ZXN0ID0gaW9uaWNIdHRwLnNlbmRSZXF1ZXN0O1xuICB2YXIgaGFuZGxlUmVzcG9uc2UgPSAoMCwgX3Byb3RlY3RGdW5jLmRlZmF1bHQpKGZ1bmN0aW9uIChyZXNwb25zZSwgaXNTdWNjZXNzLCBpb25pY1JlcUlkKSB7XG4gICAgaWYgKCFpc0lnbm9yZWQoXCJcIi5jb25jYXQoTE9HUk9DS0VUX0lPTklDX0xBQkVMKS5jb25jYXQoaW9uaWNSZXFJZCkpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzcG9uc2VIYXNoID0ge1xuICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsIHx8ICcnLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIDwgNjAwICYmIHJlc3BvbnNlLnN0YXR1cyA+PSAxMDAgPyByZXNwb25zZS5zdGF0dXMgOiAwLFxuICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMgfHwge30sXG4gICAgICAgICAgYm9keTogaXNTdWNjZXNzID8gcmVzcG9uc2UuZGF0YSA6IHJlc3BvbnNlLmVycm9yLFxuICAgICAgICAgIG1ldGhvZDogaW9uaWNNYXBbaW9uaWNSZXFJZF0udG9VcHBlckNhc2UoKVxuICAgICAgICB9O1xuICAgICAgICBhZGRSZXNwb25zZShcIlwiLmNvbmNhdChMT0dST0NLRVRfSU9OSUNfTEFCRUwpLmNvbmNhdChpb25pY1JlcUlkKSwgcmVzcG9uc2VIYXNoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB2YXIgX3Jlc3BvbnNlSGFzaCA9IHtcbiAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCB8fCAnJyxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyA8IDYwMCAmJiByZXNwb25zZS5zdGF0dXMgPj0gMTAwID8gcmVzcG9uc2Uuc3RhdHVzIDogMCxcbiAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzIHx8IHt9LFxuICAgICAgICAgIGJvZHk6IFwiTG9nUm9ja2V0IGZldGNoIGVycm9yOiBcIi5jb25jYXQoZXJyLm1lc3NhZ2UpLFxuICAgICAgICAgIG1ldGhvZDogaW9uaWNNYXBbaW9uaWNSZXFJZF0udG9VcHBlckNhc2UoKVxuICAgICAgICB9O1xuICAgICAgICBhZGRSZXNwb25zZShcIlwiLmNvbmNhdChMT0dST0NLRVRfSU9OSUNfTEFCRUwpLmNvbmNhdChpb25pY1JlcUlkKSwgX3Jlc3BvbnNlSGFzaCk7XG4gICAgICB9XG4gICAgfSAvLyBPdGhlcndpc2UsIGRvbid0IGV2ZW4gdHJ5IHRvIHJlYWQgaWdub3JlZCAvIHVuc3Vic2NyaWJlZCByZXF1ZXN0c1xuICB9KTtcblxuICBpb25pY0h0dHAuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgdmFyIGN1cnJlbnRJZCA9ICsraW9uaWNJZENvdW50ZXI7XG4gICAgdmFyIG91clN1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gb3VyU3VjY2Vzc0hhbmRsZXIocmVzcG9uc2UpIHtcbiAgICAgIGlmICghdW5zdWJzY3JpYmVkRnJvbUlvbmljKSB7XG4gICAgICAgIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCB0cnVlLCBjdXJyZW50SWQpO1xuICAgICAgICBkZWxldGUgaW9uaWNNYXBbY3VycmVudElkXTtcbiAgICAgIH1cbiAgICAgIHN1Y2Nlc3MocmVzcG9uc2UpO1xuICAgIH07XG4gICAgdmFyIG91ckZhaWx1cmVIYW5kbGVyID0gZnVuY3Rpb24gb3VyRmFpbHVyZUhhbmRsZXIocmVzcG9uc2UpIHtcbiAgICAgIGlmICghdW5zdWJzY3JpYmVkRnJvbUlvbmljKSB7XG4gICAgICAgIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCBmYWxzZSwgY3VycmVudElkKTtcbiAgICAgICAgZGVsZXRlIGlvbmljTWFwW2N1cnJlbnRJZF07XG4gICAgICB9XG4gICAgICBmYWlsdXJlKHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIGlmICghdW5zdWJzY3JpYmVkRnJvbUlvbmljKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB3aWxsIHRocm93IGp1c3QgbGlrZSBpZGVudGljYWwgaW9uaWMgY29kZSBpZiBpbnB1dCBpcyBpbnZhbGlkXG4gICAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSBoYW5kbGVNaXNzaW5nT3B0aW9ucyhvcHRpb25zLCBpb25pY0h0dHApO1xuICAgICAgICB2YXIgbW9kaWZpZWRVcmwgPSBhcHBlbmRRdWVyeVBhcmFtc1N0cmluZyh1cmwsIHNlcmlhbGl6ZU9iamVjdCgnJywgbW9kaWZpZWRPcHRpb25zLnBhcmFtcywgdHJ1ZSkpO1xuICAgICAgICAvLyBuZWVkIHRvIG1pbmljIGJlaGF2aW9yIG9mIElvbmljIEFQSSBieSBhZGRpbmcgZ2xvYmFsIGhlYWRlcnNcbiAgICAgICAgdmFyIG1lcmdlZEhlYWRlcnMgPSBnZXRNZXJnZWRIZWFkZXJzKHVybCwgbW9kaWZpZWRPcHRpb25zLmhlYWRlcnMsIGlvbmljSHR0cCk7XG5cbiAgICAgICAgLy8gaW9uaWMgQVBJcyBkZWZhdWx0IHRvIGdldCBtZXRob2RcbiAgICAgICAgdmFyIG1ldGhvZCA9IG1vZGlmaWVkT3B0aW9ucy5tZXRob2QgfHwgJ2dldCc7XG4gICAgICAgIGlvbmljTWFwW2N1cnJlbnRJZF0gPSBtZXRob2Q7XG4gICAgICAgIHZhciByZXF1ZXN0SGFzaCA9IHtcbiAgICAgICAgICB1cmw6IG1vZGlmaWVkVXJsLFxuICAgICAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgaGVhZGVyczogbWVyZ2VkSGVhZGVycyB8fCB7fSxcbiAgICAgICAgICAvLyBvbmx5IGFwcGxpY2FibGUgb24gcG9zdCwgcHV0IG9yIHBhdGNoIG1ldGhvZHNcbiAgICAgICAgICBib2R5OiBwcm9jZXNzRGF0YShtb2RpZmllZE9wdGlvbnMuZGF0YSB8fCB7fSwgbW9kaWZpZWRPcHRpb25zLnNlcmlhbGl6ZXIpXG4gICAgICAgIH07XG4gICAgICAgIGFkZFJlcXVlc3QoXCJcIi5jb25jYXQoTE9HUk9DS0VUX0lPTklDX0xBQkVMKS5jb25jYXQoY3VycmVudElkKSwgcmVxdWVzdEhhc2gpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHZhciBfcmVxdWVzdEhhc2ggPSB7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgbWV0aG9kOiAob3B0aW9ucy5tZXRob2QgfHwgJ2dldCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgYm9keTogXCJMb2dSb2NrZXQgZmV0Y2ggZXJyb3I6IFwiLmNvbmNhdChlcnIubWVzc2FnZSlcbiAgICAgICAgfTtcbiAgICAgICAgYWRkUmVxdWVzdChcIlwiLmNvbmNhdChMT0dST0NLRVRfSU9OSUNfTEFCRUwpLmNvbmNhdChjdXJyZW50SWQpLCBfcmVxdWVzdEhhc2gpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luYWxTZW5kUmVxdWVzdCh1cmwsIG9wdGlvbnMsIG91clN1Y2Nlc3NIYW5kbGVyLCBvdXJGYWlsdXJlSGFuZGxlcik7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdW5zdWJzY3JpYmVkRnJvbUlvbmljID0gdHJ1ZTtcbiAgICBpb25pY0h0dHAuc2VuZFJlcXVlc3QgPSBvcmlnaW5hbFNlbmRSZXF1ZXN0O1xuICAgIGlvbmljTWFwID0ge307XG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9uZXR3b3JrL3NyYy9yZWdpc3Rlck5ldHdvcmtJbmZvcm1hdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L25ldHdvcmsvc3JjL3JlZ2lzdGVyTmV0d29ya0luZm9ybWF0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHJlZ2lzdGVyTmV0d29ya0luZm9ybWF0aW9uO1xudmFyIEVGRkVDVElWRV9UWVBFX1ZBTFMgPSB7XG4gICdzbG93LTJnJzogJ1NMT1cyRycsXG4gICcyZyc6ICdUV09HJyxcbiAgJzNnJzogJ1RIUkVFRycsXG4gICc0Zyc6ICdGT1VSRydcbn07XG5mdW5jdGlvbiByZWdpc3Rlck5ldHdvcmtJbmZvcm1hdGlvbihsb2dnZXIpIHtcbiAgdmFyIGxhc3RTdGF0dXMgPSB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHNlbmROZXR3b3JrSW5mb3JtYXRpb24oKSB7XG4gICAgdmFyIG5ld1N0YXR1cyA9IHtcbiAgICAgIG9ubGluZTogd2luZG93Lm5hdmlnYXRvci5vbkxpbmUsXG4gICAgICBlZmZlY3RpdmVUeXBlOiAnVU5LT1dOJ1xuICAgIH07XG4gICAgaWYgKCF3aW5kb3cubmF2aWdhdG9yLm9uTGluZSkge1xuICAgICAgbmV3U3RhdHVzLmVmZmVjdGl2ZVR5cGUgPSAnTk9ORSc7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cubmF2aWdhdG9yLmNvbm5lY3Rpb24gJiYgd2luZG93Lm5hdmlnYXRvci5jb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpIHtcbiAgICAgIG5ld1N0YXR1cy5lZmZlY3RpdmVUeXBlID0gRUZGRUNUSVZFX1RZUEVfVkFMU1t3aW5kb3cubmF2aWdhdG9yLmNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZV0gfHwgJ1VOS05PV04nO1xuICAgIH1cbiAgICBpZiAobGFzdFN0YXR1cyAmJiBuZXdTdGF0dXMub25saW5lID09PSBsYXN0U3RhdHVzLm9ubGluZSAmJiBuZXdTdGF0dXMuZWZmZWN0aXZlVHlwZSA9PT0gbGFzdFN0YXR1cy5lZmZlY3RpdmVUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RTdGF0dXMgPSBuZXdTdGF0dXM7XG4gICAgbG9nZ2VyLmFkZEV2ZW50KCdsci5uZXR3b3JrLk5ldHdvcmtTdGF0dXNFdmVudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRpc0VuYWJsZWQgPSBfcmVmLmlzRW5hYmxlZCxcbiAgICAgICAgaXNFbmFibGVkID0gX3JlZiRpc0VuYWJsZWQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJGlzRW5hYmxlZDtcbiAgICAgIGlmICghaXNFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1N0YXR1cztcbiAgICB9KTtcbiAgfVxuICBzZXRUaW1lb3V0KHNlbmROZXR3b3JrSW5mb3JtYXRpb24pO1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5jb25uZWN0aW9uICYmIHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yLmNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3IuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBzZW5kTmV0d29ya0luZm9ybWF0aW9uKTtcbiAgfVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgc2VuZE5ldHdvcmtJbmZvcm1hdGlvbik7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgc2VuZE5ldHdvcmtJbmZvcm1hdGlvbik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBzZW5kTmV0d29ya0luZm9ybWF0aW9uKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgc2VuZE5ldHdvcmtJbmZvcm1hdGlvbik7XG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IuY29ubmVjdGlvbiAmJiB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvci5jb25uZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3IuY29ubmVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBzZW5kTmV0d29ya0luZm9ybWF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9uZXR3b3JrL3NyYy9yZWdpc3RlclhIUi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L25ldHdvcmsvc3JjL3JlZ2lzdGVyWEhSLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLnNldEFjdGl2ZSA9IHNldEFjdGl2ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcmVnaXN0ZXJYSFI7XG52YXIgX21hcFZhbHVlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGxvZ3JvY2tldC91dGlscy9zcmMvbWFwVmFsdWVzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9tYXBWYWx1ZXMuanNcIikpO1xudmFyIF9lbmhhbmNlRnVuYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGxvZ3JvY2tldC91dGlscy9zcmMvZW5oYW5jZUZ1bmMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2VuaGFuY2VGdW5jLmpzXCIpKTtcbnZhciBfc3RhcnRzV2l0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGxvZ3JvY2tldC91dGlscy9zcmMvc3RhcnRzV2l0aCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc3RhcnRzV2l0aC5qc1wiKSk7XG52YXIgX25wcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9ucHMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9ucHMuanNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWltcG9ydHNcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5cbnZhciBpc0FjdGl2ZSA9IHRydWU7XG5mdW5jdGlvbiBzZXRBY3RpdmUoc2hvdWxkQmVBY3RpdmUpIHtcbiAgaXNBY3RpdmUgPSBzaG91bGRCZUFjdGl2ZTtcbn1cbnZhciBjdXJyZW50WEhSSWQgPSAwO1xuZnVuY3Rpb24gcmVnaXN0ZXJYSFIoX3JlZikge1xuICB2YXIgYWRkUmVxdWVzdCA9IF9yZWYuYWRkUmVxdWVzdCxcbiAgICBhZGRSZXNwb25zZSA9IF9yZWYuYWRkUmVzcG9uc2UsXG4gICAgaXNJZ25vcmVkID0gX3JlZi5pc0lnbm9yZWQsXG4gICAgbG9nZ2VyID0gX3JlZi5sb2dnZXIsXG4gICAgX3JlZiRzaG91bGRBdWdtZW50TlBTID0gX3JlZi5zaG91bGRBdWdtZW50TlBTLFxuICAgIHNob3VsZEF1Z21lbnROUFMgPSBfcmVmJHNob3VsZEF1Z21lbnROUFMgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHNob3VsZEF1Z21lbnROUFMsXG4gICAgX3JlZiRzaG91bGRQYXJzZVhIUkJsID0gX3JlZi5zaG91bGRQYXJzZVhIUkJsb2IsXG4gICAgc2hvdWxkUGFyc2VYSFJCbG9iID0gX3JlZiRzaG91bGRQYXJzZVhIUkJsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkc2hvdWxkUGFyc2VYSFJCbDtcbiAgdmFyIF9YSFIgPSBYTUxIdHRwUmVxdWVzdDtcbiAgdmFyIHhock1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciB1bnN1YnNjcmliZWRGcm9tWGhyID0gZmFsc2U7XG4gIHZhciBMT0dST0NLRVRfWEhSX0xBQkVMID0gJ3hoci0nO1xuICB3aW5kb3cuX2xyWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmF0aXZlLXJlYXNzaWduXG4gIFhNTEh0dHBSZXF1ZXN0ID0gZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3QobW96QW5vbiwgbW96U3lzdGVtKSB7XG4gICAgdmFyIHhock9iamVjdCA9IG5ldyBfWEhSKG1vekFub24sIG1velN5c3RlbSk7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIHhock9iamVjdDtcbiAgICB9XG4gICAgeGhyTWFwLnNldCh4aHJPYmplY3QsIHtcbiAgICAgIHhocklkOiArK2N1cnJlbnRYSFJJZCxcbiAgICAgIGhlYWRlcnM6IHt9XG4gICAgfSk7XG4gICAgdmFyIG9wZW5PcmlnaW5hbCA9IHhock9iamVjdC5vcGVuO1xuICAgIGZ1bmN0aW9uIG9wZW5TaGltKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXJsID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKHdpbmRvdy5VUkwgJiYgdHlwZW9mIHdpbmRvdy5VUkwgPT09ICdmdW5jdGlvbicgJiYgdXJsLnNlYXJjaChfbnBzLldPT1RSSUNfUkVTUE9OU0VTX1JFR0VYKSA9PT0gMCkge1xuICAgICAgICAgIHZhciBsb2dyb2NrZXRTZXNzaW9uVVJMID0gbmV3IHdpbmRvdy5VUkwobG9nZ2VyLnJlY29yZGluZ1VSTCk7XG4gICAgICAgICAgbG9ncm9ja2V0U2Vzc2lvblVSTC5zZWFyY2hQYXJhbXMuc2V0KCducHMnLCAnd29vdHJpYycpO1xuICAgICAgICAgIHZhciB1cmxPYmogPSBuZXcgd2luZG93LlVSTCh1cmwpO1xuICAgICAgICAgIHZhciByZXNwb25zZVRleHQgPSB1cmxPYmouc2VhcmNoUGFyYW1zLmdldCgncmVzcG9uc2VbdGV4dF0nKTtcbiAgICAgICAgICB2YXIgZmVlZGJhY2sgPSByZXNwb25zZVRleHQgPyBcIlwiLmNvbmNhdChyZXNwb25zZVRleHQsIFwiXFxuXFxuXCIpIDogJyc7XG4gICAgICAgICAgdXJsT2JqLnNlYXJjaFBhcmFtcy5zZXQoJ3Jlc3BvbnNlW3RleHRdJywgXCJcIi5jb25jYXQoZmVlZGJhY2ssIFwiPFwiKS5jb25jYXQobG9ncm9ja2V0U2Vzc2lvblVSTC5ocmVmLCBcInxWaWV3IExvZ1JvY2tldCBzZXNzaW9uPlwiKSk7XG4gICAgICAgICAgYXJnc1sxXSA9IHVybE9iai5ocmVmOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHsvKiBkbyBub3RoaW5nICovfVxuICAgICAgcmV0dXJuIG9wZW5PcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIHNlbmRPcmlnaW5hbCA9IHhock9iamVjdC5zZW5kO1xuICAgIGZ1bmN0aW9uIHNlbmRTaGltKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjdXJyZW50WEhSID0geGhyTWFwLmdldCh4aHJPYmplY3QpO1xuICAgICAgICBpZiAod2luZG93LlVSTCAmJiB0eXBlb2Ygd2luZG93LlVSTCA9PT0gJ2Z1bmN0aW9uJyAmJiBjdXJyZW50WEhSICYmIGN1cnJlbnRYSFIudXJsICYmIGN1cnJlbnRYSFIudXJsLnNlYXJjaChfbnBzLkRFTElHSFRFRF9SRVNQT05TRVNfUkVHRVgpID09PSAwICYmIGFyZ3MubGVuZ3RoICYmIGFyZ3NbMF0uaW5kZXhPZihfbnBzLkRFTElHSFRFRF9GRUVEQkFDS19QUkVGSVgpICE9PSAtMSkge1xuICAgICAgICAgIHZhciByZWNvcmRpbmdVUkwgPSBuZXcgd2luZG93LlVSTChsb2dnZXIucmVjb3JkaW5nVVJMKTtcbiAgICAgICAgICByZWNvcmRpbmdVUkwuc2VhcmNoUGFyYW1zLnNldCgnbnBzJywgJ2RlbGlnaHRlZCcpO1xuICAgICAgICAgIHZhciBsb2dyb2NrZXRTZXNzaW9uVVJMID0gZW5jb2RlVVJJQ29tcG9uZW50KHJlY29yZGluZ1VSTC5ocmVmKTtcbiAgICAgICAgICB2YXIgZGF0YSA9IGFyZ3NbMF0uc3BsaXQoJyYnKS5tYXAoZnVuY3Rpb24gKGRhdGFTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX3N0YXJ0c1dpdGguZGVmYXVsdCkoZGF0YVN0cmluZywgX25wcy5ERUxJR0hURURfRkVFREJBQ0tfUFJFRklYKSkge1xuICAgICAgICAgICAgICB2YXIgaXNFbXB0eSA9IGRhdGFTdHJpbmcgPT09IF9ucHMuREVMSUdIVEVEX0ZFRURCQUNLX1BSRUZJWDtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGRhdGFTdHJpbmcpLmNvbmNhdChpc0VtcHR5ID8gJycgOiAnXFxuXFxuJywgXCI8XCIpLmNvbmNhdChsb2dyb2NrZXRTZXNzaW9uVVJMLCBcInxWaWV3IExvZ1JvY2tldCBzZXNzaW9uPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhU3RyaW5nO1xuICAgICAgICAgIH0pLmpvaW4oJyYnKTtcbiAgICAgICAgICBhcmdzWzBdID0gZGF0YTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7LyogZG8gbm90aGluZyAqL31cbiAgICAgIHJldHVybiBzZW5kT3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGlmIChzaG91bGRBdWdtZW50TlBTKSB7XG4gICAgICB4aHJPYmplY3Qub3BlbiA9IG9wZW5TaGltO1xuICAgICAgeGhyT2JqZWN0LnNlbmQgPSBzZW5kU2hpbTtcbiAgICB9XG5cbiAgICAvLyAuLi4sICdvcGVuJywgKG1ldGhvZCwgdXJsLCBhc3luYywgdXNlcm5hbWUsIHBhc3N3b3JkKSA9PiB7XG4gICAgKDAsIF9lbmhhbmNlRnVuYy5kZWZhdWx0KSh4aHJPYmplY3QsICdvcGVuJywgZnVuY3Rpb24gKG1ldGhvZCwgdXJsKSB7XG4gICAgICBpZiAodW5zdWJzY3JpYmVkRnJvbVhocikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFhIUiA9IHhock1hcC5nZXQoeGhyT2JqZWN0KTtcbiAgICAgIGN1cnJlbnRYSFIubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY3VycmVudFhIUi51cmwgPSB1cmw7XG4gICAgfSk7XG4gICAgKDAsIF9lbmhhbmNlRnVuYy5kZWZhdWx0KSh4aHJPYmplY3QsICdzZW5kJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmICh1bnN1YnNjcmliZWRGcm9tWGhyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50WEhSID0geGhyTWFwLmdldCh4aHJPYmplY3QpO1xuICAgICAgaWYgKCFjdXJyZW50WEhSKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICB1cmw6IGN1cnJlbnRYSFIudXJsLFxuICAgICAgICBtZXRob2Q6IGN1cnJlbnRYSFIubWV0aG9kICYmIGN1cnJlbnRYSFIubWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIGhlYWRlcnM6ICgwLCBfbWFwVmFsdWVzLmRlZmF1bHQpKGN1cnJlbnRYSFIuaGVhZGVycyB8fCB7fSwgZnVuY3Rpb24gKGhlYWRlclZhbHVlcykge1xuICAgICAgICAgIHJldHVybiBoZWFkZXJWYWx1ZXMuam9pbignLCAnKTtcbiAgICAgICAgfSksXG4gICAgICAgIGJvZHk6IGRhdGFcbiAgICAgIH07XG4gICAgICBhZGRSZXF1ZXN0KFwiXCIuY29uY2F0KExPR1JPQ0tFVF9YSFJfTEFCRUwpLmNvbmNhdChjdXJyZW50WEhSLnhocklkKSwgcmVxdWVzdCk7XG4gICAgfSk7XG4gICAgKDAsIF9lbmhhbmNlRnVuYy5kZWZhdWx0KSh4aHJPYmplY3QsICdzZXRSZXF1ZXN0SGVhZGVyJywgZnVuY3Rpb24gKGhlYWRlciwgdmFsdWUpIHtcbiAgICAgIGlmICh1bnN1YnNjcmliZWRGcm9tWGhyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50WEhSID0geGhyTWFwLmdldCh4aHJPYmplY3QpO1xuICAgICAgaWYgKCFjdXJyZW50WEhSKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRYSFIuaGVhZGVycyA9IGN1cnJlbnRYSFIuaGVhZGVycyB8fCB7fTtcbiAgICAgIGN1cnJlbnRYSFIuaGVhZGVyc1toZWFkZXJdID0gY3VycmVudFhIUi5oZWFkZXJzW2hlYWRlcl0gfHwgW107XG4gICAgICBjdXJyZW50WEhSLmhlYWRlcnNbaGVhZGVyXS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICB2YXIgeGhyTGlzdGVuZXJzID0ge1xuICAgICAgcmVhZHlzdGF0ZWNoYW5nZTogZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlZEZyb21YaHIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhock9iamVjdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRYSFIgPSB4aHJNYXAuZ2V0KHhock9iamVjdCk7XG4gICAgICAgICAgaWYgKCFjdXJyZW50WEhSKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRG8gbm90IHJlYWQgaWdub3JlZCByZXF1ZXN0cyBhdCBhbGwuXG4gICAgICAgICAgaWYgKGlzSWdub3JlZChcIlwiLmNvbmNhdChMT0dST0NLRVRfWEhSX0xBQkVMKS5jb25jYXQoY3VycmVudFhIUi54aHJJZCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoZWFkZXJTdHJpbmcgPSB4aHJPYmplY3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJyc7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSBoZWFkZXJTdHJpbmcuc3BsaXQoL1tcXHJcXG5dKy8pLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcHJldmlvdXM7XG4gICAgICAgICAgICB2YXIgaGVhZGVyUGFydHMgPSBjdXJyZW50LnNwbGl0KCc6ICcpO1xuICAgICAgICAgICAgaWYgKGhlYWRlclBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGhlYWRlclBhcnRzLnNoaWZ0KCk7IC8vIGZpcnN0IGluZGV4IG9mIHRoZSBhcnJheVxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXJQYXJ0cy5qb2luKCc6ICcpOyAvLyByZXN0IG9mIHRoZSBhcnJheSByZXBhaXJlZFxuICAgICAgICAgICAgICBpZiAocHJldmlvdXNba2V5XSkge1xuICAgICAgICAgICAgICAgIG5leHRba2V5XSArPSBcIiwgXCIuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfSwge30pO1xuICAgICAgICAgIHZhciBib2R5O1xuXG4gICAgICAgICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIHRyeWluZyB0byBhY2Nlc3MgbGFyZ2UgcmVzcG9uc2VzXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN3aXRjaCAoeGhyT2JqZWN0LnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBib2R5ID0gbG9nZ2VyLl9zaG91bGRDbG9uZVJlc3BvbnNlID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh4aHJPYmplY3QucmVzcG9uc2UpKSA6IHhock9iamVjdC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBib2R5ID0geGhyT2JqZWN0LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYm9keSA9IHhock9iamVjdC5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYm9keSA9IHhock9iamVjdC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGJvZHkgPSAnTG9nUm9ja2V0OiBFcnJvciBhY2Nlc3NpbmcgcmVzcG9uc2UuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdXJsOiBjdXJyZW50WEhSLnVybCxcbiAgICAgICAgICAgIHN0YXR1czogeGhyT2JqZWN0LnN0YXR1cyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgbWV0aG9kOiAoY3VycmVudFhIUi5tZXRob2QgfHwgJycpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChzaG91bGRQYXJzZVhIUkJsb2IgJiYgcmVzcG9uc2UuYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgIHZhciBibG9iUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIGJsb2JSZWFkZXIucmVhZEFzVGV4dChyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgIGJsb2JSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBKU09OLnBhcnNlKGJsb2JSZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICAgICAgICBhZGRSZXNwb25zZShcIlwiLmNvbmNhdChMT0dST0NLRVRfWEhSX0xBQkVMKS5jb25jYXQoY3VycmVudFhIUi54aHJJZCksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZFJlc3BvbnNlKFwiXCIuY29uY2F0KExPR1JPQ0tFVF9YSFJfTEFCRUwpLmNvbmNhdChjdXJyZW50WEhSLnhocklkKSwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gLy8gVW51c2VkIEV2ZW50IExpc3RlbmVyc1xuICAgICAgLy8gbG9hZHN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgIC8vIHByb2dyZXNzOiAoKSA9PiB7fSxcbiAgICAgIC8vIGFib3J0OiAoKSA9PiB7fSxcbiAgICAgIC8vIGVycm9yOiAoKSA9PiB7fSxcbiAgICAgIC8vIGxvYWQ6ICgpID0+IHt9LFxuICAgICAgLy8gdGltZW91dDogKCkgPT4ge30sXG4gICAgICAvLyBsb2FkZW5kOiAoKSA9PiB7fSxcbiAgICB9O1xuXG4gICAgT2JqZWN0LmtleXMoeGhyTGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHhock9iamVjdC5hZGRFdmVudExpc3RlbmVyKGtleSwgeGhyTGlzdGVuZXJzW2tleV0pO1xuICAgIH0pO1xuICAgIHJldHVybiB4aHJPYmplY3Q7XG4gIH07XG5cbiAgLy8gdGhpcyBhbGxvd3MgXCJpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0XCIgdG8gd29ya1xuICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUgPSBfWEhSLnByb3RvdHlwZTtcblxuICAvLyBQZXJzaXN0IHRoZSBzdGF0aWMgdmFyaWFibGVzLlxuICBbJ1VOU0VOVCcsICdPUEVORUQnLCAnSEVBREVSU19SRUNFSVZFRCcsICdMT0FESU5HJywgJ0RPTkUnXS5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgIFhNTEh0dHBSZXF1ZXN0W3ZhcmlhYmxlXSA9IF9YSFJbdmFyaWFibGVdO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB1bnN1YnNjcmliZWRGcm9tWGhyID0gdHJ1ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmF0aXZlLXJlYXNzaWduXG4gICAgWE1MSHR0cFJlcXVlc3QgPSBfWEhSO1xuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvbm93L3NyYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvbm93L3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIGNvbXBhdC9jb21wYXQgKi9cbnZhciBkYXRlTm93ID0gRGF0ZS5ub3cuYmluZChEYXRlKTtcbnZhciBsb2FkVGltZSA9IGRhdGVOb3coKTtcbnZhciBfZGVmYXVsdCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2Uubm93LmJpbmQocGVyZm9ybWFuY2UpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGF0ZU5vdygpIC0gbG9hZFRpbWU7XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3JlZHV4L3NyYy9jcmVhdGVFbmhhbmNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC9yZWR1eC9zcmMvY3JlYXRlRW5oYW5jZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNyZWF0ZUVuaGFuY2VyO1xudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXCIpKTtcbnZhciBfbm93ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAbG9ncm9ja2V0L25vdyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9ub3cvc3JjL2luZGV4LmpzXCIpKTtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgc3RvcmVJZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gY3JlYXRlRW5oYW5jZXIobG9nZ2VyKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICBfcmVmJHN0YXRlU2FuaXRpemVyID0gX3JlZi5zdGF0ZVNhbml0aXplcixcbiAgICBzdGF0ZVNhbml0aXplciA9IF9yZWYkc3RhdGVTYW5pdGl6ZXIgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gZjtcbiAgICB9IDogX3JlZiRzdGF0ZVNhbml0aXplcixcbiAgICBfcmVmJGFjdGlvblNhbml0aXplciA9IF9yZWYuYWN0aW9uU2FuaXRpemVyLFxuICAgIGFjdGlvblNhbml0aXplciA9IF9yZWYkYWN0aW9uU2FuaXRpemVyID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSA6IF9yZWYkYWN0aW9uU2FuaXRpemVyO1xuICAvLyBhbiBlbmhhbmNlciBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFN0b3JlXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIG9yaWdpbmFsRGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBzdG9yZUlkID0gc3RvcmVJZENvdW50ZXIrKztcbiAgICAgIGxvZ2dlci5hZGRFdmVudCgnbHIucmVkdXguSW5pdGlhbFN0YXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FuaXRpemVkU3RhdGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gb25seSB0cnkgY2F0Y2ggdXNlciBkZWZpbmVkIGZ1bmN0aW9uc1xuICAgICAgICAgIHNhbml0aXplZFN0YXRlID0gc3RhdGVTYW5pdGl6ZXIoc3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IHNhbml0aXplZFN0YXRlLFxuICAgICAgICAgIHN0b3JlSWQ6IHN0b3JlSWRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgIHZhciBzdGFydCA9ICgwLCBfbm93LmRlZmF1bHQpKCk7XG4gICAgICAgIHZhciBlcnI7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gb3JpZ2luYWxEaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSAoMCwgX25vdy5kZWZhdWx0KSgpIC0gc3RhcnQ7XG4gICAgICAgICAgbG9nZ2VyLmFkZEV2ZW50KCdsci5yZWR1eC5SZWR1eEFjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkQWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIG9ubHkgdHJ5IGNhdGNoIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgc2FuaXRpemVkU3RhdGUgPSBzdGF0ZVNhbml0aXplcihzdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgICAgc2FuaXRpemVkQWN0aW9uID0gYWN0aW9uU2FuaXRpemVyKGFjdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2FuaXRpemVkU3RhdGUgJiYgc2FuaXRpemVkQWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RvcmVJZDogc3RvcmVJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHNhbml0aXplZEFjdGlvbixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGVEZWx0YTogc2FuaXRpemVkU3RhdGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3JlZHV4L3NyYy9jcmVhdGVNaWRkbGV3YXJlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvcmVkdXgvc3JjL2NyZWF0ZU1pZGRsZXdhcmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY3JlYXRlTWlkZGxld2FyZTtcbnZhciBfbm93ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAbG9ncm9ja2V0L25vdyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9ub3cvc3JjL2luZGV4LmpzXCIpKTtcbnZhciBzdG9yZUlkQ291bnRlciA9IDA7XG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlKGxvZ2dlcikge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgX3JlZiRzdGF0ZVNhbml0aXplciA9IF9yZWYuc3RhdGVTYW5pdGl6ZXIsXG4gICAgc3RhdGVTYW5pdGl6ZXIgPSBfcmVmJHN0YXRlU2FuaXRpemVyID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSA6IF9yZWYkc3RhdGVTYW5pdGl6ZXIsXG4gICAgX3JlZiRhY3Rpb25TYW5pdGl6ZXIgPSBfcmVmLmFjdGlvblNhbml0aXplcixcbiAgICBhY3Rpb25TYW5pdGl6ZXIgPSBfcmVmJGFjdGlvblNhbml0aXplciA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmO1xuICAgIH0gOiBfcmVmJGFjdGlvblNhbml0aXplcjtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZSkge1xuICAgIHZhciBzdG9yZUlkID0gc3RvcmVJZENvdW50ZXIrKztcbiAgICBsb2dnZXIuYWRkRXZlbnQoJ2xyLnJlZHV4LkluaXRpYWxTdGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzYW5pdGl6ZWRTdGF0ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIG9ubHkgdHJ5IGNhdGNoIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnNcbiAgICAgICAgc2FuaXRpemVkU3RhdGUgPSBzdGF0ZVNhbml0aXplcihzdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVyci50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlOiBzYW5pdGl6ZWRTdGF0ZSxcbiAgICAgICAgc3RvcmVJZDogc3RvcmVJZFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBzdGFydCA9ICgwLCBfbm93LmRlZmF1bHQpKCk7XG4gICAgICAgIHZhciBlcnI7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gbmV4dChhY3Rpb24pO1xuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSAoMCwgX25vdy5kZWZhdWx0KSgpIC0gc3RhcnQ7XG4gICAgICAgICAgbG9nZ2VyLmFkZEV2ZW50KCdsci5yZWR1eC5SZWR1eEFjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkQWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIG9ubHkgdHJ5IGNhdGNoIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgc2FuaXRpemVkU3RhdGUgPSBzdGF0ZVNhbml0aXplcihzdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgICAgc2FuaXRpemVkQWN0aW9uID0gYWN0aW9uU2FuaXRpemVyKGFjdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2FuaXRpemVkU3RhdGUgJiYgc2FuaXRpemVkQWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RvcmVJZDogc3RvcmVJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHNhbml0aXplZEFjdGlvbixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGVEZWx0YTogc2FuaXRpemVkU3RhdGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3JlZHV4L3NyYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC9yZWR1eC9zcmMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVFbmhhbmNlclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZUVuaGFuY2VyLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU1pZGRsZXdhcmVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVNaWRkbGV3YXJlLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbnZhciBfY3JlYXRlRW5oYW5jZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JlYXRlRW5oYW5jZXIgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvcmVkdXgvc3JjL2NyZWF0ZUVuaGFuY2VyLmpzXCIpKTtcbnZhciBfY3JlYXRlTWlkZGxld2FyZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVNaWRkbGV3YXJlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3JlZHV4L3NyYy9jcmVhdGVNaWRkbGV3YXJlLmpzXCIpKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9UcmFjZUtpdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvVHJhY2VLaXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlICovXG5cblxuXG4vKlxuIFRyYWNlS2l0IC0gQ3Jvc3MgYnJvd3NlciBzdGFjayB0cmFjZXMgLSBnaXRodWIuY29tL29jYy9UcmFjZUtpdFxuXG4gVGhpcyB3YXMgb3JpZ2luYWxseSBmb3JrZWQgZnJvbSBnaXRodWIuY29tL29jYy9UcmFjZUtpdCwgYnV0IGhhcyBzaW5jZSBiZWVuXG4gbGFyZ2VseSByZS13cml0dGVuIGFuZCBpcyBub3cgbWFpbnRhaW5lZCBhcyBwYXJ0IG9mIHJhdmVuLWpzLiAgVGVzdHMgZm9yXG4gdGhpcyBhcmUgaW4gdGVzdC92ZW5kb3IuXG5cbiBNSVQgbGljZW5zZVxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIFRyYWNlS2l0ID0ge1xuICBjb2xsZWN0V2luZG93RXJyb3JzOiB0cnVlLFxuICBkZWJ1ZzogZmFsc2Vcbn07XG5cbi8vIFRoaXMgaXMgdG8gYmUgZGVmZW5zaXZlIGluIGVudmlyb25tZW50cyB3aGVyZSB3aW5kb3cgZG9lcyBub3QgZXhpc3QgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3JhdmVuLWpzL3B1bGwvNzg1KVxudmFyIF93aW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX3JlcXVpcmVfXy5nIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4vLyBnbG9iYWwgcmVmZXJlbmNlIHRvIHNsaWNlXG52YXIgX3NsaWNlID0gW10uc2xpY2U7XG52YXIgVU5LTk9XTl9GVU5DVElPTiA9ICc/JztcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbnZhciBFUlJPUl9UWVBFU19SRSA9IC9eKD86VW5jYXVnaHQgKD86ZXhjZXB0aW9uOiApPyk/KCg/OkV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvcik6ID8oLiopJC87XG5mdW5jdGlvbiBnZXRMb2NhdGlvbkhyZWYoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudC5sb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAnJztcbiAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG59XG5cbi8qKlxuICogVHJhY2VLaXQucmVwb3J0OiBjcm9zcy1icm93c2VyIHByb2Nlc3Npbmcgb2YgdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAqXG4gKiBTeW50YXg6XG4gKiAgIFRyYWNlS2l0LnJlcG9ydC5zdWJzY3JpYmUoZnVuY3Rpb24oc3RhY2tJbmZvKSB7IC4uLiB9KVxuICogICBUcmFjZUtpdC5yZXBvcnQudW5zdWJzY3JpYmUoZnVuY3Rpb24oc3RhY2tJbmZvKSB7IC4uLiB9KVxuICogICBUcmFjZUtpdC5yZXBvcnQoZXhjZXB0aW9uKVxuICogICB0cnkgeyAuLi5jb2RlLi4uIH0gY2F0Y2goZXgpIHsgVHJhY2VLaXQucmVwb3J0KGV4KTsgfVxuICpcbiAqIFN1cHBvcnRzOlxuICogICAtIEZpcmVmb3g6IGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIG51bWJlcnMsIHBsdXMgY29sdW1uIG51bWJlclxuICogICAgICAgICAgICAgIG9uIHRvcCBmcmFtZTsgY29sdW1uIG51bWJlciBpcyBub3QgZ3VhcmFudGVlZFxuICogICAtIE9wZXJhOiAgIGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyc1xuICogICAtIENocm9tZTogIGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyc1xuICogICAtIFNhZmFyaTogIGxpbmUgYW5kIGNvbHVtbiBudW1iZXIgZm9yIHRoZSB0b3AgZnJhbWUgb25seTsgc29tZSBmcmFtZXNcbiAqICAgICAgICAgICAgICBtYXkgYmUgbWlzc2luZywgYW5kIGNvbHVtbiBudW1iZXIgaXMgbm90IGd1YXJhbnRlZWRcbiAqICAgLSBJRTogICAgICBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyIGZvciB0aGUgdG9wIGZyYW1lIG9ubHk7IHNvbWUgZnJhbWVzXG4gKiAgICAgICAgICAgICAgbWF5IGJlIG1pc3NpbmcsIGFuZCBjb2x1bW4gbnVtYmVyIGlzIG5vdCBndWFyYW50ZWVkXG4gKlxuICogSW4gdGhlb3J5LCBUcmFjZUtpdCBzaG91bGQgd29yayBvbiBhbGwgb2YgdGhlIGZvbGxvd2luZyB2ZXJzaW9uczpcbiAqICAgLSBJRTUuNSsgKG9ubHkgOC4wIHRlc3RlZClcbiAqICAgLSBGaXJlZm94IDAuOSsgKG9ubHkgMy41KyB0ZXN0ZWQpXG4gKiAgIC0gT3BlcmEgNysgKG9ubHkgMTAuNTAgdGVzdGVkOyB2ZXJzaW9ucyA5IGFuZCBlYXJsaWVyIG1heSByZXF1aXJlXG4gKiAgICAgRXhjZXB0aW9ucyBIYXZlIFN0YWNrdHJhY2UgdG8gYmUgZW5hYmxlZCBpbiBvcGVyYTpjb25maWcpXG4gKiAgIC0gU2FmYXJpIDMrIChvbmx5IDQrIHRlc3RlZClcbiAqICAgLSBDaHJvbWUgMSsgKG9ubHkgNSsgdGVzdGVkKVxuICogICAtIEtvbnF1ZXJvciAzLjUrICh1bnRlc3RlZClcbiAqXG4gKiBSZXF1aXJlcyBUcmFjZUtpdC5jb21wdXRlU3RhY2tUcmFjZS5cbiAqXG4gKiBUcmllcyB0byBjYXRjaCBhbGwgdW5oYW5kbGVkIGV4Y2VwdGlvbnMgYW5kIHJlcG9ydCB0aGVtIHRvIHRoZVxuICogc3Vic2NyaWJlZCBoYW5kbGVycy4gUGxlYXNlIG5vdGUgdGhhdCBUcmFjZUtpdC5yZXBvcnQgd2lsbCByZXRocm93IHRoZVxuICogZXhjZXB0aW9uLiBUaGlzIGlzIFJFUVVJUkVEIGluIG9yZGVyIHRvIGdldCBhIHVzZWZ1bCBzdGFjayB0cmFjZSBpbiBJRS5cbiAqIElmIHRoZSBleGNlcHRpb24gZG9lcyBub3QgcmVhY2ggdGhlIHRvcCBvZiB0aGUgYnJvd3NlciwgeW91IHdpbGwgb25seVxuICogZ2V0IGEgc3RhY2sgdHJhY2UgZnJvbSB0aGUgcG9pbnQgd2hlcmUgVHJhY2VLaXQucmVwb3J0IHdhcyBjYWxsZWQuXG4gKlxuICogSGFuZGxlcnMgcmVjZWl2ZSBhIHN0YWNrSW5mbyBvYmplY3QgYXMgZGVzY3JpYmVkIGluIHRoZVxuICogVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2UgZG9jcy5cbiAqL1xuVHJhY2VLaXQucmVwb3J0ID0gZnVuY3Rpb24gcmVwb3J0TW9kdWxlV3JhcHBlcigpIHtcbiAgdmFyIGhhbmRsZXJzID0gW10sXG4gICAgbGFzdEFyZ3MgPSBudWxsLFxuICAgIGxhc3RFeGNlcHRpb24gPSBudWxsLFxuICAgIGxhc3RFeGNlcHRpb25TdGFjayA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNyYXNoIGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgaW5zdGFsbEdsb2JhbEhhbmRsZXIoKTtcbiAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNyYXNoIGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICBmb3IgKHZhciBpID0gaGFuZGxlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgY3Jhc2ggaGFuZGxlcnMuXG4gICAqL1xuICBmdW5jdGlvbiB1bnN1YnNjcmliZUFsbCgpIHtcbiAgICB1bmluc3RhbGxHbG9iYWxIYW5kbGVyKCk7XG4gICAgaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBzdGFjayBpbmZvcm1hdGlvbiB0byBhbGwgaGFuZGxlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+fSBzdGFja1xuICAgKi9cbiAgZnVuY3Rpb24gbm90aWZ5SGFuZGxlcnMoc3RhY2ssIGlzV2luZG93RXJyb3IpIHtcbiAgICB2YXIgZXhjZXB0aW9uID0gbnVsbDtcbiAgICBpZiAoaXNXaW5kb3dFcnJvciAmJiAhVHJhY2VLaXQuY29sbGVjdFdpbmRvd0Vycm9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpIGluIGhhbmRsZXJzKSB7XG4gICAgICBpZiAoaGFuZGxlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoYW5kbGVyc1tpXS5hcHBseShudWxsLCBbc3RhY2tdLmNvbmNhdChfc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKSk7XG4gICAgICAgIH0gY2F0Y2ggKGlubmVyKSB7XG4gICAgICAgICAgZXhjZXB0aW9uID0gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgfVxuICB2YXIgX29sZE9uZXJyb3JIYW5kbGVyLCBfb25FcnJvckhhbmRsZXJJbnN0YWxsZWQ7XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgYWxsIGdsb2JhbCB1bmhhbmRsZWQgZXhjZXB0aW9ucyBhcmUgcmVjb3JkZWQuXG4gICAqIFN1cHBvcnRlZCBieSBHZWNrbyBhbmQgSUUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIG9mIHNjcmlwdCB0aGF0IGdlbmVyYXRlZCB0aGUgZXhjZXB0aW9uLlxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gbGluZU5vIFRoZSBsaW5lIG51bWJlciBhdCB3aGljaCB0aGUgZXJyb3JcbiAgICogb2NjdXJyZWQuXG4gICAqIEBwYXJhbSB7PyhudW1iZXJ8c3RyaW5nKX0gY29sTm8gVGhlIGNvbHVtbiBudW1iZXIgYXQgd2hpY2ggdGhlIGVycm9yXG4gICAqIG9jY3VycmVkLlxuICAgKiBAcGFyYW0gez9FcnJvcn0gZXggVGhlIGFjdHVhbCBFcnJvciBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiB0cmFjZUtpdFdpbmRvd09uRXJyb3IobWVzc2FnZSwgdXJsLCBsaW5lTm8sIGNvbE5vLCBleCkge1xuICAgIHZhciBzdGFjayA9IG51bGw7XG4gICAgaWYgKGxhc3RFeGNlcHRpb25TdGFjaykge1xuICAgICAgVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2UuYXVnbWVudFN0YWNrVHJhY2VXaXRoSW5pdGlhbEVsZW1lbnQobGFzdEV4Y2VwdGlvblN0YWNrLCB1cmwsIGxpbmVObywgbWVzc2FnZSk7XG4gICAgICBwcm9jZXNzTGFzdEV4Y2VwdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoZXgpIHtcbiAgICAgIC8vIE5ldyBjaHJvbWUgYW5kIGJsaW5rIHNlbmQgYWxvbmcgYSByZWFsIGVycm9yIG9iamVjdFxuICAgICAgLy8gTGV0J3MganVzdCByZXBvcnQgdGhhdCBsaWtlIGEgbm9ybWFsIGVycm9yLlxuICAgICAgLy8gU2VlOiBodHRwczovL21pa2V3ZXN0Lm9yZy8yMDEzLzA4L2RlYnVnZ2luZy1ydW50aW1lLWVycm9ycy13aXRoLXdpbmRvdy1vbmVycm9yXG4gICAgICBzdGFjayA9IFRyYWNlS2l0LmNvbXB1dGVTdGFja1RyYWNlKGV4KTtcbiAgICAgIG5vdGlmeUhhbmRsZXJzKHN0YWNrLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0ge1xuICAgICAgICAndXJsJzogdXJsLFxuICAgICAgICAnbGluZSc6IGxpbmVObyxcbiAgICAgICAgJ2NvbHVtbic6IGNvbE5vXG4gICAgICB9O1xuICAgICAgdmFyIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgbXNnID0gbWVzc2FnZTsgLy8gbXVzdCBiZSBuZXcgdmFyIG9yIHdpbGwgbW9kaWZ5IG9yaWdpbmFsIGBhcmd1bWVudHNgXG4gICAgICB2YXIgZ3JvdXBzO1xuICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwobWVzc2FnZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBtZXNzYWdlLm1hdGNoKEVSUk9SX1RZUEVTX1JFKTtcbiAgICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICAgIG5hbWUgPSBncm91cHNbMV07XG4gICAgICAgICAgbXNnID0gZ3JvdXBzWzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsb2NhdGlvbi5mdW5jID0gVU5LTk9XTl9GVU5DVElPTjtcbiAgICAgIHN0YWNrID0ge1xuICAgICAgICAnbmFtZSc6IG5hbWUsXG4gICAgICAgICdtZXNzYWdlJzogbXNnLFxuICAgICAgICAndXJsJzogZ2V0TG9jYXRpb25IcmVmKCksXG4gICAgICAgICdzdGFjayc6IFtsb2NhdGlvbl1cbiAgICAgIH07XG4gICAgICBub3RpZnlIYW5kbGVycyhzdGFjaywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChfb2xkT25lcnJvckhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBfb2xkT25lcnJvckhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGluc3RhbGxHbG9iYWxIYW5kbGVyKCkge1xuICAgIGlmIChfb25FcnJvckhhbmRsZXJJbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX29sZE9uZXJyb3JIYW5kbGVyID0gX3dpbmRvdy5vbmVycm9yO1xuICAgIF93aW5kb3cub25lcnJvciA9IHRyYWNlS2l0V2luZG93T25FcnJvcjtcbiAgICBfb25FcnJvckhhbmRsZXJJbnN0YWxsZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHVuaW5zdGFsbEdsb2JhbEhhbmRsZXIoKSB7XG4gICAgaWYgKCFfb25FcnJvckhhbmRsZXJJbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3dpbmRvdy5vbmVycm9yID0gX29sZE9uZXJyb3JIYW5kbGVyO1xuICAgIF9vbkVycm9ySGFuZGxlckluc3RhbGxlZCA9IGZhbHNlO1xuICAgIF9vbGRPbmVycm9ySGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzTGFzdEV4Y2VwdGlvbigpIHtcbiAgICB2YXIgX2xhc3RFeGNlcHRpb25TdGFjayA9IGxhc3RFeGNlcHRpb25TdGFjayxcbiAgICAgIF9sYXN0QXJncyA9IGxhc3RBcmdzO1xuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgICBsYXN0RXhjZXB0aW9uU3RhY2sgPSBudWxsO1xuICAgIGxhc3RFeGNlcHRpb24gPSBudWxsO1xuICAgIG5vdGlmeUhhbmRsZXJzLmFwcGx5KG51bGwsIFtfbGFzdEV4Y2VwdGlvblN0YWNrLCBmYWxzZV0uY29uY2F0KF9sYXN0QXJncykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcG9ydHMgYW4gdW5oYW5kbGVkIEVycm9yIHRvIFRyYWNlS2l0LlxuICAgKiBAcGFyYW0ge0Vycm9yfSBleFxuICAgKiBAcGFyYW0gez9ib29sZWFufSByZXRocm93IElmIGZhbHNlLCBkbyBub3QgcmUtdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICogT25seSB1c2VkIGZvciB3aW5kb3cub25lcnJvciB0byBub3QgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCBvZlxuICAgKiByZXRocm93aW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwb3J0KGV4LCByZXRocm93KSB7XG4gICAgdmFyIGFyZ3MgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmIChsYXN0RXhjZXB0aW9uU3RhY2spIHtcbiAgICAgIGlmIChsYXN0RXhjZXB0aW9uID09PSBleCkge1xuICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgY2F1Z2h0IGJ5IGFuIGlubmVyIGNhdGNoIGJsb2NrLCBpZ25vcmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NMYXN0RXhjZXB0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdGFjayA9IFRyYWNlS2l0LmNvbXB1dGVTdGFja1RyYWNlKGV4KTtcbiAgICBsYXN0RXhjZXB0aW9uU3RhY2sgPSBzdGFjaztcbiAgICBsYXN0RXhjZXB0aW9uID0gZXg7XG4gICAgbGFzdEFyZ3MgPSBhcmdzO1xuXG4gICAgLy8gSWYgdGhlIHN0YWNrIHRyYWNlIGlzIGluY29tcGxldGUsIHdhaXQgZm9yIDIgc2Vjb25kcyBmb3JcbiAgICAvLyBzbG93IHNsb3cgSUUgdG8gc2VlIGlmIG9uZXJyb3Igb2NjdXJzIG9yIG5vdCBiZWZvcmUgcmVwb3J0aW5nXG4gICAgLy8gdGhpcyBleGNlcHRpb247IG90aGVyd2lzZSwgd2Ugd2lsbCBlbmQgdXAgd2l0aCBhbiBpbmNvbXBsZXRlXG4gICAgLy8gc3RhY2sgdHJhY2VcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsYXN0RXhjZXB0aW9uID09PSBleCkge1xuICAgICAgICBwcm9jZXNzTGFzdEV4Y2VwdGlvbigpO1xuICAgICAgfVxuICAgIH0sIHN0YWNrLmluY29tcGxldGUgPyAyMDAwIDogMCk7XG4gICAgaWYgKHJldGhyb3cgIT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBleDsgLy8gcmUtdGhyb3cgdG8gcHJvcGFnYXRlIHRvIHRoZSB0b3AgbGV2ZWwgKGFuZCBjYXVzZSB3aW5kb3cub25lcnJvcilcbiAgICB9XG4gIH1cblxuICByZXBvcnQuc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICByZXBvcnQudW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgcmVwb3J0LnVuaW5zdGFsbCA9IHVuc3Vic2NyaWJlQWxsO1xuICByZXR1cm4gcmVwb3J0O1xufSgpO1xuXG4vKipcbiAqIFRyYWNlS2l0LmNvbXB1dGVTdGFja1RyYWNlOiBjcm9zcy1icm93c2VyIHN0YWNrIHRyYWNlcyBpbiBKYXZhU2NyaXB0XG4gKlxuICogU3ludGF4OlxuICogICBzID0gVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2UoZXhjZXB0aW9uKSAvLyBjb25zaWRlciB1c2luZyBUcmFjZUtpdC5yZXBvcnQgaW5zdGVhZCAoc2VlIGJlbG93KVxuICogUmV0dXJuczpcbiAqICAgcy5uYW1lICAgICAgICAgICAgICAtIGV4Y2VwdGlvbiBuYW1lXG4gKiAgIHMubWVzc2FnZSAgICAgICAgICAgLSBleGNlcHRpb24gbWVzc2FnZVxuICogICBzLnN0YWNrW2ldLnVybCAgICAgIC0gSmF2YVNjcmlwdCBvciBIVE1MIGZpbGUgVVJMXG4gKiAgIHMuc3RhY2tbaV0uZnVuYyAgICAgLSBmdW5jdGlvbiBuYW1lLCBvciBlbXB0eSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyAoaWYgZ3Vlc3NpbmcgZGlkIG5vdCB3b3JrKVxuICogICBzLnN0YWNrW2ldLmFyZ3MgICAgIC0gYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24sIGlmIGtub3duXG4gKiAgIHMuc3RhY2tbaV0ubGluZSAgICAgLSBsaW5lIG51bWJlciwgaWYga25vd25cbiAqICAgcy5zdGFja1tpXS5jb2x1bW4gICAtIGNvbHVtbiBudW1iZXIsIGlmIGtub3duXG4gKlxuICogU3VwcG9ydHM6XG4gKiAgIC0gRmlyZWZveDogIGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIG51bWJlcnMgYW5kIHVucmVsaWFibGUgY29sdW1uXG4gKiAgICAgICAgICAgICAgIG51bWJlciBvbiB0b3AgZnJhbWVcbiAqICAgLSBPcGVyYSAxMDogZnVsbCBzdGFjayB0cmFjZSB3aXRoIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzXG4gKiAgIC0gT3BlcmEgOS06IGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIG51bWJlcnNcbiAqICAgLSBDaHJvbWU6ICAgZnVsbCBzdGFjayB0cmFjZSB3aXRoIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzXG4gKiAgIC0gU2FmYXJpOiAgIGxpbmUgYW5kIGNvbHVtbiBudW1iZXIgZm9yIHRoZSB0b3Btb3N0IHN0YWNrdHJhY2UgZWxlbWVudFxuICogICAgICAgICAgICAgICBvbmx5XG4gKiAgIC0gSUU6ICAgICAgIG5vIGxpbmUgbnVtYmVycyB3aGF0c29ldmVyXG4gKlxuICogVHJpZXMgdG8gZ3Vlc3MgbmFtZXMgb2YgYW5vbnltb3VzIGZ1bmN0aW9ucyBieSBsb29raW5nIGZvciBhc3NpZ25tZW50c1xuICogaW4gdGhlIHNvdXJjZSBjb2RlLiBJbiBJRSBhbmQgU2FmYXJpLCB3ZSBoYXZlIHRvIGd1ZXNzIHNvdXJjZSBmaWxlIG5hbWVzXG4gKiBieSBzZWFyY2hpbmcgZm9yIGZ1bmN0aW9uIGJvZGllcyBpbnNpZGUgYWxsIHBhZ2Ugc2NyaXB0cy4gVGhpcyB3aWxsIG5vdFxuICogd29yayBmb3Igc2NyaXB0cyB0aGF0IGFyZSBsb2FkZWQgY3Jvc3MtZG9tYWluLlxuICogSGVyZSBiZSBkcmFnb25zOiBzb21lIGZ1bmN0aW9uIG5hbWVzIG1heSBiZSBndWVzc2VkIGluY29ycmVjdGx5LCBhbmRcbiAqIGR1cGxpY2F0ZSBmdW5jdGlvbnMgbWF5IGJlIG1pc21hdGNoZWQuXG4gKlxuICogVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2Ugc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdHJhY2luZyBwdXJwb3Nlcy5cbiAqIExvZ2dpbmcgb2YgdW5oYW5kbGVkIGV4Y2VwdGlvbnMgc2hvdWxkIGJlIGRvbmUgd2l0aCBUcmFjZUtpdC5yZXBvcnQsXG4gKiB3aGljaCBidWlsZHMgb24gdG9wIG9mIFRyYWNlS2l0LmNvbXB1dGVTdGFja1RyYWNlIGFuZCBwcm92aWRlcyBiZXR0ZXJcbiAqIElFIHN1cHBvcnQgYnkgdXRpbGl6aW5nIHRoZSB3aW5kb3cub25lcnJvciBldmVudCB0byByZXRyaWV2ZSBpbmZvcm1hdGlvblxuICogYWJvdXQgdGhlIHRvcCBvZiB0aGUgc3RhY2suXG4gKlxuICogTm90ZTogSW4gSUUgYW5kIFNhZmFyaSwgbm8gc3RhY2sgdHJhY2UgaXMgcmVjb3JkZWQgb24gdGhlIEVycm9yIG9iamVjdCxcbiAqIHNvIGNvbXB1dGVTdGFja1RyYWNlIGluc3RlYWQgd2Fsa3MgaXRzICpvd24qIGNoYWluIG9mIGNhbGxlcnMuXG4gKiBUaGlzIG1lYW5zIHRoYXQ6XG4gKiAgKiBpbiBTYWZhcmksIHNvbWUgbWV0aG9kcyBtYXkgYmUgbWlzc2luZyBmcm9tIHRoZSBzdGFjayB0cmFjZTtcbiAqICAqIGluIElFLCB0aGUgdG9wbW9zdCBmdW5jdGlvbiBpbiB0aGUgc3RhY2sgdHJhY2Ugd2lsbCBhbHdheXMgYmUgdGhlXG4gKiAgICBjYWxsZXIgb2YgY29tcHV0ZVN0YWNrVHJhY2UuXG4gKlxuICogVGhpcyBpcyBva2F5IGZvciB0cmFjaW5nIChiZWNhdXNlIHlvdSBhcmUgbGlrZWx5IHRvIGJlIGNhbGxpbmdcbiAqIGNvbXB1dGVTdGFja1RyYWNlIGZyb20gdGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGJlIHRoZSB0b3Btb3N0IGVsZW1lbnRcbiAqIG9mIHRoZSBzdGFjayB0cmFjZSBhbnl3YXkpLCBidXQgbm90IG9rYXkgZm9yIGxvZ2dpbmcgdW5oYW5kbGVkXG4gKiBleGNlcHRpb25zIChiZWNhdXNlIHlvdXIgY2F0Y2ggYmxvY2sgd2lsbCBsaWtlbHkgYmUgZmFyIGF3YXkgZnJvbSB0aGVcbiAqIGlubmVyIGZ1bmN0aW9uIHRoYXQgYWN0dWFsbHkgY2F1c2VkIHRoZSBleGNlcHRpb24pLlxuICpcbiAqL1xuVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2UgPSBmdW5jdGlvbiBjb21wdXRlU3RhY2tUcmFjZVdyYXBwZXIoKSB7XG4gIC8qKlxuICAgKiBFc2NhcGVzIHNwZWNpYWwgY2hhcmFjdGVycywgZXhjZXB0IGZvciB3aGl0ZXNwYWNlLCBpbiBhIHN0cmluZyB0byBiZVxuICAgKiB1c2VkIGluc2lkZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyBhIHN0cmluZyBsaXRlcmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBlc2NhcGVkIHN0cmluZyBsaXRlcmFsLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I10vZywgJ1xcXFwkJicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nIHRvIGJlIHVzZWQgaW5zaWRlIGEgcmVndWxhclxuICAgKiBleHByZXNzaW9uIGFzIGEgc3RyaW5nIGxpdGVyYWwuIEFsc28gZW5zdXJlcyB0aGF0IEhUTUwgZW50aXRpZXMgd2lsbFxuICAgKiBiZSBtYXRjaGVkIHRoZSBzYW1lIGFzIHRoZWlyIGxpdGVyYWwgZnJpZW5kcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgVGhlIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZXNjYXBlZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVDb2RlQXNSZWdFeHBGb3JNYXRjaGluZ0luc2lkZUhUTUwoYm9keSkge1xuICAgIHJldHVybiBlc2NhcGVSZWdFeHAoYm9keSkucmVwbGFjZSgnPCcsICcoPzo8fCZsdDspJykucmVwbGFjZSgnPicsICcoPzo+fCZndDspJykucmVwbGFjZSgnJicsICcoPzomfCZhbXA7KScpLnJlcGxhY2UoJ1wiJywgJyg/OlwifCZxdW90OyknKS5yZXBsYWNlKC9cXHMrL2csICdcXFxccysnKTtcbiAgfVxuXG4gIC8vIENvbnRlbnRzIG9mIEV4Y2VwdGlvbiBpbiB2YXJpb3VzIGJyb3dzZXJzLlxuICAvL1xuICAvLyBTQUZBUkk6XG4gIC8vIGV4Lm1lc3NhZ2UgPSBDYW4ndCBmaW5kIHZhcmlhYmxlOiBxcVxuICAvLyBleC5saW5lID0gNTlcbiAgLy8gZXguc291cmNlSWQgPSA1ODAyMzgxOTJcbiAgLy8gZXguc291cmNlVVJMID0gaHR0cDovLy4uLlxuICAvLyBleC5leHByZXNzaW9uQmVnaW5PZmZzZXQgPSA5NlxuICAvLyBleC5leHByZXNzaW9uQ2FyZXRPZmZzZXQgPSA5OFxuICAvLyBleC5leHByZXNzaW9uRW5kT2Zmc2V0ID0gOThcbiAgLy8gZXgubmFtZSA9IFJlZmVyZW5jZUVycm9yXG4gIC8vXG4gIC8vIEZJUkVGT1g6XG4gIC8vIGV4Lm1lc3NhZ2UgPSBxcSBpcyBub3QgZGVmaW5lZFxuICAvLyBleC5maWxlTmFtZSA9IGh0dHA6Ly8uLi5cbiAgLy8gZXgubGluZU51bWJlciA9IDU5XG4gIC8vIGV4LmNvbHVtbk51bWJlciA9IDY5XG4gIC8vIGV4LnN0YWNrID0gLi4uc3RhY2sgdHJhY2UuLi4gKHNlZSB0aGUgZXhhbXBsZSBiZWxvdylcbiAgLy8gZXgubmFtZSA9IFJlZmVyZW5jZUVycm9yXG4gIC8vXG4gIC8vIENIUk9NRTpcbiAgLy8gZXgubWVzc2FnZSA9IHFxIGlzIG5vdCBkZWZpbmVkXG4gIC8vIGV4Lm5hbWUgPSBSZWZlcmVuY2VFcnJvclxuICAvLyBleC50eXBlID0gbm90X2RlZmluZWRcbiAgLy8gZXguYXJndW1lbnRzID0gWydhYSddXG4gIC8vIGV4LnN0YWNrID0gLi4uc3RhY2sgdHJhY2UuLi5cbiAgLy9cbiAgLy8gSU5URVJORVQgRVhQTE9SRVI6XG4gIC8vIGV4Lm1lc3NhZ2UgPSAuLi5cbiAgLy8gZXgubmFtZSA9IFJlZmVyZW5jZUVycm9yXG4gIC8vXG4gIC8vIE9QRVJBOlxuICAvLyBleC5tZXNzYWdlID0gLi4ubWVzc2FnZS4uLiAoc2VlIHRoZSBleGFtcGxlIGJlbG93KVxuICAvLyBleC5uYW1lID0gUmVmZXJlbmNlRXJyb3JcbiAgLy8gZXgub3BlcmEjc291cmNlbG9jID0gMTEgIChwcmV0dHkgbXVjaCB1c2VsZXNzLCBkdXBsaWNhdGVzIHRoZSBpbmZvIGluIGV4Lm1lc3NhZ2UpXG4gIC8vIGV4LnN0YWNrdHJhY2UgPSBuL2E7IHNlZSAnb3BlcmE6Y29uZmlnI1VzZXJQcmVmc3xFeGNlcHRpb25zIEhhdmUgU3RhY2t0cmFjZSdcblxuICAvKipcbiAgICogQ29tcHV0ZXMgc3RhY2sgdHJhY2UgaW5mb3JtYXRpb24gZnJvbSB0aGUgc3RhY2sgcHJvcGVydHkuXG4gICAqIENocm9tZSBhbmQgR2Vja28gdXNlIHRoaXMgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXJyb3J9IGV4XG4gICAqIEByZXR1cm4gez9PYmplY3QuPHN0cmluZywgKj59IFN0YWNrIHRyYWNlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZVN0YWNrVHJhY2VGcm9tU3RhY2tQcm9wKGV4KSB7XG4gICAgaWYgKHR5cGVvZiBleC5zdGFjayA9PT0gJ3VuZGVmaW5lZCcgfHwgIWV4LnN0YWNrKSByZXR1cm47XG4gICAgdmFyIGNocm9tZSA9IC9eXFxzKmF0ICguKj8pID9cXCgoKD86ZmlsZXxodHRwcz98YmxvYnxjaHJvbWUtZXh0ZW5zaW9ufG5hdGl2ZXxldmFsfDxhbm9ueW1vdXM+KS4qPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT9cXCk/XFxzKiQvaSxcbiAgICAgIGdlY2tvID0gL15cXHMqKC4qPykoPzpcXCgoLio/KVxcKSk/KD86XnxAKSgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZXxyZXNvdXJjZXxcXFtuYXRpdmUpLio/KSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xccyokL2ksXG4gICAgICB3aW5qcyA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT8uKykgKT9cXCg/KCg/OmZpbGV8bXMtYXBweHxodHRwcz98YmxvYik6Lio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaSxcbiAgICAgIGxpbmVzID0gZXguc3RhY2suc3BsaXQoJ1xcbicpLFxuICAgICAgc3RhY2sgPSBbXSxcbiAgICAgIHBhcnRzLFxuICAgICAgZWxlbWVudCxcbiAgICAgIHJlZmVyZW5jZSA9IC9eKC4qKSBpcyB1bmRlZmluZWQkLy5leGVjKGV4Lm1lc3NhZ2UpO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGluZXMubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICBpZiAocGFydHMgPSBjaHJvbWUuZXhlYyhsaW5lc1tpXSkpIHtcbiAgICAgICAgdmFyIGlzTmF0aXZlID0gcGFydHNbMl0gJiYgcGFydHNbMl0uaW5kZXhPZignbmF0aXZlJykgIT09IC0xO1xuICAgICAgICBlbGVtZW50ID0ge1xuICAgICAgICAgICd1cmwnOiAhaXNOYXRpdmUgPyBwYXJ0c1syXSA6IG51bGwsXG4gICAgICAgICAgJ2Z1bmMnOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgICAgICAgICdhcmdzJzogaXNOYXRpdmUgPyBbcGFydHNbMl1dIDogW10sXG4gICAgICAgICAgJ2xpbmUnOiBwYXJ0c1szXSA/ICtwYXJ0c1szXSA6IG51bGwsXG4gICAgICAgICAgJ2NvbHVtbic6IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChwYXJ0cyA9IHdpbmpzLmV4ZWMobGluZXNbaV0pKSB7XG4gICAgICAgIGVsZW1lbnQgPSB7XG4gICAgICAgICAgJ3VybCc6IHBhcnRzWzJdLFxuICAgICAgICAgICdmdW5jJzogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICAgICAgICAnYXJncyc6IFtdLFxuICAgICAgICAgICdsaW5lJzogK3BhcnRzWzNdLFxuICAgICAgICAgICdjb2x1bW4nOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAocGFydHMgPSBnZWNrby5leGVjKGxpbmVzW2ldKSkge1xuICAgICAgICBlbGVtZW50ID0ge1xuICAgICAgICAgICd1cmwnOiBwYXJ0c1szXSxcbiAgICAgICAgICAnZnVuYyc6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgICAgICAgJ2FyZ3MnOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCcsJykgOiBbXSxcbiAgICAgICAgICAnbGluZSc6IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbCxcbiAgICAgICAgICAnY29sdW1uJzogcGFydHNbNV0gPyArcGFydHNbNV0gOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudC5mdW5jICYmIGVsZW1lbnQubGluZSkge1xuICAgICAgICBlbGVtZW50LmZ1bmMgPSBVTktOT1dOX0ZVTkNUSU9OO1xuICAgICAgfVxuICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXN0YWNrWzBdLmNvbHVtbiAmJiB0eXBlb2YgZXguY29sdW1uTnVtYmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gRmlyZUZveCB1c2VzIHRoaXMgYXdlc29tZSBjb2x1bW5OdW1iZXIgcHJvcGVydHkgZm9yIGl0cyB0b3AgZnJhbWVcbiAgICAgIC8vIEFsc28gbm90ZSwgRmlyZWZveCdzIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZCBhbmQgZXZlcnl0aGluZyBlbHNlIGV4cGVjdHMgMS1iYXNlZCxcbiAgICAgIC8vIHNvIGFkZGluZyAxXG4gICAgICBzdGFja1swXS5jb2x1bW4gPSBleC5jb2x1bW5OdW1iZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgJ25hbWUnOiBleC5uYW1lLFxuICAgICAgJ21lc3NhZ2UnOiBleC5tZXNzYWdlLFxuICAgICAgJ3VybCc6IGdldExvY2F0aW9uSHJlZigpLFxuICAgICAgJ3N0YWNrJzogc3RhY2tcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZpcnN0IGZyYW1lIHRvIGluY29tcGxldGUgc3RhY2sgdHJhY2VzLlxuICAgKiBTYWZhcmkgYW5kIElFIHJlcXVpcmUgdGhpcyB0byBnZXQgY29tcGxldGUgZGF0YSBvbiB0aGUgZmlyc3QgZnJhbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+fSBzdGFja0luZm8gU3RhY2sgdHJhY2UgaW5mb3JtYXRpb24gZnJvbVxuICAgKiBvbmUgb2YgdGhlIGNvbXB1dGUqIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgc2NyaXB0IHRoYXQgY2F1c2VkIGFuIGVycm9yLlxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gbGluZU5vIFRoZSBsaW5lIG51bWJlciBvZiB0aGUgc2NyaXB0IHRoYXRcbiAgICogY2F1c2VkIGFuIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIGVycm9yIGdlbmVyYXRlZCBieSB0aGUgYnJvd3Nlciwgd2hpY2hcbiAgICogaG9wZWZ1bGx5IGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSBvYmplY3QgdGhhdCBjYXVzZWQgdGhlIGVycm9yLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgc3RhY2sgaW5mb3JtYXRpb24gd2FzXG4gICAqIGF1Z21lbnRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGF1Z21lbnRTdGFja1RyYWNlV2l0aEluaXRpYWxFbGVtZW50KHN0YWNrSW5mbywgdXJsLCBsaW5lTm8sIG1lc3NhZ2UpIHtcbiAgICB2YXIgaW5pdGlhbCA9IHtcbiAgICAgICd1cmwnOiB1cmwsXG4gICAgICAnbGluZSc6IGxpbmVOb1xuICAgIH07XG4gICAgaWYgKGluaXRpYWwudXJsICYmIGluaXRpYWwubGluZSkge1xuICAgICAgc3RhY2tJbmZvLmluY29tcGxldGUgPSBmYWxzZTtcbiAgICAgIGlmICghaW5pdGlhbC5mdW5jKSB7XG4gICAgICAgIGluaXRpYWwuZnVuYyA9IFVOS05PV05fRlVOQ1RJT047XG4gICAgICB9XG4gICAgICBpZiAoc3RhY2tJbmZvLnN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHN0YWNrSW5mby5zdGFja1swXS51cmwgPT09IGluaXRpYWwudXJsKSB7XG4gICAgICAgICAgaWYgKHN0YWNrSW5mby5zdGFja1swXS5saW5lID09PSBpbml0aWFsLmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gYWxyZWFkeSBpbiBzdGFjayB0cmFjZVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YWNrSW5mby5zdGFja1swXS5saW5lICYmIHN0YWNrSW5mby5zdGFja1swXS5mdW5jID09PSBpbml0aWFsLmZ1bmMpIHtcbiAgICAgICAgICAgIHN0YWNrSW5mby5zdGFja1swXS5saW5lID0gaW5pdGlhbC5saW5lO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tJbmZvLnN0YWNrLnVuc2hpZnQoaW5pdGlhbCk7XG4gICAgICBzdGFja0luZm8ucGFydGlhbCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhY2tJbmZvLmluY29tcGxldGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgc3RhY2sgdHJhY2UgaW5mb3JtYXRpb24gYnkgd2Fsa2luZyB0aGUgYXJndW1lbnRzLmNhbGxlclxuICAgKiBjaGFpbiBhdCB0aGUgdGltZSB0aGUgZXhjZXB0aW9uIG9jY3VycmVkLiBUaGlzIHdpbGwgY2F1c2UgZWFybGllclxuICAgKiBmcmFtZXMgdG8gYmUgbWlzc2VkIGJ1dCBpcyB0aGUgb25seSB3YXkgdG8gZ2V0IGFueSBzdGFjayB0cmFjZSBpblxuICAgKiBTYWZhcmkgYW5kIElFLiBUaGUgdG9wIGZyYW1lIGlzIHJlc3RvcmVkIGJ5XG4gICAqIHtAbGluayBhdWdtZW50U3RhY2tUcmFjZVdpdGhJbml0aWFsRWxlbWVudH0uXG4gICAqIEBwYXJhbSB7RXJyb3J9IGV4XG4gICAqIEByZXR1cm4gez9PYmplY3QuPHN0cmluZywgKj59IFN0YWNrIHRyYWNlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZVN0YWNrVHJhY2VCeVdhbGtpbmdDYWxsZXJDaGFpbihleCwgZGVwdGgpIHtcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gL2Z1bmN0aW9uXFxzKyhbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKik/XFxzKlxcKC9pLFxuICAgICAgc3RhY2sgPSBbXSxcbiAgICAgIGZ1bmNzID0ge30sXG4gICAgICByZWN1cnNpb24gPSBmYWxzZSxcbiAgICAgIHBhcnRzLFxuICAgICAgaXRlbSxcbiAgICAgIHNvdXJjZTtcbiAgICBmb3IgKHZhciBjdXJyID0gY29tcHV0ZVN0YWNrVHJhY2VCeVdhbGtpbmdDYWxsZXJDaGFpbi5jYWxsZXI7IGN1cnIgJiYgIXJlY3Vyc2lvbjsgY3VyciA9IGN1cnIuY2FsbGVyKSB7XG4gICAgICBpZiAoY3VyciA9PT0gY29tcHV0ZVN0YWNrVHJhY2UgfHwgY3VyciA9PT0gVHJhY2VLaXQucmVwb3J0KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdza2lwcGluZyBpbnRlcm5hbCBmdW5jdGlvbicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgICd1cmwnOiBudWxsLFxuICAgICAgICAnZnVuYyc6IFVOS05PV05fRlVOQ1RJT04sXG4gICAgICAgICdsaW5lJzogbnVsbCxcbiAgICAgICAgJ2NvbHVtbic6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoY3Vyci5uYW1lKSB7XG4gICAgICAgIGl0ZW0uZnVuYyA9IGN1cnIubmFtZTtcbiAgICAgIH0gZWxzZSBpZiAocGFydHMgPSBmdW5jdGlvbk5hbWUuZXhlYyhjdXJyLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgIGl0ZW0uZnVuYyA9IHBhcnRzWzFdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtLmZ1bmMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaXRlbS5mdW5jID0gcGFydHMuaW5wdXQuc3Vic3RyaW5nKDAsIHBhcnRzLmlucHV0LmluZGV4T2YoJ3snKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICBpZiAoZnVuY3NbJycgKyBjdXJyXSkge1xuICAgICAgICByZWN1cnNpb24gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY3NbJycgKyBjdXJyXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdGFjay5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoZGVwdGgpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkZXB0aCBpcyAnICsgZGVwdGgpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3N0YWNrIGlzICcgKyBzdGFjay5sZW5ndGgpO1xuICAgICAgc3RhY2suc3BsaWNlKDAsIGRlcHRoKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICduYW1lJzogZXgubmFtZSxcbiAgICAgICdtZXNzYWdlJzogZXgubWVzc2FnZSxcbiAgICAgICd1cmwnOiBnZXRMb2NhdGlvbkhyZWYoKSxcbiAgICAgICdzdGFjayc6IHN0YWNrXG4gICAgfTtcbiAgICBhdWdtZW50U3RhY2tUcmFjZVdpdGhJbml0aWFsRWxlbWVudChyZXN1bHQsIGV4LnNvdXJjZVVSTCB8fCBleC5maWxlTmFtZSwgZXgubGluZSB8fCBleC5saW5lTnVtYmVyLCBleC5tZXNzYWdlIHx8IGV4LmRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgc3RhY2sgdHJhY2UgZm9yIGFuIGV4Y2VwdGlvbi5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXhcbiAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcik9fSBkZXB0aFxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZVN0YWNrVHJhY2UoZXgsIGRlcHRoKSB7XG4gICAgdmFyIHN0YWNrID0gbnVsbDtcbiAgICBkZXB0aCA9IGRlcHRoID09IG51bGwgPyAwIDogK2RlcHRoO1xuICAgIHRyeSB7XG4gICAgICBzdGFjayA9IGNvbXB1dGVTdGFja1RyYWNlRnJvbVN0YWNrUHJvcChleCk7XG4gICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChUcmFjZUtpdC5kZWJ1Zykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgc3RhY2sgPSBjb21wdXRlU3RhY2tUcmFjZUJ5V2Fsa2luZ0NhbGxlckNoYWluKGV4LCBkZXB0aCArIDEpO1xuICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoVHJhY2VLaXQuZGVidWcpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICduYW1lJzogZXgubmFtZSxcbiAgICAgICdtZXNzYWdlJzogZXgubWVzc2FnZSxcbiAgICAgICd1cmwnOiBnZXRMb2NhdGlvbkhyZWYoKVxuICAgIH07XG4gIH1cbiAgY29tcHV0ZVN0YWNrVHJhY2UuYXVnbWVudFN0YWNrVHJhY2VXaXRoSW5pdGlhbEVsZW1lbnQgPSBhdWdtZW50U3RhY2tUcmFjZVdpdGhJbml0aWFsRWxlbWVudDtcbiAgY29tcHV0ZVN0YWNrVHJhY2UuY29tcHV0ZVN0YWNrVHJhY2VGcm9tU3RhY2tQcm9wID0gY29tcHV0ZVN0YWNrVHJhY2VGcm9tU3RhY2tQcm9wO1xuICByZXR1cm4gY29tcHV0ZVN0YWNrVHJhY2U7XG59KCk7XG52YXIgX2RlZmF1bHQgPSBUcmFjZUtpdDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvYWRkTGlzdGVuZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2FkZExpc3RlbmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhZGRMaXN0ZW5lcjtcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIG9iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZG9jdW1lbnQ7XG4gIG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9hZGp1c3RPc1ZlcnNpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9hZGp1c3RPc1ZlcnNpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5hZGp1c3RPc1ZlcnNpb24gPSBhZGp1c3RPc1ZlcnNpb247XG5leHBvcnRzLmFkanVzdE9zID0gYWRqdXN0T3M7XG5mdW5jdGlvbiBhZGp1c3RPc1ZlcnNpb24ob3NOYW1lLCBvc1ZlcnNpb25TdHIpIHtcbiAgdmFyIG9zVmVyc2lvbiA9IG9zVmVyc2lvblN0cjtcbiAgaWYgKG9zVmVyc2lvblN0ciAmJiBvc05hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJycpLmluZGV4T2YoJ21hY29zJykgPiAtMSkge1xuICAgIG9zVmVyc2lvbiA9IG9zVmVyc2lvblN0ci5yZXBsYWNlKCcxMC4xNS43JywgJzEwLjE1LjcrJyk7XG4gIH1cbiAgcmV0dXJuIG9zVmVyc2lvbjtcbn1cblxuLy8gVXNlZCB3aGVuIG9zIG5hbWUgYW5kIHZlcnNpb24gYXJlIGNvbWJpbmVkIGluIDEgc3RyaW5nLCBpLmUuIFwiTWFjIE9TIFggMTAuMTUuN1wiXG5mdW5jdGlvbiBhZGp1c3RPcyhvcykge1xuICByZXR1cm4gYWRqdXN0T3NWZXJzaW9uKG9zLCBvcyk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvYXBwbHlVcmxTYW5pdGl6ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2FwcGx5VXJsU2FuaXRpemVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhcHBseVVybFNhbml0aXplcjtcbmZ1bmN0aW9uIGFwcGx5VXJsU2FuaXRpemVyKF9yZWYpIHtcbiAgdmFyIGxvZ2dlciA9IF9yZWYubG9nZ2VyLFxuICAgIF9yZWYkdXJsID0gX3JlZi51cmwsXG4gICAgdXJsID0gX3JlZiR1cmwgPT09IHZvaWQgMCA/ICcnIDogX3JlZiR1cmw7XG4gIHZhciBfcmVmMiA9IGxvZ2dlci5nZXRDb25maWcoJ2xyLmJyb3dzZXInKSB8fCB7fSxcbiAgICBfcmVmMiR1cmxTYW5pdGl6ZXIgPSBfcmVmMi51cmxTYW5pdGl6ZXIsXG4gICAgdXJsU2FuaXRpemVyID0gX3JlZjIkdXJsU2FuaXRpemVyID09PSB2b2lkIDAgPyBmdW5jdGlvbiAob3JpZ2luYWxVcmwpIHtcbiAgICAgIHJldHVybiBvcmlnaW5hbFVybDtcbiAgICB9IDogX3JlZjIkdXJsU2FuaXRpemVyO1xuICB2YXIgc2FuaXRpemVkVmFsdWU7XG4gIHRyeSB7XG4gICAgc2FuaXRpemVkVmFsdWUgPSB1cmxTYW5pdGl6ZXIodXJsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHNhbml0aXplZFZhbHVlO1xuICB9XG5cbiAgLy8gaWYgc29tZXRoaW5nIHdlbnQgd3Jvbmcgb3Igd2FzIHNldCB0byBudWxsLCByZWRhY3QgY29tcGxldGVseVxuICByZXR1cm4gJyc7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvYnJvd3NlclV0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvYnJvd3NlclV0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZ2V0Tm9kZU5hbWUgPSBnZXROb2RlTmFtZTtcbmV4cG9ydHMuZ2V0VGFyZ2V0Rm9yRXZlbnQgPSBnZXRUYXJnZXRGb3JFdmVudDtcbmV4cG9ydHMuZ2V0Tm9kZVBhdGggPSBnZXROb2RlUGF0aDtcbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQtZnJhZ21lbnQnICYmIG5vZGUubW9kZSA9PT0gJ29wZW4nKSB7XG4gICAgcmV0dXJuICckc2hhZG93LXJvb3QnO1xuICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFRhcmdldEZvckV2ZW50KGV2ZW50KSB7XG4gIGlmICh0eXBlb2YgZXZlbnQuY29tcG9zZWRQYXRoID09PSAnZnVuY3Rpb24nICYmIGV2ZW50LmNvbXBvc2VkKSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9IGVsc2UgaWYgKGV2ZW50LnBhdGgpIHtcbiAgICByZXR1cm4gZXZlbnQucGF0aFswXTtcbiAgfVxuICByZXR1cm4gZXZlbnQudGFyZ2V0O1xufVxuXG4vLyBtYXhpbXVtIHNpemUgb2Ygc2VsZWN0b3Igc3RyaW5nLCBhZnRlciB3aGljaCB3ZSBubyBsb25nZXIgd2FsayB1cCB0aGUgRE9NIHRyZWUgdG8gY2FsY3VsYXRlXG4vLyB0aGUgbm9kZSBwYXRoLiBUaGlzIGNhbm5vdCBiZSBsYXJnZXIgdGhhbiAyMDQ4XG52YXIgU0VMRUNUT1JfTUFYX0xFTkdUSCA9IDEwMDA7XG5mdW5jdGlvbiBnZXROb2RlUGF0aChlbGVtZW50KSB7XG4gIHZhciBhY3RpdmVOb2RlID0gZWxlbWVudDtcbiAgdmFyIG5vZGVQYXRoID0gW107XG4gIHZhciBub2RlUGF0aExlbmd0aCA9IDA7XG4gIHdoaWxlIChhY3RpdmVOb2RlICYmIChhY3RpdmVOb2RlLnBhcmVudE5vZGUgfHwgYWN0aXZlTm9kZS5ob3N0KSkge1xuICAgIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKGFjdGl2ZU5vZGUpO1xuXG4gICAgLy8gZW5kIGF0IHRoZSBib2R5XG4gICAgaWYgKG5vZGVOYW1lID09PSAnYm9keScpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0b3IgPSB7XG4gICAgICBub2RlTmFtZTogbm9kZU5hbWVcbiAgICB9O1xuICAgIHZhciBzZWxlY3Rvckxlbmd0aCA9IHNlbGVjdG9yLm5vZGVOYW1lLmxlbmd0aDtcbiAgICBpZiAoYWN0aXZlTm9kZS5pZCAmJiBhY3RpdmVOb2RlLmlkLmxlbmd0aCA+IDApIHtcbiAgICAgIHNlbGVjdG9yLmlkID0gYWN0aXZlTm9kZS5pZDtcbiAgICAgIHNlbGVjdG9yTGVuZ3RoICs9IGFjdGl2ZU5vZGUuaWQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlTm9kZS5jbGFzc0xpc3QgJiYgYWN0aXZlTm9kZS5jbGFzc0xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZWN0b3IuY2xhc3NMaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYWN0aXZlTm9kZS5jbGFzc0xpc3QsIDApO1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFjdGl2ZU5vZGUuY2xhc3NMaXN0LCAnJyk7XG4gICAgICAvLyBjbGFzc05hbWVzIHNvbWV0aW1lcyBpcyBudWxsXG4gICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICBzZWxlY3Rvckxlbmd0aCArPSBjbGFzc05hbWVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGVQYXRoTGVuZ3RoICsgc2VsZWN0b3JMZW5ndGggPiBTRUxFQ1RPUl9NQVhfTEVOR1RIKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJRTExIG1heSBub3QgaGF2ZSBhIGNoaWxkcmVuIE5vZGVMaXN0LCBhbmQgc2hhZG93Um9vdHMgd2lsbCBub3QgaGF2ZSBhIHBhcmVudE5vZGVcbiAgICBpZiAoYWN0aXZlTm9kZS5wYXJlbnROb2RlICYmIGFjdGl2ZU5vZGUucGFyZW50Tm9kZS5jaGlsZHJlbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG50aENoaWxkID0gMDtcbiAgICAgICAgdmFyIHNpYmxpbmdOb2RlID0gYWN0aXZlTm9kZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG50aENoaWxkICs9IDE7XG4gICAgICAgICAgc2libGluZ05vZGUgPSBzaWJsaW5nTm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9IHdoaWxlIChzaWJsaW5nTm9kZSk7XG4gICAgICAgIHNlbGVjdG9yLm50aENoaWxkID0gbnRoQ2hpbGQ7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIC8qIElFIGFwcGVhcnMgdG8gcHJvdmlkZSBhIG51bGwvdW5kZWZpbmVkIHZhbHVlIGZvciBjaGlsZHJlbiBpbiBzb21lIHJhcmUgY2FzZXM/ICovXG4gICAgICB9XG4gICAgfVxuICAgIG5vZGVQYXRoTGVuZ3RoICs9IHNlbGVjdG9yTGVuZ3RoO1xuICAgIG5vZGVQYXRoLnB1c2goc2VsZWN0b3IpO1xuICAgIGFjdGl2ZU5vZGUgPSBhY3RpdmVOb2RlLnBhcmVudE5vZGUgfHwgYWN0aXZlTm9kZS5ob3N0O1xuICB9XG4gIHJldHVybiBub2RlUGF0aDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb25zdGFudHMvaXNzdWVzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9pc3N1ZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuRVNfSVNTVUVfVFlQRV9CQVNFX0ZJTFRFUiA9IGV4cG9ydHMuRVNfSVNTVUVfVFlQRVMgPSBleHBvcnRzLklTU1VFX0dST1VQX1RZUEUgPSBleHBvcnRzLklTU1VFX1RZUEUgPSB2b2lkIDA7XG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcIikpO1xudmFyIF9FU19JU1NVRV9UWVBFX0JBU0VfRjtcbnZhciBJU1NVRV9UWVBFID0ge1xuICBFWENFUFRJT046ICdFWENFUFRJT04nLFxuICBORVRXT1JLX0VSUk9SOiAnTkVUV09SS19FUlJPUicsXG4gIFJBR0VfQ0xJQ0s6ICdSQUdFX0NMSUNLJyxcbiAgREVBRF9DTElDSzogJ0RFQURfQ0xJQ0snLFxuICBGUlVTVFJBVElOR19ORVRXT1JLOiAnRlJVU1RSQVRJTkdfTkVUV09SSycsXG4gIEVSUk9SX1NUQVRFOiAnRVJST1JfU1RBVEUnXG59O1xuZXhwb3J0cy5JU1NVRV9UWVBFID0gSVNTVUVfVFlQRTtcbnZhciBJU1NVRV9HUk9VUF9UWVBFID0ge1xuICBFTkNPREVEX0ZJTFRFUjogJ0VOQ09ERURfRklMVEVSJyxcbiAgU0VOVFJZOiAnU0VOVFJZJyxcbiAgVFJPWVRPV046ICdUUk9ZVE9XTidcbn07XG5leHBvcnRzLklTU1VFX0dST1VQX1RZUEUgPSBJU1NVRV9HUk9VUF9UWVBFO1xudmFyIEVTX0lTU1VFX1RZUEVTID0gW0lTU1VFX1RZUEUuUkFHRV9DTElDSywgSVNTVUVfVFlQRS5ERUFEX0NMSUNLLCBJU1NVRV9UWVBFLkZSVVNUUkFUSU5HX05FVFdPUkssIElTU1VFX1RZUEUuRVJST1JfU1RBVEVdO1xuZXhwb3J0cy5FU19JU1NVRV9UWVBFUyA9IEVTX0lTU1VFX1RZUEVTO1xudmFyIEVTX0lTU1VFX1RZUEVfQkFTRV9GSUxURVIgPSAoX0VTX0lTU1VFX1RZUEVfQkFTRV9GID0ge30sICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKF9FU19JU1NVRV9UWVBFX0JBU0VfRiwgSVNTVUVfVFlQRS5SQUdFX0NMSUNLLCB7XG4gIHJhZ2VDbGlja2VkOiB7XG4gICAgb3BlcmF0b3I6ICdURVhUX0lTJyxcbiAgICBzdHJpbmdzOiBbXVxuICB9XG59KSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoX0VTX0lTU1VFX1RZUEVfQkFTRV9GLCBJU1NVRV9UWVBFLkRFQURfQ0xJQ0ssIHtcbiAgZGVhZENsaWNrZWQ6IHtcbiAgICBvcGVyYXRvcjogJ1RFWFRfSVMnLFxuICAgIHN0cmluZ3M6IFtdXG4gIH1cbn0pLCBfRVNfSVNTVUVfVFlQRV9CQVNFX0YpO1xuZXhwb3J0cy5FU19JU1NVRV9UWVBFX0JBU0VfRklMVEVSID0gRVNfSVNTVUVfVFlQRV9CQVNFX0ZJTFRFUjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb25zdGFudHMvbG9nVHlwZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb25zdGFudHMvbG9nVHlwZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5MT0dfRklMVEVSX1RZUEVTID0gZXhwb3J0cy5MT0dfVFlQRVMgPSB2b2lkIDA7XG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcIikpO1xudmFyIF9MT0dfRklMVEVSX1RZUEVTO1xudmFyIExPR19UWVBFUyA9IHtcbiAgTE9HOiAnTE9HJyxcbiAgV0FSTjogJ1dBUk4nLFxuICBFUlJPUjogJ0VSUk9SJyxcbiAgREVCVUc6ICdERUJVRycsXG4gIElORk86ICdJTkZPJyxcbiAgUkVEVVg6ICdSRURVWCcsXG4gIExJRkVDWUNMRTogJ0xJRkVDWUNMRScsXG4gIE5BVklHQVRJT046ICdOQVZJR0FUSU9OJyxcbiAgTkVUV09SSzogJ05FVFdPUksnLFxuICBQUkVWX1NFU1NJT046ICdQUkVWX1NFU1NJT04nLFxuICBORVhUX1NFU1NJT046ICdORVhUX1NFU1NJT04nLFxuICBMT0FEX01PUkU6ICdMT0FEX01PUkUnLFxuICBFWENFUFRJT046ICdFWENFUFRJT04nXG59O1xuZXhwb3J0cy5MT0dfVFlQRVMgPSBMT0dfVFlQRVM7XG52YXIgTE9HX0ZJTFRFUl9UWVBFUyA9IChfTE9HX0ZJTFRFUl9UWVBFUyA9IHt9LCAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShfTE9HX0ZJTFRFUl9UWVBFUywgTE9HX1RZUEVTLkxPRywge1xuICBsYWJlbDogJ0xvZ3MnLFxuICBmaWx0ZXJMYWJlbDogJ0xvZycsXG4gIHR5cGVzOiBbTE9HX1RZUEVTLkxPR11cbn0pLCAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShfTE9HX0ZJTFRFUl9UWVBFUywgTE9HX1RZUEVTLldBUk4sIHtcbiAgbGFiZWw6ICdXYXJuaW5ncycsXG4gIGZpbHRlckxhYmVsOiAnV2FybmluZycsXG4gIHR5cGVzOiBbTE9HX1RZUEVTLldBUk5dXG59KSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoX0xPR19GSUxURVJfVFlQRVMsIExPR19UWVBFUy5FUlJPUiwge1xuICBsYWJlbDogJ0Vycm9ycycsXG4gIGZpbHRlckxhYmVsOiAnRXJyb3InLFxuICB0eXBlczogW0xPR19UWVBFUy5FUlJPUiwgTE9HX1RZUEVTLkVYQ0VQVElPTl1cbn0pLCAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShfTE9HX0ZJTFRFUl9UWVBFUywgTE9HX1RZUEVTLklORk8sIHtcbiAgbGFiZWw6ICdJbmZvJyxcbiAgZmlsdGVyTGFiZWw6ICdJbmZvJyxcbiAgdHlwZXM6IFtMT0dfVFlQRVMuSU5GT11cbn0pLCAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShfTE9HX0ZJTFRFUl9UWVBFUywgTE9HX1RZUEVTLkRFQlVHLCB7XG4gIGxhYmVsOiAnRGVidWcnLFxuICBmaWx0ZXJMYWJlbDogJ0RlYnVnJyxcbiAgdHlwZXM6IFtMT0dfVFlQRVMuREVCVUddXG59KSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoX0xPR19GSUxURVJfVFlQRVMsIExPR19UWVBFUy5SRURVWCwge1xuICBsYWJlbDogJ1JlZHV4JyxcbiAgdHlwZXM6IFtMT0dfVFlQRVMuUkVEVVhdXG59KSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoX0xPR19GSUxURVJfVFlQRVMsIExPR19UWVBFUy5OQVZJR0FUSU9OLCB7XG4gIGxhYmVsOiAnTmF2aWdhdGlvbicsXG4gIHR5cGVzOiBbTE9HX1RZUEVTLk5BVklHQVRJT04sIExPR19UWVBFUy5MSUZFQ1lDTEVdXG59KSwgX0xPR19GSUxURVJfVFlQRVMpO1xuZXhwb3J0cy5MT0dfRklMVEVSX1RZUEVTID0gTE9HX0ZJTFRFUl9UWVBFUztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb25zdGFudHMvbWV0cmljcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvY29uc3RhbnRzL21ldHJpY3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkRFRkFVTFRfSU5TSUdIVFNfSEVBVE1BUF9GT1JfVVJMX09QRVJBVE9SID0gZXhwb3J0cy5ERUZBVUxUX0hFQVRNQVBfRk9SX1VSTF9PUEVSQVRPUiA9IGV4cG9ydHMubmV4dFNvcnREaXJlY3Rpb24gPSBleHBvcnRzLlNPUlRfRElSRUNUSU9OID0gZXhwb3J0cy5GRUVEQkFDS19TT1JUX0NPTFVNTiA9IGV4cG9ydHMuSEVBVE1BUF9GT1JfVVJMX09QRVJBVE9SID0gZXhwb3J0cy5NRVRSSUNfUkVURU5USU9OX1RZUEUgPSBleHBvcnRzLk1FVFJJQ19USU1FU0VSSUVTX1RZUEUgPSB2b2lkIDA7XG52YXIgTUVUUklDX1RJTUVTRVJJRVNfVFlQRSA9IHtcbiAgU0VTU0lPTl9DT1VOVDogJ1NFU1NJT05fQ09VTlQnLFxuICBQRVJDRU5USUxFOiAnUEVSQ0VOVElMRScsXG4gIENPTlZFUlNJT05fUkFURTogJ0NPTlZFUlNJT05fUkFURScsXG4gIFNFU1NJT05fUEVSQ0VOVEFHRTogJ1NFU1NJT05fUEVSQ0VOVEFHRScsXG4gIEFDVElWRV9VU0VSUzogJ0FDVElWRV9VU0VSUycsXG4gIEVWRU5UX0NPVU5UOiAnRVZFTlRfQ09VTlQnXG59O1xuZXhwb3J0cy5NRVRSSUNfVElNRVNFUklFU19UWVBFID0gTUVUUklDX1RJTUVTRVJJRVNfVFlQRTtcbnZhciBNRVRSSUNfUkVURU5USU9OX1RZUEUgPSB7XG4gIFVTRVJfUEVSQ0VOVEFHRTogJ1VTRVJfUEVSQ0VOVEFHRSdcbn07XG5leHBvcnRzLk1FVFJJQ19SRVRFTlRJT05fVFlQRSA9IE1FVFJJQ19SRVRFTlRJT05fVFlQRTtcbnZhciBIRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1IgPSB7XG4gIElTOiAnSVMnLFxuICBDT05UQUlOUzogJ0NPTlRBSU5TJyxcbiAgTElLRTogJ0xJS0UnLFxuICBIUkVGX0xJS0U6ICdIUkVGX0xJS0UnXG59O1xuZXhwb3J0cy5IRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1IgPSBIRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1I7XG52YXIgRkVFREJBQ0tfU09SVF9DT0xVTU4gPSB7XG4gIFJBVElORzogJ1JBVElORycsXG4gIFNVQk1JU1NJT05fREFURTogJ1NVQk1JU1NJT05fREFURSdcbn07XG5leHBvcnRzLkZFRURCQUNLX1NPUlRfQ09MVU1OID0gRkVFREJBQ0tfU09SVF9DT0xVTU47XG52YXIgU09SVF9ESVJFQ1RJT04gPSB7XG4gIFVOU0VUOiAnVU5TRVQnLFxuICBBU0M6ICdBU0MnLFxuICBERVNDOiAnREVTQydcbn07XG5leHBvcnRzLlNPUlRfRElSRUNUSU9OID0gU09SVF9ESVJFQ1RJT047XG52YXIgbmV4dFNvcnREaXJlY3Rpb24gPSBmdW5jdGlvbiBuZXh0U29ydERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgIF9yZWYkcmV2ZXJzZSA9IF9yZWYucmV2ZXJzZSxcbiAgICByZXZlcnNlID0gX3JlZiRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkcmV2ZXJzZTtcbiAgdmFyIFVOU0VUID0gU09SVF9ESVJFQ1RJT04uVU5TRVQsXG4gICAgQVNDID0gU09SVF9ESVJFQ1RJT04uQVNDLFxuICAgIERFU0MgPSBTT1JUX0RJUkVDVElPTi5ERVNDO1xuICB2YXIgZGlyZWN0aW9uT3B0aW9ucyA9IFtVTlNFVCwgREVTQywgQVNDXTtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBkaXJlY3Rpb25PcHRpb25zID0gW1VOU0VULCBBU0MsIERFU0NdO1xuICB9XG4gIHZhciBpbmRleCA9IGRpcmVjdGlvbk9wdGlvbnMuaW5kZXhPZihkaXJlY3Rpb24pO1xuICByZXR1cm4gZGlyZWN0aW9uT3B0aW9uc1soaW5kZXggKyAxKSAlIGRpcmVjdGlvbk9wdGlvbnMubGVuZ3RoXTtcbn07XG5leHBvcnRzLm5leHRTb3J0RGlyZWN0aW9uID0gbmV4dFNvcnREaXJlY3Rpb247XG52YXIgREVGQVVMVF9IRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1IgPSBIRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1IuSVM7XG5leHBvcnRzLkRFRkFVTFRfSEVBVE1BUF9GT1JfVVJMX09QRVJBVE9SID0gREVGQVVMVF9IRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1I7XG52YXIgREVGQVVMVF9JTlNJR0hUU19IRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1IgPSBIRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1IuSFJFRl9MSUtFO1xuZXhwb3J0cy5ERUZBVUxUX0lOU0lHSFRTX0hFQVRNQVBfRk9SX1VSTF9PUEVSQVRPUiA9IERFRkFVTFRfSU5TSUdIVFNfSEVBVE1BUF9GT1JfVVJMX09QRVJBVE9SO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9tb2JpbGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvY29uc3RhbnRzL21vYmlsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5NQVhJTVVNX1NVUFBPUlRFRF9WRVJTSU9OID0gZXhwb3J0cy5NSU5JTVVNX1NVUFBPUlRFRF9WRVJTSU9OID0gZXhwb3J0cy5JT1NfVkVSU0lPTiA9IGV4cG9ydHMuQU5EUk9JRF9WRVJTSU9OID0gdm9pZCAwO1xudmFyIEFORFJPSURfVkVSU0lPTiA9ICcxLjI1LjAnO1xuZXhwb3J0cy5BTkRST0lEX1ZFUlNJT04gPSBBTkRST0lEX1ZFUlNJT047XG52YXIgSU9TX1ZFUlNJT04gPSAnMS4yNS4wJztcblxuLy8gSW5jbHVzaXZlXG5leHBvcnRzLklPU19WRVJTSU9OID0gSU9TX1ZFUlNJT047XG52YXIgTUlOSU1VTV9TVVBQT1JURURfVkVSU0lPTiA9ICcxLjAuMCc7XG4vLyBFeGNsdXNpdmVcbmV4cG9ydHMuTUlOSU1VTV9TVVBQT1JURURfVkVSU0lPTiA9IE1JTklNVU1fU1VQUE9SVEVEX1ZFUlNJT047XG52YXIgTUFYSU1VTV9TVVBQT1JURURfVkVSU0lPTiA9ICcxLjI2LjAnO1xuZXhwb3J0cy5NQVhJTVVNX1NVUFBPUlRFRF9WRVJTSU9OID0gTUFYSU1VTV9TVVBQT1JURURfVkVSU0lPTjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb25zdGFudHMvbnBzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9ucHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuREVMSUdIVEVEX0ZFRURCQUNLX1BSRUZJWCA9IGV4cG9ydHMuREVMSUdIVEVEX1JFU1BPTlNFU19SRUdFWCA9IGV4cG9ydHMuV09PVFJJQ19SRVNQT05TRVNfUkVHRVggPSB2b2lkIDA7XG52YXIgV09PVFJJQ19SRVNQT05TRVNfUkVHRVggPSAvXmh0dHBzOlxcL1xcL3Byb2R1Y3Rpb24ud29vdHJpYy5jb21cXC9yZXNwb25zZXMvO1xuZXhwb3J0cy5XT09UUklDX1JFU1BPTlNFU19SRUdFWCA9IFdPT1RSSUNfUkVTUE9OU0VTX1JFR0VYO1xudmFyIERFTElHSFRFRF9SRVNQT05TRVNfUkVHRVggPSAvXmh0dHBzOlxcL1xcL3dlYi5kZWxpZ2h0ZWQuY29tXFwvZVxcL1thLXpBLVotXSpcXC9jLztcbmV4cG9ydHMuREVMSUdIVEVEX1JFU1BPTlNFU19SRUdFWCA9IERFTElHSFRFRF9SRVNQT05TRVNfUkVHRVg7XG52YXIgREVMSUdIVEVEX0ZFRURCQUNLX1BSRUZJWCA9ICdjb21tZW50PSc7XG5leHBvcnRzLkRFTElHSFRFRF9GRUVEQkFDS19QUkVGSVggPSBERUxJR0hURURfRkVFREJBQ0tfUFJFRklYO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9yZXBsYXlUeXBlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9yZXBsYXlUeXBlcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlJFUExBWV9UWVBFID0gdm9pZCAwO1xudmFyIFJFUExBWV9UWVBFO1xuZXhwb3J0cy5SRVBMQVlfVFlQRSA9IFJFUExBWV9UWVBFO1xuKGZ1bmN0aW9uIChSRVBMQVlfVFlQRSkge1xuICBSRVBMQVlfVFlQRVtcIlNLSUFcIl0gPSBcIlNLSUFcIjtcbiAgUkVQTEFZX1RZUEVbXCJET01cIl0gPSBcIkRPTVwiO1xuICBSRVBMQVlfVFlQRVtcIlBERlwiXSA9IFwiUERGXCI7XG59KShSRVBMQVlfVFlQRSB8fCAoZXhwb3J0cy5SRVBMQVlfVFlQRSA9IFJFUExBWV9UWVBFID0ge30pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb25zdGFudHMvc2RrVHlwZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb25zdGFudHMvc2RrVHlwZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5TRVNTSU9OX1RZUEVfVE9fRElTUExBWSA9IGV4cG9ydHMuU0RLX1JFUExBWV9UWVBFID0gZXhwb3J0cy5TREtfVFlQRV9UT19ESVNQTEFZID0gZXhwb3J0cy5TREtfVFlQRSA9IHZvaWQgMDtcbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1wiKSk7XG52YXIgX3JlcGxheVR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZXBsYXlUeXBlcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvY29uc3RhbnRzL3JlcGxheVR5cGVzLnRzXCIpO1xudmFyIF9TREtfVFlQRV9UT19ESVNQTEFZLCBfU0RLX1JFUExBWV9UWVBFO1xuLypcbiAgU0RLX1RZUEUgc2hvdWxkIGJlIGltcG9ydGVkIGFzIFNFU1NJT05fVFlQRSBiYXNlZCBvbiBob3cgaXQgaXMgYmVpbmcgdXNlZC5cbiAgU0RLX1RZUEUgZW51bWVyYXRlcyB0aGUgc3VwcG9ydGVkIHNka1R5cGVzIGZyb20gYW4gaW5nZXN0aW9uL2ZpbHRlcmluZyBwZXJzcGVjdGl2ZS4gc2RrVHlwZSBpcyBhXG4gIHNlc3Npb24gZGF0YSBmaWVsZCBpbiBFUy5cbiAgU0VTU0lPTl9UWVBFIGlzIHVzZWQgdG8gZW51bWVyYXRlIHRoZSBzdXBwb3J0ZWQgc2Vzc2lvblR5cGVzIGZvciBzdHJpcGUgcGxhbnMsIHdoZXJlIHdlIGFyZVxuICBzZWxsaW5nIGFuZCBtYW5hZ2luZyB5b3VyIHF1b3RhIGJhc2VkIG9uIHRoZSBzZXNzaW9uVHlwZSBvZiB5b3VyIHN0cmlwZSBwbGFuLlxuKi9cbnZhciBTREtfVFlQRTtcbmV4cG9ydHMuU0RLX1RZUEUgPSBTREtfVFlQRTtcbihmdW5jdGlvbiAoU0RLX1RZUEUpIHtcbiAgU0RLX1RZUEVbXCJXRUJcIl0gPSBcIndlYlwiO1xuICBTREtfVFlQRVtcIk1PQklMRVwiXSA9IFwibW9iaWxlXCI7XG4gIFNES19UWVBFW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xufSkoU0RLX1RZUEUgfHwgKGV4cG9ydHMuU0RLX1RZUEUgPSBTREtfVFlQRSA9IHt9KSk7XG52YXIgU0RLX1RZUEVfVE9fRElTUExBWSA9IChfU0RLX1RZUEVfVE9fRElTUExBWSA9IHt9LCAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShfU0RLX1RZUEVfVE9fRElTUExBWSwgU0RLX1RZUEUuV0VCLCAnV2ViJyksICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKF9TREtfVFlQRV9UT19ESVNQTEFZLCBTREtfVFlQRS5NT0JJTEUsICdNb2JpbGUnKSwgX1NES19UWVBFX1RPX0RJU1BMQVkpO1xuZXhwb3J0cy5TREtfVFlQRV9UT19ESVNQTEFZID0gU0RLX1RZUEVfVE9fRElTUExBWTtcbnZhciBTREtfUkVQTEFZX1RZUEUgPSAoX1NES19SRVBMQVlfVFlQRSA9IHt9LCAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShfU0RLX1JFUExBWV9UWVBFLCBTREtfVFlQRS5XRUIsIF9yZXBsYXlUeXBlcy5SRVBMQVlfVFlQRS5ET00pLCAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShfU0RLX1JFUExBWV9UWVBFLCBTREtfVFlQRS5NT0JJTEUsIF9yZXBsYXlUeXBlcy5SRVBMQVlfVFlQRS5TS0lBKSwgX1NES19SRVBMQVlfVFlQRSk7XG5leHBvcnRzLlNES19SRVBMQVlfVFlQRSA9IFNES19SRVBMQVlfVFlQRTtcbnZhciBTRVNTSU9OX1RZUEVfVE9fRElTUExBWSA9IFNES19UWVBFX1RPX0RJU1BMQVk7XG5leHBvcnRzLlNFU1NJT05fVFlQRV9UT19ESVNQTEFZID0gU0VTU0lPTl9UWVBFX1RPX0RJU1BMQVk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvY29uc3RhbnRzL3N0YXR1c0NvZGVzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvY29uc3RhbnRzL3N0YXR1c0NvZGVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZ2V0U3RhdHVzVGV4dCA9IGdldFN0YXR1c1RleHQ7XG5leHBvcnRzLlNUQVRVU19DT0RFUyA9IHZvaWQgMDtcbi8vIHN0YXR1cyBjb2RlcyB2aWEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXNcblxudmFyIFNUQVRVU19DT0RFUyA9IHtcbiAgMDogJycsXG4gIDEwMDogJ0NvbnRpbnVlJyxcbiAgMTAxOiAnU3dpdGNoaW5nIFByb3RvY29sJyxcbiAgMTAyOiAnUHJvY2Vzc2luZycsXG4gIDEwMzogJ0Vhcmx5IEhpbnRzJyxcbiAgMjAwOiAnT0snLFxuICAyMDE6ICdDcmVhdGVkJyxcbiAgMjAyOiAnQWNjZXB0ZWQnLFxuICAyMDM6ICdOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvbicsXG4gIDIwNDogJ05vIENvbnRlbnQnLFxuICAyMDU6ICdSZXNldCBDb250ZW50JyxcbiAgMjA2OiAnUGFydGlhbCBDb250ZW50JyxcbiAgMjA3OiAnTXVsdGktU3RhdHVzJyxcbiAgMjA4OiAnQWxyZWFkeSBSZXBvcnRlZCcsXG4gIDIyNjogJ0lNIFVzZWQnLFxuICAzMDA6ICdNdWx0aXBsZSBDaG9pY2VzJyxcbiAgMzAxOiAnTW92ZWQgUGVybWFuZW50bHknLFxuICAzMDI6ICdGb3VuZCcsXG4gIDMwMzogJ1NlZSBPdGhlcicsXG4gIDMwNDogJ05vdCBNb2RpZmllZCcsXG4gIDMwNTogJ1VzZSBQcm94eScsXG4gIDMwNjogJ3VudXNlZCcsXG4gIDMwNzogJ1RlbXBvcmFyeSBSZWRpcmVjdCcsXG4gIDMwODogJ1Blcm1hbmVudCBSZWRpcmVjdCcsXG4gIDQwMDogJ0JhZCBSZXF1ZXN0JyxcbiAgNDAxOiAnVW5hdXRob3JpemVkJyxcbiAgNDAyOiAnUGF5bWVudCBSZXF1aXJlZCcsXG4gIDQwMzogJ0ZvcmJpZGRlbicsXG4gIDQwNDogJ05vdCBGb3VuZCcsXG4gIDQwNTogJ01ldGhvZCBOb3QgQWxsb3dlZCcsXG4gIDQwNjogJ05vdCBBY2NlcHRhYmxlJyxcbiAgNDA3OiAnUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnLFxuICA0MDg6ICdSZXF1ZXN0IFRpbWVvdXQnLFxuICA0MDk6ICdDb25mbGljdCcsXG4gIDQxMDogJ0dvbmUnLFxuICA0MTE6ICdMZW5ndGggUmVxdWlyZWQnLFxuICA0MTI6ICdQcmVjb25kaXRpb24gRmFpbGVkJyxcbiAgNDEzOiAnUGF5bG9hZCBUb28gTGFyZ2UnLFxuICA0MTQ6ICdVUkkgVG9vIExvbmcnLFxuICA0MTU6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgNDE2OiAnUmFuZ2UgTm90IFNhdGlzZmlhYmxlJyxcbiAgNDE3OiAnRXhwZWN0YXRpb24gRmFpbGVkJyxcbiAgNDE4OiAnSVxcJ20gYSB0ZWFwb3QnLFxuICA0MjE6ICdNaXNkaXJlY3RlZCBSZXF1ZXN0JyxcbiAgNDIyOiAnVW5wcm9jZXNzYWJsZSBFbnRpdHknLFxuICA0MjM6ICdMb2NrZWQnLFxuICA0MjQ6ICdGYWlsZWQgRGVwZW5kZW5jeScsXG4gIDQyNTogJ1RvbyBFYXJseScsXG4gIDQyNjogJ1VwZ3JhZGUgUmVxdWlyZWQnLFxuICA0Mjg6ICdQcmVjb25kaXRpb24gUmVxdWlyZWQnLFxuICA0Mjk6ICdUb28gTWFueSBSZXF1ZXN0cycsXG4gIDQzMTogJ1JlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2UnLFxuICA0NTE6ICdVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29ucycsXG4gIDUwMDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gIDUwMTogJ05vdCBJbXBsZW1lbnRlZCcsXG4gIDUwMjogJ0JhZCBHYXRld2F5JyxcbiAgNTAzOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gIDUwNDogJ0dhdGV3YXkgVGltZW91dCcsXG4gIDUwNTogJ0hUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkJyxcbiAgNTA2OiAnVmFyaWFudCBBbHNvIE5lZ290aWF0ZXMnLFxuICA1MDc6ICdJbnN1ZmZpY2llbnQgU3RvcmFnZScsXG4gIDUwODogJ0xvb3AgRGV0ZWN0ZWQnLFxuICA1MTA6ICdOb3QgRXh0ZW5kZWQnLFxuICA1MTE6ICdOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJ1xufTtcbmV4cG9ydHMuU1RBVFVTX0NPREVTID0gU1RBVFVTX0NPREVTO1xuZnVuY3Rpb24gZ2V0U3RhdHVzVGV4dChzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBTVEFUVVNfQ09ERVNbU3RyaW5nKHN0YXR1c0NvZGUpXTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb250YWlucy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvY29udGFpbnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbnRhaW5zO1xuZnVuY3Rpb24gY29udGFpbnModmFsdWUsIHNlYXJjaCkge1xuICByZXR1cm4gdmFsdWUgJiYgc2VhcmNoICYmIHZhbHVlLmluZGV4T2Yoc2VhcmNoKSA+IC0xO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2RlZXBBcnNvbmlmeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2RlZXBBcnNvbmlmeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlZXBBcnNvbmlmeTtcbnZhciBBUlNPTiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIEBsb2dyb2NrZXQvYXJzb24gKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvYXJzb24vc3JjL2luZGV4LmpzXCIpKTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5mdW5jdGlvbiBkZWVwQXJzb25pZnkoZGF0YSkge1xuICByZXR1cm4ge1xuICAgIC8vIHRhYmxlOiBBcnNvbi50b1RhYmxlKGRhdGEpLm1hcChzaGFsbG93QXJzb25pZnkpLFxuICAgIGFyc29uOiBBUlNPTi5lbmNvZGUoZGF0YSlcbiAgfTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9kZWVwRGVhcnNvbmlmeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZGVlcERlYXJzb25pZnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlZXBEZWFyc29uaWZ5O1xudmFyIEFSU09OID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGxvZ3JvY2tldC9hcnNvbiAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC9hcnNvbi9zcmMvaW5kZXguanNcIikpO1xuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIGRlZXBEZWFyc29uaWZ5KGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIEFSU09OLmRlY29kZShkYXRhLmFyc29uKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9lbmRzV2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZW5kc1dpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGVuZHNXaXRoO1xuZnVuY3Rpb24gZW5kc1dpdGgodmFsdWUsIHNlYXJjaCkge1xuICByZXR1cm4gdmFsdWUgJiYgc2VhcmNoICYmIHZhbHVlLnN1YnN0cmluZyh2YWx1ZS5sZW5ndGggLSBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2VuaGFuY2VGdW5jLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9lbmhhbmNlRnVuYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZW5oYW5jZUZ1bmM7XG4vKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IFtcImVycm9yXCIsIHsgXCJwcm9wc1wiOiBmYWxzZSB9XSAqL1xuXG5mdW5jdGlvbiBlbmhhbmNlRnVuYyhvYmosIG1ldGhvZCwgaGFuZGxlcikge1xuICB2YXIgb3JpZ2luYWwgPSBvYmpbbWV0aG9kXTtcbiAgZnVuY3Rpb24gc2hpbSgpIHtcbiAgICB2YXIgcmVzO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsKSB7XG4gICAgICByZXMgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIG9ialttZXRob2RdID0gc2hpbTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBvYmpbbWV0aG9kXSA9IG9yaWdpbmFsO1xuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2ZpbmQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZmluZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmaW5kO1xuZnVuY3Rpb24gZmluZChhcnJheSwgcHJlZGljYXRlKSB7XG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGFycmF5Lmxlbmd0aDsgaWR4KyspIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2lkeF0pKSB7XG4gICAgICByZXR1cm4gYXJyYXlbaWR4XTtcbiAgICB9XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9maW5kSW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9maW5kSW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmaW5kSW5kZXg7XG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSkge1xuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBhcnJheS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpZHhdKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2ZpbmRLZXlGcmFtZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZmluZEtleUZyYW1lcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmaW5kS2V5RnJhbWVzO1xudmFyIF9zb3J0ZWRMYXN0SW5kZXhCeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL3NvcnRlZExhc3RJbmRleEJ5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvc29ydGVkTGFzdEluZGV4QnkuanNcIikpO1xuLyoqXG4gKiBHaXZlIGFuIGFycmF5IG9mIHRpbWVkIGV2ZW50cyBhbmQgYSB0aW1lLCBmaW5kIHRoZSBhcnJheSBlbGVtZW50XG4gKiBiZWZvcmUgYW5kIGFmdGVyIHRoYXQgdGltZSBhbmQgdGhlIHByb2dyZXNzIGJldHdlZW4gdGhlIGZyYW1lcyAoMCB0byAxKVxuICovXG5mdW5jdGlvbiBmaW5kS2V5RnJhbWVzKGZ1dHVyZXMsIHRpbWUpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgIF9yZWYkc2RrVGhyb3R0bGUgPSBfcmVmLnNka1Rocm90dGxlLFxuICAgIHNka1Rocm90dGxlID0gX3JlZiRzZGtUaHJvdHRsZSA9PT0gdm9pZCAwID8gNTAwIDogX3JlZiRzZGtUaHJvdHRsZTtcbiAgaWYgKCFmdXR1cmVzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpbmRleCA9ICgwLCBfc29ydGVkTGFzdEluZGV4QnkuZGVmYXVsdCkoZnV0dXJlcywge1xuICAgIHRpbWU6IHRpbWVcbiAgfSwgJ3RpbWUnKTtcbiAgdmFyIG5leHQgPSBmdXR1cmVzW2luZGV4XSB8fCBmdXR1cmVzW2luZGV4IC0gMV07XG4gIHZhciBwcmV2ID0gZnV0dXJlc1tpbmRleCAtIDFdIHx8IG5leHQ7XG5cbiAgLy8gRG8gbm90IGNvbnNpZGVyIGV2ZW50cyBmdXJ0aGVyIHRoYW4gYHRocm90dGxlYCB0aW1lIGF3YXkgdG8gYmUgYWN0aXZlLlxuICAvLyBUaGlzIHByZXZlbnRzIHRoZSBzbG93LWRyaWZ0IGVmZmVjdC5cbiAgdmFyIHRvdGFsVGltZSA9IE1hdGgubWluKG5leHQudGltZSAtIHByZXYudGltZSwgc2RrVGhyb3R0bGUpO1xuICB2YXIgZXhwaXJlZCA9IE1hdGgubWF4KHRpbWUgLSAobmV4dC50aW1lIC0gdG90YWxUaW1lKSwgMCk7XG4gIHZhciByYXRpbyA9IHRvdGFsVGltZSA9PT0gMCA/IDEgOiBNYXRoLm1pbihleHBpcmVkIC8gdG90YWxUaW1lLCAxKTtcbiAgcmV0dXJuIHtcbiAgICBwcmV2OiBwcmV2LFxuICAgIG5leHQ6IG5leHQsXG4gICAgcmF0aW86IHJhdGlvXG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZmxhdHRlbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9mbGF0dGVuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZsYXR0ZW47XG5mdW5jdGlvbiBmbGF0dGVuKGFjYywgY3VycmVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChjdXJyZW50KTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9nZXRDc3NSdWxlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZ2V0Q3NzUnVsZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmdldENzc1J1bGUgPSBleHBvcnRzLmdldENzc1J1bGVzID0gdm9pZCAwO1xudmFyIGdldENzc1J1bGVzID0gZnVuY3Rpb24gZ2V0Q3NzUnVsZXMoc2hlZXRPclJ1bGUpIHtcbiAgdHJ5IHtcbiAgICAvLyBDaHJvbWUgNjQgd29uJ3QgbGV0IHlvdSBjaGVjayBzaGVldC5ydWxlcyB3aXRob3V0IHRocm93aW5nIGlmIHRoZXkncmUgdW5hdmFpbGFibGVcbiAgICAvLyBhbmQgRmlyZWZveCB1c2VzIGNzc1J1bGVzXG4gICAgdmFyIGNzc1J1bGVzID0gc2hlZXRPclJ1bGUuY3NzUnVsZXM7XG4gICAgaWYgKCFjc3NSdWxlcyAmJiBzaGVldE9yUnVsZSBpbnN0YW5jZW9mIENTU1N0eWxlU2hlZXQpIHtcbiAgICAgIHJldHVybiBzaGVldE9yUnVsZS5ydWxlcztcbiAgICB9XG4gICAgcmV0dXJuIGNzc1J1bGVzO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBjYXRjaCBET01FeGNwZXRpb24gb3IgU2VjdXJpdHlFeGNlcHRpb24gZnJvbSBhdHRlbXB0aW5nIHRvIGFjY2VzcyBzaGVldE9yUnVsZS5jc3NSdWxlc1xuICAgIC8vICBvbiBhIGNyb3NzIG9yaWdpbiBob3N0ZWQgc3R5bGVzaGVldC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbmV4cG9ydHMuZ2V0Q3NzUnVsZXMgPSBnZXRDc3NSdWxlcztcbnZhciBnZXRDc3NSdWxlID0gZnVuY3Rpb24gZ2V0Q3NzUnVsZShzaGVldE9yUnVsZSwgcnVsZUluZGV4KSB7XG4gIHZhciBydWxlcyA9IGdldENzc1J1bGVzKHNoZWV0T3JSdWxlKTtcbiAgaWYgKCFydWxlcyB8fCBydWxlSW5kZXggPj0gcnVsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJ1bGVzLml0ZW0ocnVsZUluZGV4KTtcbn07XG5leHBvcnRzLmdldENzc1J1bGUgPSBnZXRDc3NSdWxlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2dldEdyYXBoUUxPcGVyYXRpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZ2V0R3JhcGhRTE9wZXJhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBnZXRHcmFwaFFMT3BlcmF0aW9uO1xuZnVuY3Rpb24gZ2V0R3JhcGhRTE9wZXJhdGlvbihib2R5KSB7XG4gIGlmIChib2R5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwYXJzZWRCb2R5ID0gdHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShib2R5KSA6IGJvZHk7XG4gICAgICB2YXIgcXVlcnkgPSBwYXJzZWRCb2R5LnF1ZXJ5LnRyaW0oKTtcbiAgICAgIHZhciBtYXRjaCA9IHF1ZXJ5Lm1hdGNoKC8ocXVlcnl8bXV0YXRpb24pIChbYS16Xy1dKykvaSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wZXJhdGlvblR5cGU6IG1hdGNoWzFdLFxuICAgICAgICBvcGVyYXRpb25OYW1lOiBtYXRjaFsyXVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9nZXRNb2NrRGV2ZWxvcGVyVXNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZ2V0TW9ja0RldmVsb3BlclVzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGdldE1vY2tEZXZlbG9wZXJVc2VyO1xuZnVuY3Rpb24gZ2V0TW9ja0RldmVsb3BlclVzZXIoKSB7XG4gIHJldHVybiB7XG4gICAgcGVybWlzc2lvbnM6IHtcbiAgICAgIGRhc2hib2FyZDoge1xuICAgICAgICBtZXRyaWNzOiB0cnVlLFxuICAgICAgICBlcnJvcnM6IHRydWVcbiAgICAgIH0sXG4gICAgICBzZXNzaW9uUGxheWJhY2s6IHtcbiAgICAgICAgZGV2ZWxvcGVyUGFuZToge1xuICAgICAgICAgIG5ldHdvcmtQYW5lOiB7XG4gICAgICAgICAgICByZXF1ZXN0Qm9kaWVzQW5kSGVhZGVyczogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYXBwUm9sZXM6IFtdXG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZ2V0Tm9kZVNlbGVjdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZ2V0Tm9kZVNlbGVjdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIF9wcm90ZWN0RnVuYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcm90ZWN0RnVuYyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcHJvdGVjdEZ1bmMuanNcIikpO1xudmFyIGdldE5vZGVTZWxlY3RvciA9ICgwLCBfcHJvdGVjdEZ1bmMuZGVmYXVsdCkoZnVuY3Rpb24gKG5vZGUpIHtcbiAgLy8gbm9kZU5hbWUgc29tZXRpbWVzIHJldHVybnMgbnVsbFxuICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gIHZhciBzZWxlY3RvciA9IHtcbiAgICBub2RlTmFtZTogbm9kZU5hbWVcbiAgfTtcbiAgaWYgKG5vZGUuaWQgJiYgbm9kZS5pZC5sZW5ndGggPiAwKSB7XG4gICAgc2VsZWN0b3IuaWQgPSBub2RlLmlkO1xuICB9XG4gIGlmIChub2RlLmNsYXNzTGlzdCAmJiBub2RlLmNsYXNzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgc2VsZWN0b3IuY2xhc3NMaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZS5jbGFzc0xpc3QsIDApO1xuICB9XG4gIHJldHVybiBzZWxlY3Rvcjtcbn0pO1xudmFyIF9kZWZhdWx0ID0gZ2V0Tm9kZVNlbGVjdG9yO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9oYXNoU3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2hhc2hTdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY29tYmluZUhhc2hlcyA9IGV4cG9ydHMuaGFzaFN0cmluZyA9IHZvaWQgMDtcbnZhciBfcHJvdGVjdEZ1bmMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHJvdGVjdEZ1bmMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3Byb3RlY3RGdW5jLmpzXCIpKTtcbnZhciBfc2VuZFRlbGVtZXRyeURhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NlbmRUZWxlbWV0cnlEYXRhICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9zZW5kVGVsZW1ldHJ5RGF0YS5qc1wiKTtcbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLy8gSmF2YSdzIFN0cmluZzo6aGFzaENvZGVcbi8vIGh0dHBzOi8vZGV2ZG9jcy5pby9vcGVuamRrfjgvamF2YS9sYW5nL3N0cmluZyNoYXNoQ29kZS0tXG52YXIgaGFzaFN0cmluZyA9ICgwLCBfcHJvdGVjdEZ1bmMuZGVmYXVsdCkoZnVuY3Rpb24gKHN0cikge1xuICB0cnkge1xuICAgIHZhciBoYXNoID0gMDtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIC8vIEZvcmNlIGhhc2ggdG8gc3RheSBpbiBhIDMyIGJpdCBpbnRlZ2VyIHNvIGJpdHNoaWZ0aW5nIHdvcmtzXG4gICAgICAgIGhhc2ggfD0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgICgwLCBfc2VuZFRlbGVtZXRyeURhdGEuc2VuZFRlbGVtZXRyeSkoJ0ZhaWxlZCB0byBoYXNoIHN0cmluZycsIHtcbiAgICAgIGV4dHJhOiB7XG4gICAgICAgIHN0cjogc3RyXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0pO1xuXG4vLyBCb29zdCdzIGhhc2hfY29tYmluZVxuZXhwb3J0cy5oYXNoU3RyaW5nID0gaGFzaFN0cmluZztcbnZhciBjb21iaW5lSGFzaGVzID0gZnVuY3Rpb24gY29tYmluZUhhc2hlcyhoYXNoZXMpIHtcbiAgdmFyIG91dCA9IGhhc2hlcy5zaGlmdCgpIHx8IDA7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihoYXNoZXMpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaGFzaCA9IF9zdGVwLnZhbHVlO1xuICAgICAgb3V0IF49IGhhc2ggKyAweDllMzc3OWI5ICsgKG91dCA8PCA2KSArIChvdXQgPj4gMik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuZXhwb3J0cy5jb21iaW5lSGFzaGVzID0gY29tYmluZUhhc2hlcztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9pZGVudGl0eVN0YXR1cy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvaWRlbnRpdHlTdGF0dXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLnBhcnNlSWRlbnRpdHlTdGF0dXMgPSBwYXJzZUlkZW50aXR5U3RhdHVzO1xuZXhwb3J0cy5JZGVudGl0eVN0YXR1cyA9IHZvaWQgMDtcbnZhciBJZGVudGl0eVN0YXR1cztcbmV4cG9ydHMuSWRlbnRpdHlTdGF0dXMgPSBJZGVudGl0eVN0YXR1cztcbihmdW5jdGlvbiAoSWRlbnRpdHlTdGF0dXMpIHtcbiAgSWRlbnRpdHlTdGF0dXNbSWRlbnRpdHlTdGF0dXNbXCJVbmtub3duXCJdID0gMF0gPSBcIlVua25vd25cIjtcbiAgSWRlbnRpdHlTdGF0dXNbSWRlbnRpdHlTdGF0dXNbXCJBbm9ueW1vdXNcIl0gPSAxXSA9IFwiQW5vbnltb3VzXCI7XG4gIElkZW50aXR5U3RhdHVzW0lkZW50aXR5U3RhdHVzW1wiSWRlbnRpZmllZFwiXSA9IDJdID0gXCJJZGVudGlmaWVkXCI7XG59KShJZGVudGl0eVN0YXR1cyB8fCAoZXhwb3J0cy5JZGVudGl0eVN0YXR1cyA9IElkZW50aXR5U3RhdHVzID0ge30pKTtcbmZ1bmN0aW9uIHBhcnNlSWRlbnRpdHlTdGF0dXModmFsKSB7XG4gIGlmICghdmFsKSB7XG4gICAgcmV0dXJuIElkZW50aXR5U3RhdHVzLlVua25vd247XG4gIH1cbiAgc3dpdGNoIChwYXJzZUludCh2YWwsIDEwKSkge1xuICAgIGNhc2UgSWRlbnRpdHlTdGF0dXMuQW5vbnltb3VzOlxuICAgICAgcmV0dXJuIElkZW50aXR5U3RhdHVzLkFub255bW91cztcbiAgICBjYXNlIElkZW50aXR5U3RhdHVzLklkZW50aWZpZWQ6XG4gICAgICByZXR1cm4gSWRlbnRpdHlTdGF0dXMuSWRlbnRpZmllZDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIElkZW50aXR5U3RhdHVzLlVua25vd247XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG52YXIgX3R5cGVvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG52YXIgX2V4cG9ydE5hbWVzID0ge1xuICBlbmhhbmNlRnVuYzogdHJ1ZSxcbiAgc2hhbGxvd0Fyc29uaWZ5OiB0cnVlLFxuICBzaGFsbG93RGVhcnNvbmlmeTogdHJ1ZSxcbiAgZGVlcEFyc29uaWZ5OiB0cnVlLFxuICBkZWVwRGVhcnNvbmlmeTogdHJ1ZSxcbiAgYWRkTGlzdGVuZXI6IHRydWUsXG4gIHByb3RlY3RGdW5jOiB0cnVlLFxuICBmaW5kSW5kZXg6IHRydWUsXG4gIGZpbmQ6IHRydWUsXG4gIGZsYXR0ZW46IHRydWUsXG4gIHNlbGVjdG9yTWF0Y2hlczogdHJ1ZSxcbiAgcGFyc2VTZWxlY3RvckZvck1hdGNoOiB0cnVlLFxuICBxdWVyeVNlbGVjdG9yV2l0aFNoYWRvd0RvbTogdHJ1ZSxcbiAgc2VuZEVycm9yVGVsZW1ldHJ5OiB0cnVlLFxuICBzZW5kVGVsZW1ldHJ5OiB0cnVlLFxuICBzYW5pdGl6ZVZhbHVlOiB0cnVlLFxuICBhZGp1c3RPczogdHJ1ZSxcbiAgYWRqdXN0T3NWZXJzaW9uOiB0cnVlLFxuICBzZWxlY3RvckZyb21Ob2RlUGF0aDogdHJ1ZSxcbiAgc3RhcnRzV2l0aDogdHJ1ZSxcbiAgZW5kc1dpdGg6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICB1dWlkOiB0cnVlLFxuICByYW5kb21JbnQ6IHRydWUsXG4gIGdldENzc1J1bGVzOiB0cnVlLFxuICBnZXRDc3NSdWxlOiB0cnVlLFxuICBnZXROb2RlU2VsZWN0b3I6IHRydWUsXG4gIGdldEdyYXBoUUxPcGVyYXRpb246IHRydWUsXG4gIGlzU2Vzc2lvbkV2ZW50OiB0cnVlLFxuICBpc0FjdGl2aXR5RXZlbnQ6IHRydWUsXG4gIHBhcnNlSW50RnJvbUhleDogdHJ1ZSxcbiAgaXNSZWNvcmRpbmdTYW1wbGVkOiB0cnVlLFxuICBtYWtlUmVjb3JkaW5nSUQ6IHRydWUsXG4gIHNldEZyb21BcnJheTogdHJ1ZSxcbiAgc2V0VG9BcnJheTogdHJ1ZSxcbiAgYXBwbHlVcmxTYW5pdGl6ZXI6IHRydWUsXG4gIGdldE1vY2tEZXZlbG9wZXJVc2VyOiB0cnVlLFxuICBtYXliZUNsZWFuU3dpZnRVSUNsYXNzTmFtZTogdHJ1ZSxcbiAgTE9HX0ZJTFRFUl9UWVBFUzogdHJ1ZSxcbiAgTE9HX1RZUEVTOiB0cnVlLFxuICBNRVRSSUNfVElNRVNFUklFU19UWVBFOiB0cnVlLFxuICBIRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1I6IHRydWUsXG4gIERFRkFVTFRfSEVBVE1BUF9GT1JfVVJMX09QRVJBVE9SOiB0cnVlLFxuICBERUZBVUxUX0lOU0lHSFRTX0hFQVRNQVBfRk9SX1VSTF9PUEVSQVRPUjogdHJ1ZSxcbiAgU09SVF9ESVJFQ1RJT046IHRydWUsXG4gIEZFRURCQUNLX1NPUlRfQ09MVU1OOiB0cnVlLFxuICBNRVRSSUNfUkVURU5USU9OX1RZUEU6IHRydWUsXG4gIElTU1VFX1RZUEU6IHRydWUsXG4gIElTU1VFX0dST1VQX1RZUEU6IHRydWUsXG4gIEVTX0lTU1VFX1RZUEVfQkFTRV9GSUxURVI6IHRydWUsXG4gIEVTX0lTU1VFX1RZUEVTOiB0cnVlLFxuICBmaW5kS2V5RnJhbWVzOiB0cnVlLFxuICBpbnRlcnBvbGF0ZTogdHJ1ZSxcbiAgaW50ZXJwb2xhdGVNb2JpbGU6IHRydWUsXG4gIHJlbW92ZU91dGRhdGVkOiB0cnVlLFxuICBERUxJR0hURURfUkVTUE9OU0VTX1JFR0VYOiB0cnVlLFxuICBXT09UUklDX1JFU1BPTlNFU19SRUdFWDogdHJ1ZSxcbiAgUkVQTEFZX1RZUEU6IHRydWUsXG4gIFNES19SRVBMQVlfVFlQRTogdHJ1ZSxcbiAgU0RLX1RZUEU6IHRydWUsXG4gIFNES19UWVBFX1RPX0RJU1BMQVk6IHRydWUsXG4gIFNFU1NJT05fVFlQRV9UT19ESVNQTEFZOiB0cnVlLFxuICBTVEFUVVNfQ09ERVM6IHRydWUsXG4gIGdldFN0YXR1c1RleHQ6IHRydWUsXG4gIHBhcnNlUXVlcnlTdHJpbmc6IHRydWUsXG4gIGxpa2VPcGVyYXRvcjogdHJ1ZSxcbiAgc2Nyb2xsTWFwSGlzdG9ncmFtVG9QZXJjZW50OiB0cnVlLFxuICBjb21iaW5lSGFzaGVzOiB0cnVlLFxuICBoYXNoU3RyaW5nOiB0cnVlLFxuICBlbmNvZGVVc2VyVHJhaXRTdHJpbmc6IHRydWUsXG4gIHBhcnNlVXNlclRyYWl0U3RyaW5nOiB0cnVlLFxuICBJZGVudGl0eVN0YXR1czogdHJ1ZSxcbiAgcGFyc2VJZGVudGl0eVN0YXR1czogdHJ1ZSxcbiAgc2NydWJFeGNlcHRpb246IHRydWUsXG4gIE1vYmlsZUNvbnN0YW50czogdHJ1ZVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuaGFuY2VGdW5jXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5oYW5jZUZ1bmMuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhbGxvd0Fyc29uaWZ5XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2hhbGxvd0Fyc29uaWZ5LmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYWxsb3dEZWFyc29uaWZ5XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2hhbGxvd0RlYXJzb25pZnkuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVlcEFyc29uaWZ5XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZGVlcEFyc29uaWZ5LmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZXBEZWFyc29uaWZ5XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZGVlcERlYXJzb25pZnkuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkTGlzdGVuZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lci5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm90ZWN0RnVuY1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3Byb3RlY3RGdW5jLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZpbmRJbmRleFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZpbmRJbmRleC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmaW5kXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmluZC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmbGF0dGVuXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmxhdHRlbi5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxlY3Rvck1hdGNoZXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zZWxlY3Rvck1hdGNoZXMuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VTZWxlY3RvckZvck1hdGNoXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGFyc2VTZWxlY3RvckZvck1hdGNoLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInF1ZXJ5U2VsZWN0b3JXaXRoU2hhZG93RG9tXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcXVlcnlTZWxlY3RvcldpdGhTaGFkb3dEb20uZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VuZEVycm9yVGVsZW1ldHJ5XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2VuZFRlbGVtZXRyeURhdGEuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VuZFRlbGVtZXRyeVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NlbmRUZWxlbWV0cnlEYXRhLnNlbmRUZWxlbWV0cnk7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNhbml0aXplVmFsdWVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zYW5pdGl6ZVZhbHVlLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkanVzdE9zXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYWRqdXN0T3NWZXJzaW9uLmFkanVzdE9zO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGp1c3RPc1ZlcnNpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hZGp1c3RPc1ZlcnNpb24uYWRqdXN0T3NWZXJzaW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxlY3RvckZyb21Ob2RlUGF0aFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NlbGVjdG9yRnJvbU5vZGVQYXRoLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0YXJ0c1dpdGhcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zdGFydHNXaXRoLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuZHNXaXRoXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5kc1dpdGguZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29udGFpbnNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb250YWlucy5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dWlkXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXVpZC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYW5kb21JbnRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yYW5kb21JbnQuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q3NzUnVsZXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRDc3NSdWxlcy5nZXRDc3NSdWxlcztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q3NzUnVsZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldENzc1J1bGVzLmdldENzc1J1bGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE5vZGVTZWxlY3RvclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldE5vZGVTZWxlY3Rvci5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRHcmFwaFFMT3BlcmF0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0R3JhcGhRTE9wZXJhdGlvbi5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1Nlc3Npb25FdmVudFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzU2Vzc2lvbkV2ZW50LmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQWN0aXZpdHlFdmVudFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzQWN0aXZpdHlFdmVudC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUludEZyb21IZXhcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZUludEZyb21IZXguZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNSZWNvcmRpbmdTYW1wbGVkXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNSZWNvcmRpbmdTYW1wbGVkLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VSZWNvcmRpbmdJRFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21ha2VSZWNvcmRpbmdJRC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRGcm9tQXJyYXlcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zZXRGcm9tQXJyYXkuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2V0VG9BcnJheVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NldFRvQXJyYXkuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlVcmxTYW5pdGl6ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcHBseVVybFNhbml0aXplci5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNb2NrRGV2ZWxvcGVyVXNlclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldE1vY2tEZXZlbG9wZXJVc2VyLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1heWJlQ2xlYW5Td2lmdFVJQ2xhc3NOYW1lXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWF5YmVDbGVhblN3aWZ0VUlDbGFzc05hbWUuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTE9HX0ZJTFRFUl9UWVBFU1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvZ1R5cGVzLkxPR19GSUxURVJfVFlQRVM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxPR19UWVBFU1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvZ1R5cGVzLkxPR19UWVBFUztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTUVUUklDX1RJTUVTRVJJRVNfVFlQRVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21ldHJpY3MuTUVUUklDX1RJTUVTRVJJRVNfVFlQRTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSEVBVE1BUF9GT1JfVVJMX09QRVJBVE9SXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWV0cmljcy5IRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1I7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFRkFVTFRfSEVBVE1BUF9GT1JfVVJMX09QRVJBVE9SXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWV0cmljcy5ERUZBVUxUX0hFQVRNQVBfRk9SX1VSTF9PUEVSQVRPUjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiREVGQVVMVF9JTlNJR0hUU19IRUFUTUFQX0ZPUl9VUkxfT1BFUkFUT1JcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tZXRyaWNzLkRFRkFVTFRfSU5TSUdIVFNfSEVBVE1BUF9GT1JfVVJMX09QRVJBVE9SO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTT1JUX0RJUkVDVElPTlwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21ldHJpY3MuU09SVF9ESVJFQ1RJT047XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZFRURCQUNLX1NPUlRfQ09MVU1OXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWV0cmljcy5GRUVEQkFDS19TT1JUX0NPTFVNTjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTUVUUklDX1JFVEVOVElPTl9UWVBFXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWV0cmljcy5NRVRSSUNfUkVURU5USU9OX1RZUEU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklTU1VFX1RZUEVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc3N1ZXMuSVNTVUVfVFlQRTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSVNTVUVfR1JPVVBfVFlQRVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzc3Vlcy5JU1NVRV9HUk9VUF9UWVBFO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFU19JU1NVRV9UWVBFX0JBU0VfRklMVEVSXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNzdWVzLkVTX0lTU1VFX1RZUEVfQkFTRV9GSUxURVI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVTX0lTU1VFX1RZUEVTXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNzdWVzLkVTX0lTU1VFX1RZUEVTO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmaW5kS2V5RnJhbWVzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmluZEtleUZyYW1lcy5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlcnBvbGF0ZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVycG9sYXRlLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludGVycG9sYXRlTW9iaWxlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVNb2JpbGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZU91dGRhdGVkXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmVtb3ZlT3V0ZGF0ZWQuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiREVMSUdIVEVEX1JFU1BPTlNFU19SRUdFWFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX25wcy5ERUxJR0hURURfUkVTUE9OU0VTX1JFR0VYO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXT09UUklDX1JFU1BPTlNFU19SRUdFWFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX25wcy5XT09UUklDX1JFU1BPTlNFU19SRUdFWDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUkVQTEFZX1RZUEVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZXBsYXlUeXBlcy5SRVBMQVlfVFlQRTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU0RLX1JFUExBWV9UWVBFXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2RrVHlwZXMuU0RLX1JFUExBWV9UWVBFO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTREtfVFlQRVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3Nka1R5cGVzLlNES19UWVBFO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTREtfVFlQRV9UT19ESVNQTEFZXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2RrVHlwZXMuU0RLX1RZUEVfVE9fRElTUExBWTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU0VTU0lPTl9UWVBFX1RPX0RJU1BMQVlcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zZGtUeXBlcy5TRVNTSU9OX1RZUEVfVE9fRElTUExBWTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1RBVFVTX0NPREVTXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc3RhdHVzQ29kZXMuU1RBVFVTX0NPREVTO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRTdGF0dXNUZXh0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc3RhdHVzQ29kZXMuZ2V0U3RhdHVzVGV4dDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VRdWVyeVN0cmluZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlUXVlcnlTdHJpbmcucGFyc2VRdWVyeVN0cmluZztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibGlrZU9wZXJhdG9yXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbGlrZU9wZXJhdG9yLmxpa2VPcGVyYXRvcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2Nyb2xsTWFwSGlzdG9ncmFtVG9QZXJjZW50XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2Nyb2xsTWFwSGlzdG9ncmFtVG9QZXJjZW50LmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbWJpbmVIYXNoZXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9oYXNoU3RyaW5nLmNvbWJpbmVIYXNoZXM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc2hTdHJpbmdcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9oYXNoU3RyaW5nLmhhc2hTdHJpbmc7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVVzZXJUcmFpdFN0cmluZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3VzZXJUcmFpdFN0cmluZ3MuZW5jb2RlVXNlclRyYWl0U3RyaW5nO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVVzZXJUcmFpdFN0cmluZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3VzZXJUcmFpdFN0cmluZ3MucGFyc2VVc2VyVHJhaXRTdHJpbmc7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklkZW50aXR5U3RhdHVzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaWRlbnRpdHlTdGF0dXMuSWRlbnRpdHlTdGF0dXM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlSWRlbnRpdHlTdGF0dXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pZGVudGl0eVN0YXR1cy5wYXJzZUlkZW50aXR5U3RhdHVzO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY3J1YkV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjcnViRXhjZXB0aW9uLnNjcnViRXhjZXB0aW9uO1xuICB9XG59KSk7XG5leHBvcnRzLk1vYmlsZUNvbnN0YW50cyA9IHZvaWQgMDtcbnZhciBfZW5oYW5jZUZ1bmMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW5oYW5jZUZ1bmMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2VuaGFuY2VGdW5jLmpzXCIpKTtcbnZhciBfc2hhbGxvd0Fyc29uaWZ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NoYWxsb3dBcnNvbmlmeSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2hhbGxvd0Fyc29uaWZ5LmpzXCIpKTtcbnZhciBfc2hhbGxvd0RlYXJzb25pZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2hhbGxvd0RlYXJzb25pZnkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3NoYWxsb3dEZWFyc29uaWZ5LmpzXCIpKTtcbnZhciBfZGVlcEFyc29uaWZ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RlZXBBcnNvbmlmeSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZGVlcEFyc29uaWZ5LmpzXCIpKTtcbnZhciBfZGVlcERlYXJzb25pZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVlcERlYXJzb25pZnkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2RlZXBEZWFyc29uaWZ5LmpzXCIpKTtcbnZhciBfYWRkTGlzdGVuZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWRkTGlzdGVuZXIgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2FkZExpc3RlbmVyLmpzXCIpKTtcbnZhciBfcHJvdGVjdEZ1bmMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHJvdGVjdEZ1bmMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3Byb3RlY3RGdW5jLmpzXCIpKTtcbnZhciBfZmluZEluZGV4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbmRJbmRleCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZmluZEluZGV4LmpzXCIpKTtcbnZhciBfZmluZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maW5kICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9maW5kLmpzXCIpKTtcbnZhciBfZmxhdHRlbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mbGF0dGVuICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9mbGF0dGVuLmpzXCIpKTtcbnZhciBfc2VsZWN0b3JNYXRjaGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NlbGVjdG9yTWF0Y2hlcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2VsZWN0b3JNYXRjaGVzLmpzXCIpKTtcbnZhciBfcGFyc2VTZWxlY3RvckZvck1hdGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhcnNlU2VsZWN0b3JGb3JNYXRjaCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcGFyc2VTZWxlY3RvckZvck1hdGNoLmpzXCIpKTtcbnZhciBfcXVlcnlTZWxlY3RvcldpdGhTaGFkb3dEb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcXVlcnlTZWxlY3RvcldpdGhTaGFkb3dEb20gKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3F1ZXJ5U2VsZWN0b3JXaXRoU2hhZG93RG9tLmpzXCIpKTtcbnZhciBfc2VuZFRlbGVtZXRyeURhdGEgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NlbmRUZWxlbWV0cnlEYXRhICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9zZW5kVGVsZW1ldHJ5RGF0YS5qc1wiKSk7XG52YXIgX3Nhbml0aXplVmFsdWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2FuaXRpemVWYWx1ZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2FuaXRpemVWYWx1ZS5qc1wiKSk7XG52YXIgX2FkanVzdE9zVmVyc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWRqdXN0T3NWZXJzaW9uICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9hZGp1c3RPc1ZlcnNpb24udHNcIik7XG52YXIgX3NlbGVjdG9yRnJvbU5vZGVQYXRoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NlbGVjdG9yRnJvbU5vZGVQYXRoICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9zZWxlY3RvckZyb21Ob2RlUGF0aC5qc1wiKSk7XG52YXIgX3N0YXJ0c1dpdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3RhcnRzV2l0aCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc3RhcnRzV2l0aC5qc1wiKSk7XG52YXIgX2VuZHNXaXRoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VuZHNXaXRoICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9lbmRzV2l0aC5qc1wiKSk7XG52YXIgX2NvbnRhaW5zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRhaW5zICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb250YWlucy5qc1wiKSk7XG52YXIgX3V1aWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXVpZCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvdXVpZC5qc1wiKSk7XG52YXIgX3JhbmRvbUludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yYW5kb21JbnQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3JhbmRvbUludC5qc1wiKSk7XG52YXIgX2dldENzc1J1bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRDc3NSdWxlcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZ2V0Q3NzUnVsZXMudHNcIik7XG52YXIgX2dldE5vZGVTZWxlY3RvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXROb2RlU2VsZWN0b3IgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2dldE5vZGVTZWxlY3Rvci5qc1wiKSk7XG52YXIgX2dldEdyYXBoUUxPcGVyYXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0R3JhcGhRTE9wZXJhdGlvbiAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZ2V0R3JhcGhRTE9wZXJhdGlvbi5qc1wiKSk7XG52YXIgX2lzU2Vzc2lvbkV2ZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzU2Vzc2lvbkV2ZW50ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9pc1Nlc3Npb25FdmVudC5qc1wiKSk7XG52YXIgX2lzQWN0aXZpdHlFdmVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FjdGl2aXR5RXZlbnQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2lzQWN0aXZpdHlFdmVudC5qc1wiKSk7XG52YXIgX3BhcnNlSW50RnJvbUhleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYXJzZUludEZyb21IZXggKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3BhcnNlSW50RnJvbUhleC5qc1wiKSk7XG52YXIgX2lzUmVjb3JkaW5nU2FtcGxlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1JlY29yZGluZ1NhbXBsZWQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2lzUmVjb3JkaW5nU2FtcGxlZC5qc1wiKSk7XG52YXIgX21ha2VSZWNvcmRpbmdJRCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYWtlUmVjb3JkaW5nSUQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL21ha2VSZWNvcmRpbmdJRC5qc1wiKSk7XG52YXIgX3NldEZyb21BcnJheSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZXRGcm9tQXJyYXkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3NldEZyb21BcnJheS5qc1wiKSk7XG52YXIgX3NldFRvQXJyYXkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2V0VG9BcnJheSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2V0VG9BcnJheS5qc1wiKSk7XG52YXIgX2FwcGx5VXJsU2FuaXRpemVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FwcGx5VXJsU2FuaXRpemVyICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9hcHBseVVybFNhbml0aXplci5qc1wiKSk7XG52YXIgX2dldE1vY2tEZXZlbG9wZXJVc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldE1vY2tEZXZlbG9wZXJVc2VyICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9nZXRNb2NrRGV2ZWxvcGVyVXNlci5qc1wiKSk7XG52YXIgX21heWJlQ2xlYW5Td2lmdFVJQ2xhc3NOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21heWJlQ2xlYW5Td2lmdFVJQ2xhc3NOYW1lICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9tYXliZUNsZWFuU3dpZnRVSUNsYXNzTmFtZS50c1wiKSk7XG52YXIgX2xvZ1R5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25zdGFudHMvbG9nVHlwZXMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9sb2dUeXBlcy5qc1wiKTtcbnZhciBfbWV0cmljcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzL21ldHJpY3MgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9tZXRyaWNzLmpzXCIpO1xudmFyIF9pc3N1ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50cy9pc3N1ZXMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9pc3N1ZXMudHNcIik7XG52YXIgX2ZpbmRLZXlGcmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmluZEtleUZyYW1lcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvZmluZEtleUZyYW1lcy5qc1wiKSk7XG52YXIgX2ludGVycG9sYXRlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcnBvbGF0ZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvaW50ZXJwb2xhdGUuanNcIikpO1xudmFyIF9yZW1vdmVPdXRkYXRlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZW1vdmVPdXRkYXRlZCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcmVtb3ZlT3V0ZGF0ZWQuanNcIikpO1xudmFyIF9ucHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50cy9ucHMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9ucHMuanNcIik7XG52YXIgX3JlcGxheVR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25zdGFudHMvcmVwbGF5VHlwZXMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2NvbnN0YW50cy9yZXBsYXlUeXBlcy50c1wiKTtcbnZhciBfc2RrVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50cy9zZGtUeXBlcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvY29uc3RhbnRzL3Nka1R5cGVzLnRzXCIpO1xudmFyIF9zdGF0dXNDb2RlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzL3N0YXR1c0NvZGVzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9jb25zdGFudHMvc3RhdHVzQ29kZXMudHNcIik7XG52YXIgX3BhcnNlUXVlcnlTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhcnNlUXVlcnlTdHJpbmcgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3BhcnNlUXVlcnlTdHJpbmcuanNcIik7XG52YXIgX2xpa2VPcGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGlrZU9wZXJhdG9yICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9saWtlT3BlcmF0b3IuanNcIik7XG52YXIgX3Njcm9sbE1hcEhpc3RvZ3JhbVRvUGVyY2VudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY3JvbGxNYXBIaXN0b2dyYW1Ub1BlcmNlbnQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3Njcm9sbE1hcEhpc3RvZ3JhbVRvUGVyY2VudC5qc1wiKSk7XG52YXIgX2hhc2hTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hhc2hTdHJpbmcgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2hhc2hTdHJpbmcuanNcIik7XG52YXIgX3VzZXJUcmFpdFN0cmluZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VzZXJUcmFpdFN0cmluZ3MgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3VzZXJUcmFpdFN0cmluZ3MudHNcIik7XG52YXIgX2lkZW50aXR5U3RhdHVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pZGVudGl0eVN0YXR1cyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvaWRlbnRpdHlTdGF0dXMudHNcIik7XG52YXIgX3NjcnViRXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY3J1YkV4Y2VwdGlvbiAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2NydWJFeGNlcHRpb24udHNcIik7XG52YXIgX01vYmlsZUNvbnN0YW50cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzL21vYmlsZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvY29uc3RhbnRzL21vYmlsZS50c1wiKSk7XG5leHBvcnRzLk1vYmlsZUNvbnN0YW50cyA9IF9Nb2JpbGVDb25zdGFudHM7XG52YXIgX2Jyb3dzZXJVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYnJvd3NlclV0aWxzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9icm93c2VyVXRpbHMuanNcIik7XG5PYmplY3Qua2V5cyhfYnJvd3NlclV0aWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfYnJvd3NlclV0aWxzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2Jyb3dzZXJVdGlsc1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfaXNWYWxpZEFwcElEID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1ZhbGlkQXBwSUQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2lzVmFsaWRBcHBJRC50c1wiKTtcbk9iamVjdC5rZXlzKF9pc1ZhbGlkQXBwSUQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pc1ZhbGlkQXBwSURba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfaXNWYWxpZEFwcElEW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9yZXF1aXJlVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlcXVpcmVWYWx1ZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcmVxdWlyZVZhbHVlLnRzXCIpO1xuT2JqZWN0LmtleXMoX3JlcXVpcmVWYWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3JlcXVpcmVWYWx1ZVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9yZXF1aXJlVmFsdWVba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3R5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvdHlwZXMudHNcIik7XG5PYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF90eXBlc1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvaW50ZXJwb2xhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2ludGVycG9sYXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBpbnRlcnBvbGF0ZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVNb2JpbGUgPSBpbnRlcnBvbGF0ZU1vYmlsZTtcbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1wiKSk7XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShrZXlGcmFtZXMsIHByb3BzKSB7XG4gIGlmICgha2V5RnJhbWVzKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHZhciBwcmV2ID0ga2V5RnJhbWVzLnByZXYsXG4gICAgbmV4dCA9IGtleUZyYW1lcy5uZXh0LFxuICAgIHJhdGlvID0ga2V5RnJhbWVzLnJhdGlvO1xuICB2YXIgbWlkID0gX29iamVjdFNwcmVhZCh7fSwgbmV4dCk7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwcm9wcyksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICBtaWRbcF0gPSBwcmV2W3BdICsgKG5leHRbcF0gLSBwcmV2W3BdKSAqIHJhdGlvO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiBtaWQ7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU1vYmlsZShrZXlGcmFtZXMsIHByb3BzLCB0aW1lKSB7XG4gIGlmICgha2V5RnJhbWVzKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHZhciBwcmV2ID0ga2V5RnJhbWVzLnByZXYsXG4gICAgbmV4dCA9IGtleUZyYW1lcy5uZXh0O1xuICBpZiAobmV4dC50eXBlID09PSAnTU9WRScpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUoa2V5RnJhbWVzLCBwcm9wcyk7XG4gIH1cblxuICAvLyBsZXQgdG91Y2ggZXZlbnRzIG9ubHkgbGluZ2VyIGZvciBoYWxmIGEgc2Vjb25kIG9uIHRoZSBzY3JlZW5cbiAgaWYgKHByZXYgPT09IG5leHQgJiYgTWF0aC5hYnModGltZSAtIG5leHQudGltZSkgPiA1MDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmV4dDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9pc0FjdGl2aXR5RXZlbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9pc0FjdGl2aXR5RXZlbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBpc0FjdGl2aXR5RXZlbnQ7XG5mdW5jdGlvbiBpc0FjdGl2aXR5RXZlbnQodHlwZSkge1xuICB2YXIgYWN0aXZpdHlUeXBlcyA9IFsnbHIuYnJvd3Nlci5Nb3VzZUV2ZW50JywgJ2xyLmJyb3dzZXIuU2Nyb2xsRXZlbnQnLCAnbHIuYnJvd3Nlci5JbnB1dEV2ZW50JywgJ2xyLmJyb3dzZXIuSW5wdXRDaGFuZ2VFdmVudCcsICdsci5hbmRyb2lkLlRvdWNoRXZlbnQnLCAnbHIuYW5kcm9pZC5JbnB1dENoYW5nZUV2ZW50JywgJ2xyLmlvcy5Ub3VjaEV2ZW50JywgJ2xyLmlvcy5JbnB1dENoYW5nZUV2ZW50J107XG4gIHJldHVybiBhY3Rpdml0eVR5cGVzLmluZGV4T2YodHlwZSkgPiAtMTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9pc1JlY29yZGluZ1NhbXBsZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9pc1JlY29yZGluZ1NhbXBsZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBpc1JlY29yZGluZ1NhbXBsZWQ7XG52YXIgX3BhcnNlSW50RnJvbUhleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYXJzZUludEZyb21IZXggKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3BhcnNlSW50RnJvbUhleC5qc1wiKSk7XG52YXIgU0FNUExFX0JVQ0tFVFMgPSAxMDAwMDsgLy8gQXMgZmV3IGFzIDAuMDElIG9mIHJlY29yZGluZ3NcblxuZnVuY3Rpb24gaXNSZWNvcmRpbmdTYW1wbGVkKHJlY29yZGluZ0lELCBzYW1wbGVQZXJjZW50KSB7XG4gIGlmIChzYW1wbGVQZXJjZW50IDw9IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG1heEJ1Y2tldCA9IE1hdGguZmxvb3Ioc2FtcGxlUGVyY2VudCAqIFNBTVBMRV9CVUNLRVRTKTtcbiAgdmFyIG51bSA9ICgwLCBfcGFyc2VJbnRGcm9tSGV4LmRlZmF1bHQpKHJlY29yZGluZ0lEKTtcbiAgdmFyIGJ1Y2tldCA9IG51bSAlIFNBTVBMRV9CVUNLRVRTO1xuICByZXR1cm4gYnVja2V0IDw9IG1heEJ1Y2tldDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9pc1Nlc3Npb25FdmVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvaXNTZXNzaW9uRXZlbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGlzU2Vzc2lvbkV2ZW50O1xudmFyIFNFU1NJT05fRVZFTlRfV0hJVEVMSVNUID0gWydsci5icm93c2VyLk5hdmlnYXRpb25FdmVudCcsICdsci5icm93c2VyLklucHV0Q2hhbmdlRXZlbnQnLCAnbHIuYnJvd3Nlci5JbnB1dEV2ZW50J107XG5mdW5jdGlvbiBpc1Nlc3Npb25FdmVudChldmVudCkge1xuICByZXR1cm4gU0VTU0lPTl9FVkVOVF9XSElURUxJU1QuaW5kZXhPZihldmVudC50eXBlKSA+IC0xIHx8IGV2ZW50LmRhdGEuZXZlbnRUeXBlID09PSAnQ0xJQ0snO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2lzVmFsaWRBcHBJRC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2lzVmFsaWRBcHBJRC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmlzVmFsaWRBcHBJRCA9IGlzVmFsaWRBcHBJRDtcbi8vIFRoaXMgcGF0dGVybiBtYXRjaGVzIHRoZSBvcmdTbHVnL2FwcFNsdWcgZm9ybWF0IHdlIGV4cGVjdCBmb3IgYXBwSURzLiBFYWNoIHNsdWcgaXMgZ2VuZXJhdGVkIHVzaW5nIHRoZSBgc2x1Z2lmeWBcbi8vIGhlbHBlciB3aGljaCBwZXJmb3JtcyBhIGZldyBjb252ZXJzaW9uczpcbi8vIDEpIEFsbCB1bmljb2RlIGlzIGNvbnZlcnRlZCB0byBhcHByb3hpbWF0ZSBBU0NJSSwgb3IgcmVtb3ZlZCBpZiB0aGVyZSBpcyBubyByZXBsYWNlbWVudC5cbi8vIDIpIFNwYWNlcyBhcmUgY29udmVydGVkIHRvIGh5cGhlbnNcbi8vIDMpIFJlbW92ZSBhbnkgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgYWxwaGFudW1lcmljLCBhIGh5cGhlbiwgb3IgYW4gdW5kZXJzY29yZS5cbi8vIDQpIEFuZCBmaW5hbGx5LCBsb3dlcmNhc2UgdGhlIHN0cmluZy5cbi8vXG4vLyBodHRwczovL2RvY3MuZGphbmdvcHJvamVjdC5jb20vZW4vMS4xMC9fbW9kdWxlcy9kamFuZ28vdXRpbHMvdGV4dC8jc2x1Z2lmeVxuLy9cbi8vIFRoZSBmaWVsZHMgc3RvcmluZyB0aGVzZSBzbHVncyBhcmUgU2x1Z0ZpZWxkIGluc3RhbmNlcywgd2hpY2ggdXNlIGEgZGlmZmVyZW50IHZhbGlkYXRpb24gcmVnZXggYWxsb3dpbmcgdXBwZXJjYXNlXG4vLyBjaGFyYWN0ZXJzLiBBcyB0aGUgZmluYWwgc3RlcCBpbiBgc2x1Z2lmeWAgaXMgdG8gbG93ZXJjYXNlIGFsbCB0ZXh0LCBhbmQgdGhhdCBpcyBob3cgd2UgZ2VuZXJhdGUgc2x1Z3MsIHdlIGRvIG5vdFxuLy8gY29uc2lkZXIgdXBwZXJjYXNlIGNoYXJhY3RlcnMgdmFsaWQgaW4gYW4gYXBwSUQuXG4vL1xuLy8gaHR0cHM6Ly9kb2NzLmRqYW5nb3Byb2plY3QuY29tL2VuLzEuMTAvX21vZHVsZXMvZGphbmdvL2NvcmUvdmFsaWRhdG9ycy8gKHNlZSBzbHVnX3JlKVxudmFyIEFQUF9JRF9QQVRURVJOID0gL15bYS16MC05Xy1dK1xcL1thLXowLTlfLV0rJC87XG5mdW5jdGlvbiBpc1ZhbGlkQXBwSUQoYXBwSUQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcHBJRCA9PT0gJ3N0cmluZycgJiYgQVBQX0lEX1BBVFRFUk4udGVzdChhcHBJRCk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvbGlrZU9wZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvbGlrZU9wZXJhdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMubGlrZU9wZXJhdG9yID0gbGlrZU9wZXJhdG9yO1xuZnVuY3Rpb24gbGlrZU9wZXJhdG9yKHZhbHVlLCBwYXR0ZXJuKSB7XG4gIC8vIEJlaGF2ZXMgbGlrZSB0aGUgRVMgXCJ3aWxkY2FyZFwiIHF1ZXJ5XG4gIC8vIChTZWU6IGh0dHBzOi8vd3d3LmVsYXN0aWMuY28vZ3VpZGUvZW4vZWxhc3RpY3NlYXJjaC9yZWZlcmVuY2UvNi41L3F1ZXJ5LWRzbC13aWxkY2FyZC1xdWVyeS5odG1sI3F1ZXJ5LWRzbC13aWxkY2FyZC1xdWVyeSlcblxuICB2YXIgZXNjYXBlZCA9IHBhdHRlcm4ucmVwbGFjZShcbiAgLy8gKFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zI2VzY2FwaW5nKVxuICAvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcblxuICAvLyBUbyBlbXVsYXRlIHRoZSBFUyB3aWxkY2FyZCBzZWFyY2ggaW4gcmVnZXhcbiAgLy8gKGEpIHByZWZpeCAnKicgd2l0aCB0aGUgcmVnZXggd2lsZGNhcmQgJy4nIGNoYXJhY3RlclxuICAvLyAoYykgY29udmVydCAnPycgdG8gJy4nXG4gIC8vIEtlZXAgaW4gbWluZCB0aGF0IHdlIGhhdmUgZXNjYXBlZCB0aGVzZSBjaGFyYWN0ZXJzLCBzbyB3ZSBhY3R1YWxseSBuZWVkIHRvIG1hdGNoXG4gIC8vIHRoZWlyIGVzY2FwZWQgdmVyc2lvbnMuXG4gIHZhciBlc2NhcGVkUmVnZXhTdHJpbmcgPSBlc2NhcGVkLnJlcGxhY2UoL1xcXFxcXCovZywgJy4qJykucmVwbGFjZSgvXFxcXFxcPy9nLCAnLicpO1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChlc2NhcGVkUmVnZXhTdHJpbmcsIFwiJFwiKSk7XG4gIHJldHVybiByZWdleC50ZXN0KHZhbHVlKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9sb2dFcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvbG9nRXJyb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBjYW5CaW5kID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvci5iaW5kO1xudmFyIGxvZ0Vycm9yID0gY2FuQmluZCA/IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSA6IGZ1bmN0aW9uICgpIHt9O1xudmFyIF9kZWZhdWx0ID0gbG9nRXJyb3I7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL21ha2VSZWNvcmRpbmdJRC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL21ha2VSZWNvcmRpbmdJRC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1ha2VSZWNvcmRpbmdJRDtcbnZhciBfdXVpZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dWlkICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy91dWlkLmpzXCIpKTtcbmZ1bmN0aW9uIG1ha2VSZWNvcmRpbmdJRCgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgIF9yZWYkcHJlZml4ID0gX3JlZi5wcmVmaXgsXG4gICAgcHJlZml4ID0gX3JlZiRwcmVmaXggPT09IHZvaWQgMCA/IDUgOiBfcmVmJHByZWZpeDtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeCwgXCItXCIpLmNvbmNhdCgoMCwgX3V1aWQuZGVmYXVsdCkoKSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvbWFwVmFsdWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvbWFwVmFsdWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbWFwVmFsdWVzO1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iaiwgZikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc1trZXldID0gZihvYmpba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL21heWJlQ2xlYW5Td2lmdFVJQ2xhc3NOYW1lLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9tYXliZUNsZWFuU3dpZnRVSUNsYXNzTmFtZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbWF5YmVDbGVhblN3aWZ0VUlDbGFzc05hbWU7XG5mdW5jdGlvbiBtYXliZUNsZWFuU3dpZnRVSUNsYXNzTmFtZShjbGFzc05hbWUpIHtcbiAgLy8gcmVwbGFjZSBhbmdsZSBicmFja2V0cyBwcmVzZW50IGluIFN3aWZ0VUkgVmlld0NvbnRyb2xsZXIgdHlwZSBzdHJpbmdzIHdpdGggYXNjaWkgZW5jb2RpbmcgYW5kIHN0cmlwIHNwYWNlc1xuICByZXR1cm4gY2xhc3NOYW1lLnJlcGxhY2UoLzwvZywgJyUzYycpLnJlcGxhY2UoLz4vZywgJyUzZScpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcGFyc2VJbnRGcm9tSGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcGFyc2VJbnRGcm9tSGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcGFyc2VJbnRGcm9tSGV4O1xuZnVuY3Rpb24gcGFyc2VJbnRGcm9tSGV4KHN0cmluZykge1xuICAvLyBzdHJpcCBub24taGV4IGNoYXJhY3RlcnNcbiAgdmFyIGhleCA9IHN0cmluZy5yZXBsYWNlKC9bXjAtOWEtZl0vZywgJycpO1xuICByZXR1cm4gcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXgpLCAxNikgfHwgMDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9wYXJzZVF1ZXJ5U3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3BhcnNlUXVlcnlTdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMucGFyc2VRdWVyeVN0cmluZyA9IHZvaWQgMDtcbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qc1wiKSk7XG52YXIgcGFyc2VTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiBwYXJzZVNlYXJjaFBhcmFtcyhxdWVyeVN0cmluZykge1xuICAvLyBJZGVhbGx5IHRoaXMgd291bGQgdXNlIFVSTFNlYXJjaFBhcmFtcyBidXQgdGhhdCdzIHVuc3VwcG9ydGVkIGluIElFIDExXG4gIHZhciBwYXJhbXMgPSB7fTtcbiAgdmFyIGZyYWdtZW50cyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJyk7XG4gIC8vIFRoZSB3YXkgdGhpcyBpcyBjb25zdHJ1Y3RlZCB3aWxsIHRha2UgdGhlIGxhc3Qgb2YgYW55IGR1cGxpY2F0ZSBrZXlzXG4gIGZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgIHZhciBfZnJhZ21lbnQkc3BsaXQkbWFwJG0gPSBmcmFnbWVudC5zcGxpdCgnPScpXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2RlY29kZVVSSUNvbXBvbmVudCNkZWNvZGluZ19xdWVyeV9wYXJhbWV0ZXJzX2Zyb21fYV91cmxcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICB9KS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KSxcbiAgICAgIF9mcmFnbWVudCRzcGxpdCRtYXAkbTIgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9mcmFnbWVudCRzcGxpdCRtYXAkbSwgMiksXG4gICAgICBrZXkgPSBfZnJhZ21lbnQkc3BsaXQkbWFwJG0yWzBdLFxuICAgICAgdmFsdWUgPSBfZnJhZ21lbnQkc3BsaXQkbWFwJG0yWzFdO1xuICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcGFyYW1zO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGZ1bGwgVVJMIGludG8gYW4gb2JqZWN0IHdpdGgga2V5cyBhbmQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzIGluIHRoZSBxdWVyeVxuICogc3RyaW5nIG9mIHRoZSBVUkwuXG4gKi9cbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhocmVmKSB7XG4gIHZhciBxdWVyeURlbGltaXRlckluZGV4ID0gaHJlZi5pbmRleE9mKCc/Jyk7XG4gIGlmIChxdWVyeURlbGltaXRlckluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vIFN0cmlwIHRoZSBsZWFkaW5nICc/J1xuICB2YXIgcXVlcnlTdHJpbmcgPSBocmVmLnN1YnN0cmluZyhxdWVyeURlbGltaXRlckluZGV4ICsgMSk7XG4gIHJldHVybiBwYXJzZVNlYXJjaFBhcmFtcyhxdWVyeVN0cmluZyk7XG59O1xuZXhwb3J0cy5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9wYXJzZVNlbGVjdG9yRm9yTWF0Y2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9wYXJzZVNlbGVjdG9yRm9yTWF0Y2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwYXJzZVNlbGVjdG9yRm9yTWF0Y2g7XG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanNcIikpO1xudmFyIF9zbGljZWRUb0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXCIpKTtcbnZhciBfc3RhcnRzV2l0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdGFydHNXaXRoICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9zdGFydHNXaXRoLmpzXCIpKTtcbnZhciBudGhDaGlsZERlbGltID0gJ34nO1xudmFyIG50aENoaWxkUHJlZml4ID0gJzpudGgtY2hpbGQoJztcblxuLy8gcGFyc2VzIHNlbGVjdG9yU3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygbm9kZSBvYmplY3RzIGlkZW50aWZ5aW5nIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbi8vIGlkOiA8U3RyaW5nPiwgY2xhc3NOYW1lczogWzxTdHJpbmc+XSwgbm9kZU5hbWU6IDxTdHJpbmc+LCBkaXJlY3REZXNjOiA8Qm9vbD4sIG50aENoaWxkOiA8U3RyaW5nPlxuZnVuY3Rpb24gcGFyc2VTZWxlY3RvckZvck1hdGNoKHNlbGVjdG9yU3RyaW5nKSB7XG4gIHZhciBwYXJzZWRTdHIgPSBzZWxlY3RvclN0cmluZy5yZXBsYWNlKC9cXHMqPlxccyp8Om50aC1jaGlsZFxcKChbMS05XVswLTldKnxvZGR8ZXZlbilcXCl8XFxzKy9naSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoLmluZGV4T2YoJz4nKSA+IC0xKSB7XG4gICAgICByZXR1cm4gJyA+JztcbiAgICB9XG4gICAgaWYgKG1hdGNoLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnICc7XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdChudGhDaGlsZERlbGltKS5jb25jYXQobWF0Y2guc2xpY2UobnRoQ2hpbGRQcmVmaXgubGVuZ3RoKSk7XG4gIH0pO1xuICByZXR1cm4gcGFyc2VkU3RyLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChub2RlU3RyaW5nKSB7XG4gICAgdmFyIG5vZGVPYmplY3QgPSB7fTtcbiAgICB2YXIgY2xlYW5Ob2RlU3RyaW5nID0gbm9kZVN0cmluZztcbiAgICBpZiAoY2xlYW5Ob2RlU3RyaW5nLmNoYXJBdCgwKSA9PT0gJz4nKSB7XG4gICAgICBub2RlT2JqZWN0LmRpcmVjdERlc2MgPSB0cnVlO1xuICAgICAgY2xlYW5Ob2RlU3RyaW5nID0gY2xlYW5Ob2RlU3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cbiAgICBjbGVhbk5vZGVTdHJpbmcgPSBjbGVhbk5vZGVTdHJpbmcucmVwbGFjZSgvXihbYS16MC05LV9dKykvaWcsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgbm9kZU9iamVjdC5ub2RlTmFtZSA9IG1hdGNoO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICAgIGlmIChjbGVhbk5vZGVTdHJpbmcuY2hhckF0KDApID09PSBudGhDaGlsZERlbGltKSB7XG4gICAgICB2YXIgX2NsZWFuTm9kZVN0cmluZyRzbGljID0gY2xlYW5Ob2RlU3RyaW5nLnNsaWNlKDEpLnNwbGl0KCcpJyksXG4gICAgICAgIF9jbGVhbk5vZGVTdHJpbmckc2xpYzIgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9jbGVhbk5vZGVTdHJpbmckc2xpYywgMiksXG4gICAgICAgIGNoaWxkSUQgPSBfY2xlYW5Ob2RlU3RyaW5nJHNsaWMyWzBdLFxuICAgICAgICByZXN0ID0gX2NsZWFuTm9kZVN0cmluZyRzbGljMlsxXTtcbiAgICAgIG5vZGVPYmplY3QubnRoQ2hpbGQgPSBjaGlsZElEO1xuICAgICAgY2xlYW5Ob2RlU3RyaW5nID0gcmVzdDtcbiAgICB9XG4gICAgY2xlYW5Ob2RlU3RyaW5nLnJlcGxhY2UoL1xcLnwjL2dpLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBcIiBcIi5jb25jYXQobWF0Y2gpO1xuICAgIH0pLnRyaW0oKS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVQYXJ0KSB7XG4gICAgICBpZiAoKDAsIF9zdGFydHNXaXRoLmRlZmF1bHQpKG5vZGVQYXJ0LCAnLicpKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBub2RlUGFydC5zbGljZSgxKTtcbiAgICAgICAgbm9kZU9iamVjdC5jbGFzc0xpc3QgPSBub2RlT2JqZWN0LmNsYXNzTGlzdCA/IFtdLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShub2RlT2JqZWN0LmNsYXNzTGlzdCksIFtjbGFzc05hbWVdKSA6IFtjbGFzc05hbWVdO1xuICAgICAgfSBlbHNlIGlmICgoMCwgX3N0YXJ0c1dpdGguZGVmYXVsdCkobm9kZVBhcnQsICcjJykpIHtcbiAgICAgICAgbm9kZU9iamVjdC5pZCA9IG5vZGVQYXJ0LnNsaWNlKDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2RlT2JqZWN0O1xuICB9KTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9wcm90ZWN0RnVuYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcHJvdGVjdEZ1bmMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHByb3RlY3RGdW5jO1xudmFyIF9zZW5kVGVsZW1ldHJ5RGF0YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZW5kVGVsZW1ldHJ5RGF0YSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2VuZFRlbGVtZXRyeURhdGEuanNcIikpO1xudmFyIF9sb2dFcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2dFcnJvciAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvbG9nRXJyb3IuanNcIikpO1xuZnVuY3Rpb24gcHJvdGVjdEZ1bmMoZikge1xuICB2YXIgb25GYWlsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX2xyZGVidWcpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdmFyIHBheWxvYWQgPSBvbkZhaWwoZXJyKTtcbiAgICAgICgwLCBfbG9nRXJyb3IuZGVmYXVsdCkoJ0xvZ1JvY2tldCcsIGVycik7XG4gICAgICAoMCwgX3NlbmRUZWxlbWV0cnlEYXRhLmRlZmF1bHQpKGVyciwgcGF5bG9hZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcXVlcnlTZWxlY3RvcldpdGhTaGFkb3dEb20uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3F1ZXJ5U2VsZWN0b3JXaXRoU2hhZG93RG9tLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBxdWVyeVNlbGVjdG9yV2l0aFNoYWRvd0RvbTtcbmV4cG9ydHMuY2FzZUluc2Vuc2l0aXZlUXVlcnlTZWxlY3RvciA9IHZvaWQgMDtcbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxudmFyIGdldE1hdGNoaW5nQ2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRNYXRjaGluZ0NoaWxkcmVuKF9yZWYpIHtcbiAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgc2VsZWN0b3JMaXN0ID0gX3JlZi5zZWxlY3Rvckxpc3QsXG4gICAgZGlyZWN0RGVzYyA9IF9yZWYuZGlyZWN0RGVzYztcbiAgdmFyIHNlbGVjdG9yUGFydHMgPSBzZWxlY3Rvckxpc3RbMF0uc3BsaXQoLyg/PVxcLil8KD89IykvKTtcblxuICAvLyBlbGVtZW50IHNlbGVjdG9yIGxvb2tzIGxpa2UgXCJ0eXBlOm50aC1jaGlsZCh4KVwiXG4gIHZhciBlbGVtZW50U2VsZWN0b3IgPSBzZWxlY3RvclBhcnRzLnNoaWZ0KCk7XG4gIHZhciBpZCA9ICcnO1xuICB2YXIgY2xhc3NlcyA9IFtdO1xuICBzZWxlY3RvclBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICBpZiAocGFydFswXSA9PT0gJyMnKSB7XG4gICAgICBpZCA9IHBhcnQudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSkudHJpbSgpO1xuICAgIH1cbiAgICBpZiAocGFydFswXSA9PT0gJy4nKSB7XG4gICAgICBjbGFzc2VzLnB1c2gocGFydC50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygxKS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBtYXRjaGluZ0VsZW1lbnRzO1xuICBpZiAoZGlyZWN0RGVzYykge1xuICAgIG1hdGNoaW5nRWxlbWVudHMgPSBbcm9vdC5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlID4gXCIuY29uY2F0KGVsZW1lbnRTZWxlY3RvcikpXTtcbiAgfSBlbHNlIHtcbiAgICBtYXRjaGluZ0VsZW1lbnRzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRTZWxlY3Rvcik7XG4gIH1cbiAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgLy8gY2hlY2sgZWFjaCBtYXRjaGVkIGVsZW1lbnRzIGZvciBhIGZ1bGwgbWF0Y2hcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG1hdGNoaW5nRWxlbWVudHMpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIGN1cnJlbnRNYXRjaCA9IF9zdGVwLnZhbHVlO1xuICAgICAgaWYgKCFjdXJyZW50TWF0Y2ggfHwgaWQgIT09IGN1cnJlbnRNYXRjaC5pZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudENsYXNzZXMgPSBBcnJheS5mcm9tKGN1cnJlbnRNYXRjaC5jbGFzc0xpc3QudmFsdWVzKCkpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzICE9PSAnJyAmJiBzWzBdICE9PSAnOic7XG4gICAgICB9KTsgLy8gbm8gcHNldWRvIGNsYXNzZXMgb3IgZW1wdGllc1xuXG4gICAgICBpZiAoIWNsYXNzZXMuZXZlcnkoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDbGFzc2VzLmluZGV4T2YodikgPiAtMTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICB9XG4gICAgICBtYXRjaGVzLnB1c2goY3VycmVudE1hdGNoKTtcbiAgICB9O1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKCk7XG4gICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbi8vIFRoZSBwYXJzZXIgZXhwZWN0cyB0aGUgc2VsZWN0b3IgdG8gYmUgZm9ybWF0dGVkIGFzIGFuIEVTIG1vdXNlIGNsaWNrIHNlbGVjdG9yOlxuXG4vLyBkaXY6bnRoLWNoaWxkKDEpI3NvbWUtaWQgPiBkaXY6bnRoLWNoaWxkKDEpI2lkLW1lLmNsYXNzMS5jbGFzczIgPiBkaXY6bnRoLWNoaWxkKDMpID4gLi4uXG5cbi8vIHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yIGZvcm1hdCBpdCB3aWxsIHJldHVybiB0aGUgc2FtZSByZXN1bHQgYXNcbi8vIHJvb3QucXVlcnlTZWxlY3RvcihzZWxlY3Rvcikgd2l0aG91dCBjYXNlIHNlbnNpdGl2aXR5XG52YXIgY2FzZUluc2Vuc2l0aXZlUXVlcnlTZWxlY3RvciA9IGZ1bmN0aW9uIGNhc2VJbnNlbnNpdGl2ZVF1ZXJ5U2VsZWN0b3Iocm9vdCwgc2VsZWN0b3IpIHtcbiAgaWYgKCFzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHJvb3QgaXMgcGFydCBvZiBhIHNoYWRvdyBET00sIHN0YXJ0IGZyb20gdGhlIHNoYWRvdyByb290LiBPdGhlcndpc2UsXG4gIC8vICByb290IG11c3Qgc3RhcnQgYXQgYm9keSBlbGVtZW50IHRvIHByb3RlY3QgYWdhaW5zdCBtYWxmb3JtZWQgRE9NczpcbiAgdmFyIHJvb3RFbGVtZW50O1xuICBpZiAocm9vdC5ob3N0KSB7XG4gICAgLy8gVGhlIHByZXNlbmNlIG9mIHJvb3QuaG9zdCBpbmRpY2F0ZXMgYSBzaGFkb3cgcm9vdDpcbiAgICByb290RWxlbWVudCA9IHJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgcm9vdEVsZW1lbnQgPSByb290LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgfVxuXG4gIC8vIG5vIHNoYWRvdyBkb20gcm9vdCBvciBib2R5IHRhZ1xuICBpZiAoIXJvb3RFbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB3aGVuIHN0b3Jpbmcgc2VsZWN0b3JzIHdlIHRydW5jYXRlIHRoZSBsZWFkaW5nIHNlZ21lbnRzIG9mIGxvbmcgc2VsZWN0b3Igc3RyaW5nc1xuICAvLyB0aGlzIG1ha2VzIHRoZSBmaXJzdCBzZWxlY3RvciBzZWdtZW50IHBvc3NpYmx5IGFueXdoZXJlIGluIHRoZSBET01cbiAgdmFyIHF1ZXVlID0gW3tcbiAgICBtYXRjaGVzOiBbcm9vdEVsZW1lbnRdLFxuICAgIHNlbGVjdG9yTGlzdDogc2VsZWN0b3Iuc3BsaXQoJyA+ICcpLFxuICAgIGRpcmVjdERlc2M6IGZhbHNlXG4gIH1dO1xuICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgdmFyIF9xdWV1ZSRzaGlmdCA9IHF1ZXVlLnNoaWZ0KCksXG4gICAgICBtYXRjaGVzID0gX3F1ZXVlJHNoaWZ0Lm1hdGNoZXMsXG4gICAgICBzZWxlY3Rvckxpc3QgPSBfcXVldWUkc2hpZnQuc2VsZWN0b3JMaXN0LFxuICAgICAgZGlyZWN0RGVzYyA9IF9xdWV1ZSRzaGlmdC5kaXJlY3REZXNjO1xuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobWF0Y2hlcyksXG4gICAgICBfc3RlcDI7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBtYXRjaGVkRWxlbWVudCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgdmFyIGN1cnJlbnRNYXRjaGVzID0gZ2V0TWF0Y2hpbmdDaGlsZHJlbih7XG4gICAgICAgICAgcm9vdDogbWF0Y2hlZEVsZW1lbnQsXG4gICAgICAgICAgc2VsZWN0b3JMaXN0OiBzZWxlY3Rvckxpc3QsXG4gICAgICAgICAgZGlyZWN0RGVzYzogZGlyZWN0RGVzY1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkaWQgSSBmaW5kIGl0P1xuICAgICAgICBpZiAoY3VycmVudE1hdGNoZXMubGVuZ3RoICYmIHNlbGVjdG9yTGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudE1hdGNoZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRNYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgbWF0Y2hlczogY3VycmVudE1hdGNoZXMsXG4gICAgICAgICAgICBzZWxlY3Rvckxpc3Q6IHNlbGVjdG9yTGlzdC5zbGljZSgxKSxcbiAgICAgICAgICAgIGRpcmVjdERlc2M6IHRydWUgLy8gYWxsIHNlZ21lbnRzIGFmdGVyIHRoZSBmaXJzdCBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50c1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmV4cG9ydHMuY2FzZUluc2Vuc2l0aXZlUXVlcnlTZWxlY3RvciA9IGNhc2VJbnNlbnNpdGl2ZVF1ZXJ5U2VsZWN0b3I7XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yV2l0aFNoYWRvd0RvbShlbGVtZW50LCBmdWxsU2VsZWN0b3IpIHtcbiAgaWYgKGZ1bGxTZWxlY3Rvci5zdGFydHNXaXRoKCckc2hhZG93LXJvb3QgPicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHNlbGVjdG9yICdcIi5jb25jYXQoZnVsbFNlbGVjdG9yLCBcIic6IHNob3VsZCBub3Qgc3RhcnQgd2l0aCAkc2hhZG93LXJvb3RcIikpO1xuICB9XG4gIGlmIChmdWxsU2VsZWN0b3IuZW5kc1dpdGgoJz4gJHNoYWRvdy1yb290JykpIHtcbiAgICAvLyBTZWxlY3RvciBlbmRzIGluIGFuIGVtcHR5IHNoYWRvdyByb290OyByZW1vdmUgaXQgc28gd2UgZG9uJ3QgcGVyZm9ybSBhbiBpbnZhbGlkIHF1ZXJ5OlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGZ1bGxTZWxlY3RvciA9IGZ1bGxTZWxlY3Rvci5zbGljZSgwLCBmdWxsU2VsZWN0b3IubGVuZ3RoIC0gJz4gJHNoYWRvdy1yb290Jy5sZW5ndGgpO1xuICB9XG4gIHZhciBjdXJyZW50Um9vdCA9IGVsZW1lbnQ7XG4gIHZhciBjdXJyZW50Tm9kZTtcbiAgdmFyIHNlbGVjdG9ycyA9IGZ1bGxTZWxlY3Rvci5zcGxpdCgnPiAkc2hhZG93LXJvb3QgPicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGN1cnJlbnROb2RlID0gY2FzZUluc2Vuc2l0aXZlUXVlcnlTZWxlY3RvcihjdXJyZW50Um9vdCwgc2VsZWN0b3JzW2ldKTtcblxuICAgIC8vIERpdmUgaW50byB0aGUgc2hhZG93IVxuICAgIGlmIChjdXJyZW50Tm9kZSAmJiBpIDwgc2VsZWN0b3JzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChjdXJyZW50Tm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgIGN1cnJlbnRSb290ID0gY3VycmVudE5vZGUuc2hhZG93Um9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2hhZG93Um9vdCBmb3Igc2VsZWN0b3IgJ1wiLmNvbmNhdChmdWxsU2VsZWN0b3IsIFwiJyBhdCBkZXB0aCBcIikuY29uY2F0KGkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByb290OiBjdXJyZW50Um9vdCxcbiAgICBub2RlOiBjdXJyZW50Tm9kZVxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3JhbmRvbUludC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3JhbmRvbUludC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHJhbmRvbUludDtcbi8vIG1pbiBpcyBpbmNsdXNpdmUsIG1heCBpcyBleGNsdXNpdmVcbmZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICB2YXIgbWluSW50ID0gTWF0aC5jZWlsKG1pbik7XG4gIHZhciBtYXhJbnQgPSBNYXRoLmZsb29yKG1heCk7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4SW50IC0gbWluSW50KSkgKyBtaW5JbnQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvcmVtb3ZlT3V0ZGF0ZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3JlbW92ZU91dGRhdGVkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSByZW1vdmVPdXRkYXRlZDtcbnZhciBfc29ydGVkTGFzdEluZGV4QnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9zb3J0ZWRMYXN0SW5kZXhCeSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3NvcnRlZExhc3RJbmRleEJ5LmpzXCIpKTtcbnZhciBLRUVQID0gNTAwMDtcbmZ1bmN0aW9uIHJlbW92ZU91dGRhdGVkKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGZpcnN0IGVudHJ5IHdoaWNoIGlzICoqYmVmb3JlKiogdGhlIGdpdmVuIGFjdGlvbnMgdGltZS5cbiAgdmFyIGluZGV4ID0gKDAsIF9zb3J0ZWRMYXN0SW5kZXhCeS5kZWZhdWx0KShzdGF0ZSwge1xuICAgIHRpbWU6IGFjdGlvbi50aW1lIC0gS0VFUFxuICB9LCAndGltZScpIC0gMTtcbiAgdmFyIGZpcnN0ID0gc3RhdGVbaW5kZXhdO1xuXG4gIC8vIEtlZXAgb25lIGVudHJ5IHRoYXQgaXMgbW9yZSB0aGFuIEtFRVAgYXdheSwgYW5kIHJlbW92ZSB0aGUgcmVzdCBvZiB0aGVtLlxuICBpZiAoZmlyc3QgJiYgYWN0aW9uLnRpbWUgLSBmaXJzdC50aW1lID4gS0VFUCAmJiBpbmRleCA+IDApIHtcbiAgICByZXR1cm4gc3RhdGUuc2xpY2UoaW5kZXgpO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9yZXF1aXJlVmFsdWUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9yZXF1aXJlVmFsdWUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5yZXF1aXJlVmFsdWUgPSB2b2lkIDA7XG52YXIgcmVxdWlyZVZhbHVlID0gZnVuY3Rpb24gcmVxdWlyZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydHMucmVxdWlyZVZhbHVlID0gcmVxdWlyZVZhbHVlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3Nhbml0aXplVmFsdWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2FuaXRpemVWYWx1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBzYW5pdGl6ZVZhbHVlO1xudmFyIF9yZXBsYWNlV2l0aExpcHN1bSA9IGZ1bmN0aW9uIF9yZXBsYWNlV2l0aExpcHN1bShjb250ZW50KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIHZhciBsaXBzdW0gPSAnTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuICc7XG4gIHZhciByZXBlYXRMZW5ndGggPSBNYXRoLmNlaWwoY29udGVudC5sZW5ndGggLyBsaXBzdW0ubGVuZ3RoKTtcbiAgdmFyIHJlcGxhY2VtZW50Q29udGVudCA9ICcnO1xuICB3aGlsZSAocmVwZWF0TGVuZ3RoID4gMCkge1xuICAgIHJlcGxhY2VtZW50Q29udGVudCArPSBsaXBzdW07XG4gICAgcmVwZWF0TGVuZ3RoLS07XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2VtZW50Q29udGVudC5zbGljZSgwLCBjb250ZW50Lmxlbmd0aCk7XG59O1xuZnVuY3Rpb24gc2FuaXRpemVWYWx1ZSh2YWx1ZVRvQ2xlYW4sIHRhaW50VHlwZSkge1xuICB2YXIgdmFsdWUgPSBTdHJpbmcodmFsdWVUb0NsZWFuKTtcbiAgaWYgKFN0cmluZyh0YWludFR5cGUpLnRvTG93ZXJDYXNlKCkgPT09ICdsaXBzdW0nKSB7XG4gICAgcmV0dXJuIF9yZXBsYWNlV2l0aExpcHN1bSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3Njcm9sbE1hcEhpc3RvZ3JhbVRvUGVyY2VudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3Njcm9sbE1hcEhpc3RvZ3JhbVRvUGVyY2VudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNjcm9sbE1hcEhpc3RvZ3JhbVRvUGVyY2VudDtcbmZ1bmN0aW9uIHNjcm9sbE1hcEhpc3RvZ3JhbVRvUGVyY2VudChidWNrZXRzLCBzY3JvbGxIZWlnaHQpIHtcbiAgdmFyIHNjcm9sbE1hcCA9IFtdO1xuICB2YXIgY3VycmVudFNlc3Npb25Db3VudCA9IGJ1Y2tldHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGQpIHtcbiAgICByZXR1cm4gYWNjICsgZC5jb3VudDtcbiAgfSwgMCk7XG4gIHZhciBjdXJzb3IgPSAwO1xuICBmb3IgKHZhciBwID0gMTsgcCA8PSAxMDA7IHArKykge1xuICAgIHZhciBjb250YWluZXJQb3NpdGlvbiA9IHNjcm9sbEhlaWdodCAqIChwICogMC4wMSk7XG4gICAgaWYgKGN1cnNvciA+PSBidWNrZXRzLmxlbmd0aCkge1xuICAgICAgc2Nyb2xsTWFwLnB1c2goMCk7IC8vIGJleW9uZCBzY3JvbGxlZCBhcmVhIGhhcyAwIHNlc3Npb25zXG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcm9sbE1hcC5wdXNoKGN1cnJlbnRTZXNzaW9uQ291bnQpO1xuICAgICAgaWYgKGNvbnRhaW5lclBvc2l0aW9uID4gYnVja2V0c1tjdXJzb3JdLm1heFNjcm9sbCkge1xuICAgICAgICBjdXJyZW50U2Vzc2lvbkNvdW50IC09IGJ1Y2tldHNbY3Vyc29yXS5jb3VudDtcbiAgICAgICAgY3Vyc29yKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzY3JvbGxNYXA7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2NydWJFeGNlcHRpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3NjcnViRXhjZXB0aW9uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5zY3J1YkV4Y2VwdGlvbiA9IHNjcnViRXhjZXB0aW9uO1xudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZiAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXCIpKTtcbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gaXNTY2FsYXIodmFsdWUpIHtcbiAgcmV0dXJuIC9ib29sZWFufG51bWJlcnxzdHJpbmcvLnRlc3QoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbHVlKSk7XG59XG52YXIgb3B0aW9uYWxTY2FsYXJzID0gW1xuLy8gVmFsaWQgdmFsdWVzIGZvciAnbGV2ZWwnIGFyZSAnZmF0YWwnLCAnZXJyb3InLCAnd2FybmluZycsICdpbmZvJyxcbi8vIGFuZCAnZGVidWcnLiBEZWZhdWx0cyB0byAnZXJyb3InLlxuJ2xldmVsJywgJ2xvZ2dlciddO1xudmFyIG9wdGlvbmFsTWFwcyA9IFsndGFncycsICdleHRyYSddO1xuZnVuY3Rpb24gc2NydWJFeGNlcHRpb24oZGF0YSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvcHRpb25hbFNjYWxhcnMpLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBmaWVsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW2ZpZWxkXTtcbiAgICAgICAgaWYgKGlzU2NhbGFyKHZhbHVlKSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIGRhdGFbZmllbGRdID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvcHRpb25hbE1hcHMpLFxuICAgICAgX3N0ZXAyO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX2ZpZWxkID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICB2YXIgZGlydHkgPSBvcHRpb25zW19maWVsZF0gfHwge307XG4gICAgICAgIHZhciBzY3J1YmJlZCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKGRpcnR5KTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9PYmplY3Qka2V5c1tfaV07XG4gICAgICAgICAgdmFyIF92YWx1ZSA9IGRpcnR5W2tleV07XG4gICAgICAgICAgaWYgKGlzU2NhbGFyKF92YWx1ZSkpIHtcbiAgICAgICAgICAgIHNjcnViYmVkW2tleS50b1N0cmluZygpXSA9IF92YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBkYXRhW19maWVsZF0gPSBzY3J1YmJlZDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9zZWxlY3RvckZyb21Ob2RlUGF0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2VsZWN0b3JGcm9tTm9kZVBhdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNlbGVjdG9yRnJvbU5vZGVQYXRoO1xudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzXCIpKTtcbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gc2VsZWN0b3JGcm9tTm9kZVBhdGgoKSB7XG4gIHZhciBub2RlUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHZhciBzZWxlY3RvcnMgPSBbXTtcbiAgLy8gTm9kZVBhdGhzIGFyZSB7IG5vZGVOYW1lOiBTdHJpbmcsIGNsYXNzTGlzdDogW1N0cmluZ10sIGlkOiBTdHJpbmcgfVxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobm9kZVBhdGgpLnJldmVyc2UoKSksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgcGF0aCA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIG5vZGVOYW1lID0gcGF0aC5ub2RlTmFtZSxcbiAgICAgICAgaWQgPSBwYXRoLmlkLFxuICAgICAgICBudGhDaGlsZCA9IHBhdGgubnRoQ2hpbGQ7XG4gICAgICB2YXIgY2xhc3NMaXN0ID0gcGF0aC5jbGFzc0xpc3Q7XG4gICAgICB2YXIgc2VsZWN0b3JQYXJ0cyA9IFtdO1xuXG4gICAgICAvLyBwc2V1ZG8gY2xhc3Nlc1xuICAgICAgdmFyIHBzZXVkb0NsYXNzTGlzdCA9IFtdO1xuICAgICAgbnRoQ2hpbGQgJiYgcHNldWRvQ2xhc3NMaXN0LnB1c2goXCJudGgtY2hpbGQoXCIuY29uY2F0KG50aENoaWxkLCBcIilcIikpO1xuICAgICAgLy8gLi4uIG1vcmUgYXMgd2UgZGVjaWRlIHRvIHN1cHBvcnQgdGhlbVxuXG4gICAgICBpZiAobm9kZU5hbWUpIHtcbiAgICAgICAgc2VsZWN0b3JQYXJ0cy5wdXNoKG5vZGVOYW1lKTtcbiAgICAgICAgcHNldWRvQ2xhc3NMaXN0LnNvcnQoKS5tYXAoZnVuY3Rpb24gKHBzZXVkb0NsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdG9yUGFydHMucHVzaChcIjpcIi5jb25jYXQocHNldWRvQ2xhc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgc2VsZWN0b3JQYXJ0cy5wdXNoKFwiI1wiLmNvbmNhdChpZCkpO1xuICAgICAgfVxuICAgICAgaWYgKGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIGNsYXNzTGlzdCA9IGNsYXNzTGlzdC5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pLnNvcnQoKTtcbiAgICAgICAgc2VsZWN0b3JQYXJ0cyA9IFtdLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShzZWxlY3RvclBhcnRzKSwgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoY2xhc3NMaXN0Lm1hcChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIFwiLlwiLmNvbmNhdChjbGFzc05hbWUpO1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdG9yUGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yUGFydHMuam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiBzZWxlY3RvcnMuam9pbignID4gJyk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2VsZWN0b3JNYXRjaGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2VsZWN0b3JNYXRjaGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc2VsZWN0b3JNYXRjaGVzO1xudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzXCIpKTtcbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qc1wiKSk7XG52YXIgX2ZpbmRJbmRleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maW5kSW5kZXggKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2ZpbmRJbmRleC5qc1wiKSk7XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8vIGNoZWNrcyB0aGF0IG5vZGVCIGZ1bGZpbGxzIGFsbCByZXF1aXJlbWVudHMgc3BlY2lmaWVkIGluIG5vZGVBXG5mdW5jdGlvbiBub2Rlc01hdGNoKG5vZGVBLCBub2RlQikge1xuICBpZiAoIShub2RlQSAmJiBub2RlQikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5vZGVBLmlkICYmIG5vZGVBLmlkICE9PSBub2RlQi5pZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobm9kZUEubm9kZU5hbWUgJiYgbm9kZUEubm9kZU5hbWUgIT09IG5vZGVCLm5vZGVOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChub2RlQS5jbGFzc0xpc3QgJiYgKCFub2RlQi5jbGFzc0xpc3QgfHwgbm9kZUEuY2xhc3NMaXN0Lm1hcChmdW5jdGlvbiAoY2xhc3NOYW1lQSkge1xuICAgIHJldHVybiBjbGFzc05hbWVBLnRvTG93ZXJDYXNlKCk7XG4gIH0pLnNvbWUoZnVuY3Rpb24gKGNsYXNzTmFtZUEpIHtcbiAgICByZXR1cm4gbm9kZUIuY2xhc3NMaXN0Lm1hcChmdW5jdGlvbiAoY2xhc3NOYW1lQikge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZUIudG9Mb3dlckNhc2UoKTtcbiAgICB9KS5pbmRleE9mKGNsYXNzTmFtZUEpID09PSAtMTtcbiAgfSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChub2RlQS5udGhDaGlsZCkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChub2RlQS5udGhDaGlsZCwgMTApO1xuICAgIGlmIChpc05hTihwYXJzZWQpKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMobm9kZUIubnRoQ2hpbGQgJSAyKSA9PT0gKG5vZGVBLm50aENoaWxkID09PSAnb2RkJyA/IDEgOiAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZCA9PT0gbm9kZUIubnRoQ2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGNoZWNrcyB0aGF0IG5vZGVQYXRoIGluY2x1ZGVzLCBpbiBvcmRlciwgYWxsIG5vZGVzIHNwZWNpZmllZCBpbiBwYXJzZWRTZWxlY3RvclxuZnVuY3Rpb24gc2VsZWN0b3JNYXRjaGVzKG5vZGVQYXRoLCBwYXJzZWRTZWxlY3Rvcikge1xuICB2YXIgdG9wRG93bk5vZGVQYXRoID0gbm9kZVBhdGguc2xpY2UoMCkucmV2ZXJzZSgpO1xuICB2YXIgbWF0Y2hJbmRleDtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBhcnNlZFNlbGVjdG9yKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBzZWxlY3Rvck5vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGlmIChzZWxlY3Rvck5vZGUuZGlyZWN0RGVzYykge1xuICAgICAgICBpZiAobm9kZXNNYXRjaC5hcHBseSh2b2lkIDAsIFtzZWxlY3Rvck5vZGVdLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KSh0b3BEb3duTm9kZVBhdGguc3BsaWNlKDAsIDEpKSkpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXRjaEluZGV4ID0gKDAsIF9maW5kSW5kZXguZGVmYXVsdCkodG9wRG93bk5vZGVQYXRoLCBmdW5jdGlvbiAocGF0aE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzTWF0Y2goc2VsZWN0b3JOb2RlLCBwYXRoTm9kZSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChtYXRjaEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0b3BEb3duTm9kZVBhdGguc3BsaWNlKDAsIG1hdGNoSW5kZXggKyAxKTtcbiAgICB9O1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKCk7XG4gICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgIGlmICgoMCwgX3R5cGVvZjIuZGVmYXVsdCkoX3JldCkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2VuZFRlbGVtZXRyeURhdGEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3NlbmRUZWxlbWV0cnlEYXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5zZW5kVGVsZW1ldHJ5ID0gc2VuZFRlbGVtZXRyeTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc2VuZEVycm9yVGVsZW1ldHJ5O1xudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXCIpKTtcbnZhciBfbG9nRXJyb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9nRXJyb3IgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL2xvZ0Vycm9yLmpzXCIpKTtcbnZhciBfVHJhY2VLaXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVHJhY2VLaXQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL1RyYWNlS2l0LmpzXCIpKTtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbnZhciBTQ1JJUFRfVkVSU0lPTiA9ICB0cnVlID8gXCJiMGRiMmJkZTEzYWJiZGFhYzRkZGY3NjUxZTdiZTYwZWI2MzljY2Y3XCIgOiAwO1xuZnVuY3Rpb24gX3NlbmRUb1NlbnRyeShkYXRhKSB7XG4gIHZhciBYSFIgPSB3aW5kb3cuX2xyWE1MSHR0cFJlcXVlc3QgfHwgWE1MSHR0cFJlcXVlc3Q7XG4gIHRyeSB7XG4gICAgdmFyIHJlcSA9IG5ldyBYSFIoKTtcbiAgICB2YXIgbWVzc2FnZSA9IGRhdGEubWVzc2FnZTtcbiAgICB2YXIgdXJsID0gJ2h0dHBzOi8vZS5sb2dyb2NrZXQuY29tL2FwaS8zL3N0b3JlLz9zZW50cnlfdmVyc2lvbj03JnNlbnRyeV9jbGllbnQ9aHR0cCUyRjMuOC4wJnNlbnRyeV9rZXk9YjY0MTYyYjQxODdhNGM1Y2FhZThhNjhhN2UyOTE3OTMnO1xuICAgIHJlcS5vcGVuKCdQT1NUJywgdXJsKTtcbiAgICByZXEuc2VuZChKU09OLnN0cmluZ2lmeShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBsb2dnZXI6ICdqYXZhc2NyaXB0JyxcbiAgICAgIHBsYXRmb3JtOiAnamF2YXNjcmlwdCcsXG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnVXNlci1BZ2VudCc6IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgfSxcbiAgICAgICAgdXJsOiB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uLmhyZWZcbiAgICAgIH0sXG4gICAgICByZWxlYXNlOiBTQ1JJUFRfVkVSU0lPTixcbiAgICAgIGVudmlyb25tZW50OiAgZmFsc2UgfHwgJ3Rlc3QnXG4gICAgfSwgZGF0YSkpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgKDAsIF9sb2dFcnJvci5kZWZhdWx0KSgnRmFpbGVkIHRvIHNlbmQnLCBlcnIpO1xuICB9XG59XG5mdW5jdGlvbiBzZW5kVGVsZW1ldHJ5KG1lc3NhZ2UsIG1vcmUpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fbHJkZWJ1Zykge1xuICAgIHJldHVybiB2b2lkICgwLCBfbG9nRXJyb3IuZGVmYXVsdCkobWVzc2FnZSk7XG4gIH1cbiAgaWYgKG1vcmUgJiYgbW9yZS5leHRyYSAmJiBtb3JlLmV4dHJhLmFwcElEICYmIHR5cGVvZiBtb3JlLmV4dHJhLmFwcElELmluZGV4T2YgPT09ICdmdW5jdGlvbicgJiYgbW9yZS5leHRyYS5hcHBJRC5pbmRleE9mKCdhdTJkcnAvJykgPT09IDAgJiYgTWF0aC5yYW5kb20oKSA+PSAwLjI1KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9zZW5kVG9TZW50cnkoX29iamVjdFNwcmVhZCh7XG4gICAgbWVzc2FnZTogbWVzc2FnZVxuICB9LCBtb3JlKSk7XG59XG5mdW5jdGlvbiBzZW5kRXJyb3JUZWxlbWV0cnkoZXJyLCBwYXlsb2FkKSB7XG4gIHRyeSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB2YXIgc3RyaW5nUGF5bG9hZDtcbiAgICB0cnkge1xuICAgICAgc3RyaW5nUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLnNsaWNlKDAsIDEwMDApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyaW5nUGF5bG9hZCA9IFwiQ291bGQgbm90IHN0cmluZ2lmeSBwYXlsb2FkOiBcIi5jb25jYXQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBheWxvYWQpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikgey8qIG5hZGEgKi99XG4gICAgfVxuICAgIHZhciBzdGFjaztcbiAgICB0cnkge1xuICAgICAgc3RhY2sgPSBfVHJhY2VLaXQuZGVmYXVsdC5jb21wdXRlU3RhY2tUcmFjZShlcnIpLnN0YWNrLm1hcChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaWxlbmFtZTogZnJhbWUudXJsLFxuICAgICAgICAgIGxpbmVubzogZnJhbWUubGluZSxcbiAgICAgICAgICBjb2xubzogZnJhbWUuY29sdW1uLFxuICAgICAgICAgIGZ1bmN0aW9uOiBmcmFtZS5mdW5jIHx8ICc/J1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvKiBuYWRhICovXG4gICAgfVxuICAgIF9zZW5kVG9TZW50cnkoe1xuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIGV4dHJhOiB7XG4gICAgICAgIHN0cmluZ1BheWxvYWQ6IHN0cmluZ1BheWxvYWRcbiAgICAgIH0sXG4gICAgICBleGNlcHRpb246IHtcbiAgICAgICAgdmFsdWVzOiBbe1xuICAgICAgICAgIHR5cGU6IGVyci50eXBlLFxuICAgICAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgICAgIHN0YWNrdHJhY2U6IHtcbiAgICAgICAgICAgIGZyYW1lczogc3RhY2tcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgICgwLCBfbG9nRXJyb3IuZGVmYXVsdCkoJ0ZhaWxlZCB0byBzZW5kJywgZXJyKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3NldEZyb21BcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3NldEZyb21BcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNldEZyb21BcnJheTtcbmZ1bmN0aW9uIHNldEZyb21BcnJheShhcnJheSkge1xuICB2YXIgc2V0ID0gbmV3IFNldCgpO1xuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBzZXQuYWRkKGVsKTtcbiAgfSk7XG4gIHJldHVybiBzZXQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2V0VG9BcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9zZXRUb0FycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNldFRvQXJyYXk7XG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goZWwpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3NoYWxsb3dBcnNvbmlmeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3NoYWxsb3dBcnNvbmlmeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNoYWxsb3dBcnNvbmlmeTtcbmZ1bmN0aW9uIHNoYWxsb3dBcnNvbmlmeSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdbb2JqZWN0IFVuZGVmaW5lZF0nOlxuICAgICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuZGVmaW5lZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdbb2JqZWN0IE51bGxdJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBudWxsOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvb2xlYW46IHtcbiAgICAgICAgICAgIGJvb2w6IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBkb3VibGU6IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBzdHJpbmc6IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb2JqZWN0OiB7XG4gICAgICAgICAgICBtYXA6IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcnJheToge1xuICAgICAgICAgICAgbWFwOiB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICBkb3VibGU6IHZhbHVlLmdldFRpbWUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBzdHJpbmc6IFwiXCIuY29uY2F0KHZhbHVlLm5hbWUsIFwiOiBcIikuY29uY2F0KHZhbHVlLm1lc3NhZ2UpXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdW5zdXBwb3J0ZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9zaGFsbG93RGVhcnNvbmlmeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvc2hhbGxvd0RlYXJzb25pZnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNoYWxsb3dEZWFyc29uaWZ5O1xuLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cblxuZnVuY3Rpb24gc2hhbGxvd0RlYXJzb25pZnkodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB2YWx1ZS50eXBlIHx8IE9iamVjdC5rZXlzKHZhbHVlKVswXTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICBjYXNlICdudWxsJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5ib29sZWFuLmJvb2w7XG4gICAgICB9XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm51bWJlci5kb3VibGU7XG4gICAgICB9XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZy5zdHJpbmc7XG4gICAgICB9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm9iamVjdC5tYXA7XG4gICAgICB9XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuYXJyYXkubWFwKS5yZWR1Y2UoZnVuY3Rpb24gKGFycmF5LCBrZXkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICBhcnJheVtrZXldID0gdmFsdWUuYXJyYXkubWFwW2tleV07XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9LCBbXSk7XG4gICAgICB9XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS5kYXRlLmRvdWJsZSk7XG4gICAgICB9XG4gICAgY2FzZSAndW5zdXBwb3J0ZWQnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gdmFsdWUudW5zdXBwb3J0ZWQudHlwZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSBpbiBzaGFsbG93RGVhcnNvbmlmeTogXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICB9XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy9zdGFydHNXaXRoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3N0YXJ0c1dpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc3RhcnRzV2l0aDtcbmZ1bmN0aW9uIHN0YXJ0c1dpdGgodmFsdWUsIHNlYXJjaCkge1xuICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICByZXR1cm4gdmFsdWUgJiYgc2VhcmNoICYmIHZhbHVlLnN1YnN0cmluZyhwb3MsIHBvcyArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvdHlwZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3R5cGVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3VzZXJUcmFpdFN0cmluZ3MudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9zcmMvdXNlclRyYWl0U3RyaW5ncy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5wYXJzZVVzZXJUcmFpdFN0cmluZyA9IGV4cG9ydHMuZW5jb2RlVXNlclRyYWl0U3RyaW5nID0gdm9pZCAwO1xuLy8gQ2hhcmFjdGVyIHVzZWQgdG8gc2VwYXJhdGUga2V5L3ZhbHVlIHBhaXJzIHdoZW4gY29uY2F0ZW5hdGVkLCBpLmUuIFwia2V5OnZhbHVlXCI6XG52YXIgVVNFUl9UUkFJVF9ERUxJTUlURVIgPSAnOic7XG5cbi8vIFN0cmluZyB1c2VkIHRvIHRlbXBvcmFyaWx5IGVzY2FwZSBhYm92ZSB2YWx1ZSB3aGVuIGluY2x1ZGVkIGluIGEgdXNlci1kZWZpbmVkIHN0cmluZzpcbnZhciBkZWxpbWl0ZXJSZXBsYWNlID0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNik7XG5cbi8qKiBFbmNvZGUgc3RyaW5ncyB0byBiZSB1c2VkIGFzIGEgY3VzdG9tIGtleS12YWx1ZSBwYWlyLCBleC4gZm9yIHVzZXIgdHJhaXRzICovXG52YXIgZW5jb2RlVXNlclRyYWl0U3RyaW5nID0gZnVuY3Rpb24gZW5jb2RlVXNlclRyYWl0U3RyaW5nKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBhcmdzXG4gIC8vIEVzY2FwZSBpbnN0YW5jZXMgb2YgZGVsaW1pdGVyIHZhbHVlIGluIHVzZXItZGVmaW5lZCB0ZXh0OlxuICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChVU0VSX1RSQUlUX0RFTElNSVRFUiwgJ2cnKSwgZGVsaW1pdGVyUmVwbGFjZSk7XG4gIH0pLmpvaW4oVVNFUl9UUkFJVF9ERUxJTUlURVIpO1xufTtcblxuLyoqIFNwbGl0IGVuY29kZWQgdXNlciB0cmFpdCBzdHJpbmcgaW50byBvcmlnaW5hbCBrZXkgJiB2YWx1ZSAqL1xuZXhwb3J0cy5lbmNvZGVVc2VyVHJhaXRTdHJpbmcgPSBlbmNvZGVVc2VyVHJhaXRTdHJpbmc7XG52YXIgcGFyc2VVc2VyVHJhaXRTdHJpbmcgPSBmdW5jdGlvbiBwYXJzZVVzZXJUcmFpdFN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIG5vbkVtcHR5U3RyID0gc3RyaW5nIHx8IFVTRVJfVFJBSVRfREVMSU1JVEVSOyAvLyBFbnN1cmUgYXQgbGVhc3QgdHdvIHN0cmluZ3Mgd2lsbCBiZSByZXR1cm5lZFxuICByZXR1cm4gbm9uRW1wdHlTdHIuc3BsaXQoVVNFUl9UUkFJVF9ERUxJTUlURVIpXG4gIC8vIFJlc3RvcmUgcHJldmlvdXNseSBlc2NhcGVkIGluc3RhbmNlcyBvZiBkZWxpbWl0ZXIgY2hhcmFjdGVyOlxuICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChkZWxpbWl0ZXJSZXBsYWNlLCAnZycpLCBVU0VSX1RSQUlUX0RFTElNSVRFUik7XG4gIH0pO1xufTtcbmV4cG9ydHMucGFyc2VVc2VyVHJhaXRTdHJpbmcgPSBwYXJzZVVzZXJUcmFpdFN0cmluZztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL3NyYy91dWlkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvc3JjL3V1aWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdXVpZDtcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuZnVuY3Rpb24gdXVpZChhKSB7XG4gIHJldHVybiBhID8gKGEgXiBNYXRoLnJhbmRvbSgpICogMTYgPj4gYSAvIDQpLnRvU3RyaW5nKDE2KSA6IChbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExKS5yZXBsYWNlKC9bMDE4XS9nLCB1dWlkKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9sb2dyb2NrZXQvc3JjL0xvZ1JvY2tldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvbG9ncm9ja2V0L3NyYy9Mb2dSb2NrZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMuTUFYX1FVRVVFX1NJWkUgPSB2b2lkIDA7XG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjayAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanNcIikpO1xudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXCIpKTtcbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1wiKSk7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanNcIikpO1xudmFyIF9uZXR3b3JrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAbG9ncm9ja2V0L25ldHdvcmsgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvbmV0d29yay9zcmMvaW5kZXguanNcIikpO1xudmFyIF9leGNlcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGxvZ3JvY2tldC9leGNlcHRpb25zICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L2V4Y2VwdGlvbnMvc3JjL2luZGV4LmpzXCIpO1xudmFyIF9jb25zb2xlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAbG9ncm9ja2V0L2NvbnNvbGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvY29uc29sZS9zcmMvaW5kZXguanNcIikpO1xudmFyIF9yZWR1eCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBsb2dyb2NrZXQvcmVkdXggKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvcmVkdXgvc3JjL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBNQVhfUVVFVUVfU0laRSA9IDEwMDA7XG5leHBvcnRzLk1BWF9RVUVVRV9TSVpFID0gTUFYX1FVRVVFX1NJWkU7XG52YXIgY29uc2lkZXJJbmdlc3RTZXJ2ZXJPcHRpb24gPSBmdW5jdGlvbiBjb25zaWRlckluZ2VzdFNlcnZlck9wdGlvbigpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgIGluZ2VzdFNlcnZlciA9IF9yZWYuaW5nZXN0U2VydmVyLFxuICAgIG9wdGlvbnMgPSAoMCwgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMi5kZWZhdWx0KShfcmVmLCBbXCJpbmdlc3RTZXJ2ZXJcIl0pO1xuICBpZiAoaW5nZXN0U2VydmVyKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgc2VydmVyVVJMOiBcIlwiLmNvbmNhdChpbmdlc3RTZXJ2ZXIsIFwiL2lcIiksXG4gICAgICBzdGF0c1VSTDogXCJcIi5jb25jYXQoaW5nZXN0U2VydmVyLCBcIi9zXCIpXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xudmFyIExvZ1JvY2tldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExvZ1JvY2tldCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIExvZ1JvY2tldCk7XG4gICAgdGhpcy5fYnVmZmVyID0gW107XG4gICAgLy8gVE9ETzogdGVzdHMgZm9yIHRoZXNlIGV4cG9zZWQgbWV0aG9kcy5cbiAgICBbJ2xvZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InLCAnZGVidWcnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIF90aGlzW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYWRkRXZlbnQoJ2xyLmNvcmUuTG9nRXZlbnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNvbnNvbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSAnZXJyb3InICYmIGNvbnNvbGVPcHRpb25zLnNob3VsZEFnZ3JlZ2F0ZUNvbnNvbGVFcnJvcnMpIHtcbiAgICAgICAgICAgIF9leGNlcHRpb25zLkNhcHR1cmUuY2FwdHVyZU1lc3NhZ2UoX3RoaXMsIGFyZ3NbMF0sIGFyZ3MsIHt9LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvZ0xldmVsOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB7XG4gICAgICAgICAgc2hvdWxkQ2FwdHVyZVN0YWNrVHJhY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnN0YWxsZWQgPSBbXTtcblxuICAgIC8vIGV4cG9zZSBhIGNhbGxiYWNrIHRvIGdldCB0aGUgc2Vzc2lvbiBVUkwgZnJvbSB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICB3aW5kb3cuX2xyX3N1cmxfY2IgPSB0aGlzLmdldFNlc3Npb25VUkwuYmluZCh0aGlzKTtcbiAgfVxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShMb2dSb2NrZXQsIFt7XG4gICAga2V5OiBcImFkZEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50KHR5cGUsIGdldE1lc3NhZ2UpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMuX3J1bihmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5hZGRFdmVudCh0eXBlLCBnZXRNZXNzYWdlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdHMpLCB7fSwge1xuICAgICAgICAgIHRpbWVPdmVycmlkZTogdGltZVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Mb2dnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Mb2dnZXIobG9nZ2VyKSB7XG4gICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXI7XG4gICAgICB3aGlsZSAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLl9idWZmZXIuc2hpZnQoKTtcbiAgICAgICAgZih0aGlzLl9sb2dnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ydW4oZikge1xuICAgICAgaWYgKHRoaXMuX2lzRGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xvZ2dlcikge1xuICAgICAgICBmKHRoaXMuX2xvZ2dlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+PSBNQVhfUVVFVUVfU0laRSkge1xuICAgICAgICAgIHRoaXMuX2lzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2FybignTG9nUm9ja2V0OiBzY3JpcHQgZGlkIG5vdCBsb2FkLiBDaGVjayB0aGF0IHlvdSBoYXZlIGEgdmFsaWQgbmV0d29yayBjb25uZWN0aW9uLicpO1xuICAgICAgICAgIHRoaXMudW5pbnN0YWxsKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlci5wdXNoKGYuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChhcHBJRCkge1xuICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgIHZhciBfb3B0cyRzaG91bGRBdWdtZW50TlAgPSBvcHRzLnNob3VsZEF1Z21lbnROUFMsXG4gICAgICAgICAgc2hvdWxkQXVnbWVudE5QUyA9IF9vcHRzJHNob3VsZEF1Z21lbnROUCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRzJHNob3VsZEF1Z21lbnROUCxcbiAgICAgICAgICBfb3B0cyRzaG91bGRQYXJzZVhIUkIgPSBvcHRzLnNob3VsZFBhcnNlWEhSQmxvYixcbiAgICAgICAgICBzaG91bGRQYXJzZVhIUkJsb2IgPSBfb3B0cyRzaG91bGRQYXJzZVhIUkIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdHMkc2hvdWxkUGFyc2VYSFJCLFxuICAgICAgICAgIF9vcHRzJHNob3VsZERldGVjdEV4YyA9IG9wdHMuc2hvdWxkRGV0ZWN0RXhjZXB0aW9ucyxcbiAgICAgICAgICBzaG91bGREZXRlY3RFeGNlcHRpb25zID0gX29wdHMkc2hvdWxkRGV0ZWN0RXhjID09PSB2b2lkIDAgPyB0cnVlIDogX29wdHMkc2hvdWxkRGV0ZWN0RXhjO1xuICAgICAgICBpZiAoc2hvdWxkRGV0ZWN0RXhjZXB0aW9ucykge1xuICAgICAgICAgIHRoaXMuX2luc3RhbGxlZC5wdXNoKCgwLCBfZXhjZXB0aW9ucy5yZWdpc3RlckV4Y2VwdGlvbnMpKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnN0YWxsZWQucHVzaCgoMCwgX25ldHdvcmsuZGVmYXVsdCkodGhpcywge1xuICAgICAgICAgIHNob3VsZEF1Z21lbnROUFM6ICEhc2hvdWxkQXVnbWVudE5QUyxcbiAgICAgICAgICBzaG91bGRQYXJzZVhIUkJsb2I6ICEhc2hvdWxkUGFyc2VYSFJCbG9iXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5faW5zdGFsbGVkLnB1c2goKDAsIF9jb25zb2xlLmRlZmF1bHQpKHRoaXMpKTtcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3J1bihmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyLmluaXQoYXBwSUQsIGNvbnNpZGVySW5nZXN0U2VydmVyT3B0aW9uKG9wdHMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5fcnVuKGZ1bmN0aW9uIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLnN0YXJ0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5pbnN0YWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuaW5zdGFsbCgpIHtcbiAgICAgIHRoaXMuX2luc3RhbGxlZC5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2J1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5fcnVuKGZ1bmN0aW9uIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLnVuaW5zdGFsbCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlkZW50aWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlkZW50aWZ5KGlkLCBvcHRzKSB7XG4gICAgICB0aGlzLl9ydW4oZnVuY3Rpb24gKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaWRlbnRpZnkoaWQsIG9wdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0TmV3U2Vzc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydE5ld1Nlc3Npb24oKSB7XG4gICAgICB0aGlzLl9ydW4oZnVuY3Rpb24gKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuc3RhcnROZXdTZXNzaW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhY2soY3VzdG9tRXZlbnROYW1lLCBldmVudFByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3J1bihmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci50cmFjayhjdXN0b21FdmVudE5hbWUsIGV2ZW50UHJvcGVydGllcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2Vzc2lvblVSTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXNzaW9uVVJMKGNiKSB7XG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTG9nUm9ja2V0OiBtdXN0IHBhc3MgY2FsbGJhY2sgdG8gZ2V0U2Vzc2lvblVSTCgpJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ydW4oZnVuY3Rpb24gKGxvZ2dlcikge1xuICAgICAgICBpZiAobG9nZ2VyLmdldFNlc3Npb25VUkwpIHtcbiAgICAgICAgICBsb2dnZXIuZ2V0U2Vzc2lvblVSTChjYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobG9nZ2VyLnJlY29yZGluZ1VSTCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZlcnNpb24oY2IpIHtcbiAgICAgIHRoaXMuX3J1bihmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgIGNiKGxvZ2dlci52ZXJzaW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYXB0dXJlTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYXB0dXJlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBfZXhjZXB0aW9ucy5DYXB0dXJlLmNhcHR1cmVNZXNzYWdlKHRoaXMsIG1lc3NhZ2UsIFttZXNzYWdlXSwgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhcHR1cmVFeGNlcHRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIF9leGNlcHRpb25zLkNhcHR1cmUuY2FwdHVyZUV4Y2VwdGlvbih0aGlzLCBleGNlcHRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyICYmIHRoaXMuX2xvZ2dlci52ZXJzaW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXNzaW9uVVJMXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyICYmIHRoaXMuX2xvZ2dlci5yZWNvcmRpbmdVUkw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY29yZGluZ1VSTFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlciAmJiB0aGlzLl9sb2dnZXIucmVjb3JkaW5nVVJMO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWNvcmRpbmdJRFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlciAmJiB0aGlzLl9sb2dnZXIucmVjb3JkaW5nSUQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRocmVhZElEXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyICYmIHRoaXMuX2xvZ2dlci50aHJlYWRJRDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGFiSURcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2dnZXIgJiYgdGhpcy5fbG9nZ2VyLnRhYklEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWR1eEVuaGFuY2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHV4RW5oYW5jZXIoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICByZXR1cm4gKDAsIF9yZWR1eC5jcmVhdGVFbmhhbmNlcikodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZHV4TWlkZGxld2FyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWR1eE1pZGRsZXdhcmUoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICByZXR1cm4gKDAsIF9yZWR1eC5jcmVhdGVNaWRkbGV3YXJlKSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEaXNhYmxlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuX2lzRGlzYWJsZWQgfHwgdGhpcy5fbG9nZ2VyICYmIHRoaXMuX2xvZ2dlci5faXNEaXNhYmxlZCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2dSb2NrZXQ7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExvZ1JvY2tldDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9sb2dyb2NrZXQvc3JjL21ha2VMb2dSb2NrZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9sb2dyb2NrZXQvc3JjL21ha2VMb2dSb2NrZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdCAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtYWtlTG9nUm9ja2V0O1xudmFyIF9Mb2dSb2NrZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vTG9nUm9ja2V0ICovIFwiLi9wYWNrYWdlcy9sb2dyb2NrZXQvc3JjL0xvZ1JvY2tldC5qc1wiKSk7XG52YXIgUkVBQ1RfTkFUSVZFX05PVElDRSA9ICdMb2dSb2NrZXQgZG9lcyBub3QgeWV0IHN1cHBvcnQgUmVhY3QgTmF0aXZlLic7XG52YXIgbWFrZU5vb3BQb2x5ZmlsbCA9IGZ1bmN0aW9uIG1ha2VOb29wUG9seWZpbGwoKSB7XG4gIHJldHVybiB7XG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHt9LFxuICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gdW5pbnN0YWxsKCkge30sXG4gICAgbG9nOiBmdW5jdGlvbiBsb2coKSB7fSxcbiAgICBpbmZvOiBmdW5jdGlvbiBpbmZvKCkge30sXG4gICAgd2FybjogZnVuY3Rpb24gd2FybigpIHt9LFxuICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcigpIHt9LFxuICAgIGRlYnVnOiBmdW5jdGlvbiBkZWJ1ZygpIHt9LFxuICAgIGFkZEV2ZW50OiBmdW5jdGlvbiBhZGRFdmVudCgpIHt9LFxuICAgIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSgpIHt9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHt9LFxuICAgIGdldCB0aHJlYWRJRCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0IHJlY29yZGluZ0lEKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBnZXQgcmVjb3JkaW5nVVJMKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZWR1eEVuaGFuY2VyOiBmdW5jdGlvbiByZWR1eEVuaGFuY2VyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0sXG4gICAgcmVkdXhNaWRkbGV3YXJlOiBmdW5jdGlvbiByZWR1eE1pZGRsZXdhcmUoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9LFxuICAgIHRyYWNrOiBmdW5jdGlvbiB0cmFjaygpIHt9LFxuICAgIGdldFNlc3Npb25VUkw6IGZ1bmN0aW9uIGdldFNlc3Npb25VUkwoKSB7fSxcbiAgICBnZXRWZXJzaW9uOiBmdW5jdGlvbiBnZXRWZXJzaW9uKCkge30sXG4gICAgc3RhcnROZXdTZXNzaW9uOiBmdW5jdGlvbiBzdGFydE5ld1Nlc3Npb24oKSB7fSxcbiAgICBvbkxvZ2dlcjogZnVuY3Rpb24gb25Mb2dnZXIoKSB7fSxcbiAgICBzZXRDbG9jazogZnVuY3Rpb24gc2V0Q2xvY2soKSB7fSxcbiAgICBjYXB0dXJlTWVzc2FnZTogZnVuY3Rpb24gY2FwdHVyZU1lc3NhZ2UoKSB7fSxcbiAgICBjYXB0dXJlRXhjZXB0aW9uOiBmdW5jdGlvbiBjYXB0dXJlRXhjZXB0aW9uKCkge31cbiAgfTtcbn07XG5mdW5jdGlvbiBtYWtlTG9nUm9ja2V0KCkge1xuICB2YXIgZ2V0TG9nZ2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFJFQUNUX05BVElWRV9OT1RJQ0UpO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh3aW5kb3cuX2Rpc2FibGVMb2dSb2NrZXQpIHtcbiAgICAgIHJldHVybiBtYWtlTm9vcFBvbHlmaWxsKCk7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuTXV0YXRpb25PYnNlcnZlciAmJiB3aW5kb3cuV2Vha01hcCkge1xuICAgICAgLy8gU2F2ZSB3aW5kb3cgZ2xvYmFscyB0aGF0IHdlIHJlbHkgb24uXG4gICAgICB3aW5kb3cuX2xyTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IF9Mb2dSb2NrZXQuZGVmYXVsdCgpO1xuICAgICAgZ2V0TG9nZ2VyKGluc3RhbmNlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1ha2VOb29wUG9seWZpbGwoKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9sb2dyb2NrZXQvc3JjL3NldHVwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL2xvZ3JvY2tldC9zcmMvc2V0dXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc2V0dXA7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanNcIikpO1xudmFyIF9tYWtlTG9nUm9ja2V0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21ha2VMb2dSb2NrZXQgKi8gXCIuL3BhY2thZ2VzL2xvZ3JvY2tldC9zcmMvbWFrZUxvZ1JvY2tldC5qc1wiKSk7XG52YXIgQ0ROX1NFUlZFUl9NQVAgPSB7XG4gICdjZG4ubG9ncm9ja2V0LmlvJzogJ2h0dHBzOi8vci5sb2dyb2NrZXQuaW8nLFxuICAnY2RuLmxyLWluZ2VzdC5pbyc6ICdodHRwczovL3IubHItaW5nZXN0LmlvJyxcbiAgJ2Nkbi5sci1pbi5jb20nOiAnaHR0cHM6Ly9yLmxyLWluLmNvbScsXG4gICdjZG4ubHItaW4tcHJvZC5jb20nOiAnaHR0cHM6Ly9yLmxyLWluLXByb2QuY29tJyxcbiAgJ2Nkbi5sci1pbmdlc3QuY29tJzogJ2h0dHBzOi8vci5sci1pbmdlc3QuY29tJyxcbiAgJ2Nkbi5pbmdlc3QtbHIuY29tJzogJ2h0dHBzOi8vci5pbmdlc3QtbHIuY29tJyxcbiAgJ2Nkbi5sci1pbnRha2UuY29tJzogJ2h0dHBzOi8vci5sci1pbnRha2UuY29tJyxcbiAgJ2Nkbi1zdGFnaW5nLmxvZ3JvY2tldC5pbyc6ICdodHRwczovL3N0YWdpbmctaS5sb2dyb2NrZXQuaW8nLFxuICAnY2RuLXN0YWdpbmcubHItaW5nZXN0LmlvJzogJ2h0dHBzOi8vc3RhZ2luZy1pLmxyLWluZ2VzdC5pbycsXG4gICdjZG4tc3RhZ2luZy5sci1pbi5jb20nOiAnaHR0cHM6Ly9zdGFnaW5nLWkubHItaW4uY29tJyxcbiAgJ2Nkbi1zdGFnaW5nLmxyLWluLXByb2QuY29tJzogJ2h0dHBzOi8vc3RhZ2luZy1pLmxyLWluLXByb2QuY29tJyxcbiAgJ2Nkbi1zdGFnaW5nLmxyLWluZ2VzdC5jb20nOiAnaHR0cHM6Ly9zdGFnaW5nLWkubHItaW5nZXN0LmNvbScsXG4gICdjZG4tc3RhZ2luZy5pbmdlc3QtbHIuY29tJzogJ2h0dHBzOi8vc3RhZ2luZy1pLmluZ2VzdC1sci5jb20nLFxuICAnY2RuLXN0YWdpbmcubHItaW50YWtlLmNvbSc6ICdodHRwczovL3N0YWdpbmctaS5sci1pbnRha2UuY29tJ1xufTtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgZW50ZXJwcmlzZVNlcnZlciA9IF9yZWYuZW50ZXJwcmlzZVNlcnZlcixcbiAgICBfcmVmJHNka1ZlcnNpb24gPSBfcmVmLnNka1ZlcnNpb24sXG4gICAgc2RrVmVyc2lvbiA9IF9yZWYkc2RrVmVyc2lvbiA9PT0gdm9pZCAwID8gXCI2LjAuMVwiIDogX3JlZiRzZGtWZXJzaW9uLFxuICAgIG9wdHMgPSAoMCwgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMi5kZWZhdWx0KShfcmVmLCBbXCJlbnRlcnByaXNlU2VydmVyXCIsIFwic2RrVmVyc2lvblwiXSk7XG4gIHZhciBzY3JpcHRPcmlnaW4gPSAgZmFsc2UgPyAwIDogJ2h0dHBzOi8vY2RuLmxvZ3JvY2tldC5pbyc7XG4gIHZhciBzY3JpcHRJbmdlc3Q7XG4gIGlmIChzZGtWZXJzaW9uID09PSAnc2NyaXB0Jykge1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgICAgdmFyIHNjcmlwdFRhZyA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHNjcmlwdFRhZy5zcmMubWF0Y2goL14oaHR0cHM/OlxcL1xcLyhbXlxcXFxdKykpXFwvLiskLyk7XG4gICAgICB2YXIgc2NyaXB0SG9zdG5hbWUgPSBtYXRjaGVzICYmIG1hdGNoZXNbMl07XG4gICAgICBpZiAoc2NyaXB0SG9zdG5hbWUgJiYgQ0ROX1NFUlZFUl9NQVBbc2NyaXB0SG9zdG5hbWVdKSB7XG4gICAgICAgIHNjcmlwdE9yaWdpbiA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXTtcbiAgICAgICAgc2NyaXB0SW5nZXN0ID0gQ0ROX1NFUlZFUl9NQVBbc2NyaXB0SG9zdG5hbWVdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8qIG5vLW9wICovXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE5QTVxuICAgIHNjcmlwdE9yaWdpbiA9ICBmYWxzZSA/IDAgOiAnaHR0cHM6Ly9jZG4ubHItaW50YWtlLmNvbSc7XG4gICAgc2NyaXB0SW5nZXN0ID0gIGZhbHNlID8gMCA6ICdodHRwczovL3IubHItaW50YWtlLmNvbSc7XG4gIH1cbiAgdmFyIHNka1NlcnZlciA9IG9wdHMuc2RrU2VydmVyIHx8IGVudGVycHJpc2VTZXJ2ZXI7XG4gIHZhciBpbmdlc3RTZXJ2ZXIgPSBvcHRzLmluZ2VzdFNlcnZlciB8fCBlbnRlcnByaXNlU2VydmVyIHx8IHNjcmlwdEluZ2VzdDtcbiAgdmFyIGluc3RhbmNlID0gKDAsIF9tYWtlTG9nUm9ja2V0LmRlZmF1bHQpKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgaWYgKGluZ2VzdFNlcnZlcikge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuX19TREtDT05GSUdfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93Ll9fU0RLQ09ORklHX18gPSB7fTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5fX1NES0NPTkZJR19fLnNlcnZlclVSTCA9IFwiXCIuY29uY2F0KGluZ2VzdFNlcnZlciwgXCIvaVwiKTtcbiAgICAgIHdpbmRvdy5fX1NES0NPTkZJR19fLnN0YXRzVVJMID0gXCJcIi5jb25jYXQoaW5nZXN0U2VydmVyLCBcIi9zXCIpO1xuICAgIH1cbiAgICBpZiAoc2RrU2VydmVyKSB7XG4gICAgICBzY3JpcHQuc3JjID0gXCJcIi5jb25jYXQoc2RrU2VydmVyLCBcIi9sb2dnZXIubWluLmpzXCIpO1xuICAgIH0gZWxzZSBpZiAod2luZG93Ll9fU0RLQ09ORklHX18gJiYgd2luZG93Ll9fU0RLQ09ORklHX18ubG9nZ2VyVVJMKSB7XG4gICAgICBzY3JpcHQuc3JjID0gd2luZG93Ll9fU0RLQ09ORklHX18ubG9nZ2VyVVJMO1xuICAgIH0gZWxzZSBpZiAod2luZG93Ll9sckFzeW5jU2NyaXB0KSB7XG4gICAgICBzY3JpcHQuc3JjID0gd2luZG93Ll9sckFzeW5jU2NyaXB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHQuc3JjID0gXCJcIi5jb25jYXQoc2NyaXB0T3JpZ2luLCBcIi9sb2dnZXItMS5taW4uanNcIik7XG4gICAgfVxuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBCcmF2ZSBicm93c2VyOiBBZHZlcnRpc2VzIGl0cyB1c2VyLWFnZW50IGFzIENocm9tZSAjIy4jIy4uLiB0aGVuXG4gICAgICAvLyBsb2FkcyBsb2dnZXIubWluLmpzLCBidXQgYmxvY2tzIHRoZSBleGVjdXRpb24gb2YgdGhlIHNjcmlwdFxuICAgICAgLy8gY2F1c2luZyBfTFJsb2dnZXIgdG8gYmUgdW5kZWZpbmVkLiAgTGV0J3MgbWFrZSBzdXJlIGl0cyB0aGVyZSBmaXJzdC5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Ll9MUkxvZ2dlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5vbkxvZ2dlcihuZXcgd2luZG93Ll9MUkxvZ2dlcih7XG4gICAgICAgICAgc2RrVmVyc2lvbjogc2RrVmVyc2lvblxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0xvZ1JvY2tldDogc2NyaXB0IGV4ZWN1dGlvbiBoYXMgYmVlbiBibG9ja2VkIGJ5IGEgcHJvZHVjdCBvciBzZXJ2aWNlLicpO1xuICAgICAgICBpbnN0YW5jZS51bmluc3RhbGwoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc29sZS53YXJuKCdMb2dSb2NrZXQ6IHNjcmlwdCBjb3VsZCBub3QgbG9hZC4gQ2hlY2sgdGhhdCB5b3UgaGF2ZSBhIHZhbGlkIG5ldHdvcmsgY29ubmVjdGlvbi4nKTtcbiAgICAgIGluc3RhbmNlLnVuaW5zdGFsbCgpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qc1wiKSxcbiAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhc2hDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc2hDbGVhciAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanNcIiksXG4gICAgaGFzaERlbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc2hEZWxldGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qc1wiKSxcbiAgICBoYXNoR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzaEdldCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzXCIpLFxuICAgIGhhc2hIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXNoSGFzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanNcIiksXG4gICAgaGFzaFNldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc2hTZXQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBsaXN0Q2FjaGVDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpc3RDYWNoZUNsZWFyICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzXCIpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpc3RDYWNoZURlbGV0ZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanNcIiksXG4gICAgbGlzdENhY2hlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbGlzdENhY2hlR2V0ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qc1wiKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19saXN0Q2FjaGVIYXMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzXCIpLFxuICAgIGxpc3RDYWNoZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpc3RDYWNoZVNldCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qc1wiKSxcbiAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtYXBDYWNoZUNsZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwQ2FjaGVDbGVhciAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzXCIpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwQ2FjaGVEZWxldGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanNcIiksXG4gICAgbWFwQ2FjaGVHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tYXBDYWNoZUdldCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qc1wiKSxcbiAgICBtYXBDYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21hcENhY2hlSGFzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzXCIpLFxuICAgIG1hcENhY2hlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwQ2FjaGVTZXQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXROYXRpdmUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXROYXRpdmUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE1hcENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTWFwQ2FjaGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanNcIiksXG4gICAgc2V0Q2FjaGVBZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zZXRDYWNoZUFkZCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qc1wiKSxcbiAgICBzZXRDYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NldENhY2hlSGFzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzXCIpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBMaXN0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19MaXN0Q2FjaGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzXCIpLFxuICAgIHN0YWNrQ2xlYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdGFja0NsZWFyICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanNcIiksXG4gICAgc3RhY2tEZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdGFja0RlbGV0ZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qc1wiKSxcbiAgICBzdGFja0dldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3N0YWNrR2V0ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzXCIpLFxuICAgIHN0YWNrSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3RhY2tIYXMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanNcIiksXG4gICAgc3RhY2tTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdGFja1NldCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qc1wiKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXROYXRpdmUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVRpbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVRpbWVzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qc1wiKSxcbiAgICBpc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcmd1bWVudHMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNCdWZmZXIgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qc1wiKSxcbiAgICBpc0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNJbmRleCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzXCIpLFxuICAgIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNUeXBlZEFycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzXCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlcSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXEgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNhc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2FzdFBhdGggKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanNcIiksXG4gICAgdG9LZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190b0tleSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlQdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlQdXNoICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TeW1ib2wgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzXCIpLFxuICAgIGdldFJhd1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldFJhd1RhZyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanNcIiksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3RUb1N0cmluZyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRUYWcgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qc1wiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0TGlrZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNFcXVhbERlZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNFcXVhbERlZXAgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N0YWNrICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzXCIpLFxuICAgIGVxdWFsQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXF1YWxBcnJheXMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanNcIiksXG4gICAgZXF1YWxCeVRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2VxdWFsQnlUYWcgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qc1wiKSxcbiAgICBlcXVhbE9iamVjdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lcXVhbE9iamVjdHMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzXCIpLFxuICAgIGdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldFRhZyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQnVmZmVyICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanNcIiksXG4gICAgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1R5cGVkQXJyYXkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanNcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWF0Y2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3RhY2sgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanNcIiksXG4gICAgYmFzZUlzRXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNFcXVhbCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanNcIiksXG4gICAgaXNNYXNrZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc01hc2tlZCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qc1wiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qc1wiKSxcbiAgICB0b1NvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvU291cmNlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzXCIpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRUYWcgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qc1wiKSxcbiAgICBpc0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNMZW5ndGggKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qc1wiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0TGlrZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZU1hdGNoZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlTWF0Y2hlcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qc1wiKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzXCIpLFxuICAgIGlkZW50aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pZGVudGl0eSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIHByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcm9wZXJ0eSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNQcm90b3R5cGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanNcIiksXG4gICAgbmF0aXZlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25hdGl2ZUtleXMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzTWF0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNNYXRjaCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qc1wiKSxcbiAgICBnZXRNYXRjaERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRNYXRjaERhdGEgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzXCIpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJc0VxdWFsICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzXCIpLFxuICAgIGdldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzXCIpLFxuICAgIGhhc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oYXNJbiAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzXCIpLFxuICAgIGlzS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNLZXkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanNcIiksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNTdHJpY3RDb21wYXJhYmxlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qc1wiKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzXCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG9LZXkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanNcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzXCIpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU29ydGVkSW5kZXhCeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTb3J0ZWRJbmRleEJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzU3ltYm9sICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanNcIik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG52YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDE7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhCeWAgYW5kIGBfLnNvcnRlZExhc3RJbmRleEJ5YFxuICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAqICBpbnRvIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgdmFyIGxvdyA9IDAsXG4gICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmIChoaWdoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcbiAgdmFyIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcbiAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgIGlmICh2YWxJc05hTikge1xuICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHNldExvdykge1xuICAgICAgbG93ID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaCA9IG1pZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb3J0ZWRJbmRleEJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N5bWJvbCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanNcIiksXG4gICAgYXJyYXlNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheU1hcCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTeW1ib2wgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qc1wiKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgaXNLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0tleSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qc1wiKSxcbiAgICBzdHJpbmdUb1BhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdHJpbmdUb1BhdGggKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzXCIpLFxuICAgIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b1N0cmluZyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzXCIpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTZXRDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1NldENhY2hlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzXCIpLFxuICAgIGFycmF5U29tZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5U29tZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanNcIiksXG4gICAgY2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jYWNoZUhhcyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TeW1ib2wgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzXCIpLFxuICAgIFVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19VaW50OEFycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanNcIiksXG4gICAgZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VxICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanNcIiksXG4gICAgZXF1YWxBcnJheXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lcXVhbEFycmF5cyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qc1wiKSxcbiAgICBtYXBUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwVG9BcnJheSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzXCIpLFxuICAgIHNldFRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zZXRUb0FycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanNcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRBbGxLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0QWxsS2V5cyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18uZyA9PSAnb2JqZWN0JyAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nLk9iamVjdCA9PT0gT2JqZWN0ICYmIF9fd2VicGFja19yZXF1aXJlX18uZztcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0QWxsS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRBbGxLZXlzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzXCIpLFxuICAgIGdldFN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRTeW1ib2xzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanNcIiksXG4gICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5cyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNLZXlhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNLZXlhYmxlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNTdHJpY3RDb21wYXJhYmxlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qc1wiKSxcbiAgICBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc05hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJc05hdGl2ZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanNcIiksXG4gICAgZ2V0VmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRWYWx1ZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3ltYm9sICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheUZpbHRlciAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qc1wiKSxcbiAgICBzdHViQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0dWJBcnJheSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19EYXRhVmlldyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qc1wiKSxcbiAgICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19NYXAgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzXCIpLFxuICAgIFByb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19Qcm9taXNlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanNcIiksXG4gICAgU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU2V0ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qc1wiKSxcbiAgICBXZWFrTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fV2Vha01hcCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzXCIpLFxuICAgIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0VGFnICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanNcIiksXG4gICAgdG9Tb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190b1NvdXJjZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jYXN0UGF0aCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qc1wiKSxcbiAgICBpc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcmd1bWVudHMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNJbmRleCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzXCIpLFxuICAgIGlzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0xlbmd0aCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzXCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG9LZXkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanNcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbmF0aXZlQ3JlYXRlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1wiKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG5hdGl2ZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25hdGl2ZUNyZWF0ZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanNcIik7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBuYXRpdmVDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19uYXRpdmVDcmVhdGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzXCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbmF0aXZlQ3JlYXRlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1wiKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTeW1ib2wgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qc1wiKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3JlSnNEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29yZUpzRGF0YSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzXCIpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc29jSW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Fzc29jSW5kZXhPZiAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzb2NJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzb2NJbmRleE9mICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzb2NJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzb2NJbmRleE9mICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qc1wiKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc29jSW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Fzc29jSW5kZXhPZiAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanNcIik7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIEhhc2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19IYXNoICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanNcIiksXG4gICAgTGlzdENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTGlzdENhY2hlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qc1wiKSxcbiAgICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19NYXAgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzXCIpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRNYXBEYXRhICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanNcIik7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TWFwRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldE1hcERhdGEgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TWFwRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldE1hcERhdGEgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qc1wiKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRNYXBEYXRhICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanNcIik7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtZW1vaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZW1vaXplICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qc1wiKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG92ZXJBcmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vdmVyQXJnICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogbW9kdWxlIGRlY29yYXRvciAqLyBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZChtb2R1bGUpO1xudmFyIGZyZWVHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19mcmVlR2xvYmFsICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanNcIik7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSAgdHJ1ZSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgXCJvYmplY3RcIiA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZnJlZUdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZyZWVHbG9iYWwgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qc1wiKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBMaXN0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19MaXN0Q2FjaGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzXCIpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTGlzdENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTGlzdENhY2hlICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qc1wiKSxcbiAgICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19NYXAgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzXCIpLFxuICAgIE1hcENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTWFwQ2FjaGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanNcIik7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG1lbW9pemVDYXBwZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tZW1vaXplQ2FwcGVkICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanNcIik7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTeW1ib2wgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qc1wiKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2dldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXQgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUhhc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUhhc0luICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qc1wiKSxcbiAgICBoYXNQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzUGF0aCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJc0FyZ3VtZW50cyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzRnVuY3Rpb24gKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzXCIpLFxuICAgIGlzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0xlbmd0aCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogbW9kdWxlIGRlY29yYXRvciAqLyBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZChtb2R1bGUpO1xudmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanNcIiksXG4gICAgc3R1YkZhbHNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdHViRmFsc2UgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanNcIik7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSAgdHJ1ZSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgXCJvYmplY3RcIiA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldFRhZyAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzXCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0VGFnICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNUeXBlZEFycmF5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanNcIiksXG4gICAgYmFzZVVuYXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVVuYXJ5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qc1wiKSxcbiAgICBub2RlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25vZGVVdGlsICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzXCIpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlMaWtlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5TGlrZUtleXMgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qc1wiKSxcbiAgICBiYXNlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VLZXlzICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzXCIpLFxuICAgIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE1hcENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTWFwQ2FjaGUgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanNcIik7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUHJvcGVydHkgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzXCIpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUHJvcGVydHlEZWVwICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanNcIiksXG4gICAgaXNLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0tleSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qc1wiKSxcbiAgICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvS2V5ICovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvc29ydGVkTGFzdEluZGV4QnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvc29ydGVkTGFzdEluZGV4QnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJdGVyYXRlZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJdGVyYXRlZSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIiksXG4gICAgYmFzZVNvcnRlZEluZGV4QnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlU29ydGVkSW5kZXhCeSAqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU29ydGVkSW5kZXhCeS5qc1wiKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICogIGludG8gYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gKlxuICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICogLy8gPT4gMVxuICovXG5mdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRlZExhc3RJbmRleEJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWNrYWdlcy9AbG9ncm9ja2V0L3V0aWxzL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vcGFja2FnZXMvQGxvZ3JvY2tldC91dGlscy9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlVG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlVG9TdHJpbmcgKi8gXCIuL3BhY2thZ2VzL0Bsb2dyb2NrZXQvdXRpbHMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzXCIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlMaWtlVG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXJyYXlMaWtlVG9BcnJheS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b1Byb3BlcnR5S2V5LmpzICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9Qcm9wZXJ0eUtleS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBudWxsID09IGFyciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gX2kpIHtcbiAgICB2YXIgX3MsXG4gICAgICBfZSxcbiAgICAgIF94LFxuICAgICAgX3IsXG4gICAgICBfYXJyID0gW10sXG4gICAgICBfbiA9ICEwLFxuICAgICAgX2QgPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XG4gICAgICAgIGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuO1xuICAgICAgICBfbiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSAhMCwgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgbnVsbCAhPSBfaVtcInJldHVyblwiXSAmJiAoX3IgPSBfaVtcInJldHVyblwiXSgpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qc1wiKTtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheVdpdGhIb2xlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXJyYXlXaXRoSG9sZXMuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzXCIpO1xudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanNcIik7XG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciBub25JdGVyYWJsZVJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL25vbkl0ZXJhYmxlUmVzdC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzXCIpO1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlXaXRob3V0SG9sZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FycmF5V2l0aG91dEhvbGVzLmpzICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2l0ZXJhYmxlVG9BcnJheS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzXCIpO1xudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL25vbkl0ZXJhYmxlU3ByZWFkLmpzICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qc1wiKTtcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1ByaW1pdGl2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9QcmltaXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX3R5cGVvZiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVvZi5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXSk7XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9QcmltaXRpdmUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfdHlwZW9mID0gKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZW9mLmpzICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdKTtcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9QcmltaXRpdmUuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXCIpO1xuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSwgX3R5cGVvZihvYmopO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FycmF5TGlrZVRvQXJyYXkuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0XHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcbi8qKioqKiovIFx0XHRcdHRyeSB7XG4vKioqKioqLyBcdFx0XHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuLyoqKioqKi8gXHRcdFx0fSBjYXRjaCAoZSkge1xuLyoqKioqKi8gXHRcdFx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fSkoKTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuLyoqKioqKi8gXHRcdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIG1vZHVsZTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpbiBzdHJpY3QgbW9kZS5cbiFmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiO1xudmFyIGV4cG9ydHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhY2thZ2VzL2xvZ3JvY2tldC9zcmMvbW9kdWxlLW5wbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0ICovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBfc2V0dXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2V0dXAgKi8gXCIuL3BhY2thZ2VzL2xvZ3JvY2tldC9zcmMvc2V0dXAuanNcIikpO1xudmFyIGluc3RhbmNlID0gKDAsIF9zZXR1cC5kZWZhdWx0KSgpO1xudmFyIF9kZWZhdWx0ID0gaW5zdGFuY2U7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xufSgpO1xuX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdO1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/logrocket/dist/build.umd.js\n");

/***/ })

};
;
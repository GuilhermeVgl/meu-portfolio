/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@headlessui";
exports.ids = ["vendor-chunks/@headlessui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@headlessui/react/dist/headlessui.dev.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@headlessui/react/dist/headlessui.dev.cjs ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target, mod));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Combobox: () => Combobox,\n  Dialog: () => Dialog2,\n  Disclosure: () => Disclosure2,\n  FocusTrap: () => FocusTrap,\n  Listbox: () => Listbox2,\n  Menu: () => Menu2,\n  Popover: () => Popover2,\n  Portal: () => Portal2,\n  RadioGroup: () => RadioGroup2,\n  Switch: () => Switch2,\n  Tab: () => Tab2,\n  Transition: () => Transition2\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/components/combobox/combobox.tsx\nvar import_react17 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\n\n// src/hooks/use-computed.ts\nvar import_react3 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n// src/hooks/use-iso-morphic-effect.ts\nvar import_react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n// src/utils/ssr.ts\nvar isServer = typeof window === \"undefined\" || typeof document === \"undefined\";\n\n// src/hooks/use-iso-morphic-effect.ts\nvar useIsoMorphicEffect = isServer ? import_react.useEffect : import_react.useLayoutEffect;\n\n// src/hooks/use-latest-value.ts\nvar import_react2 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useLatestValue(value) {\n  let cache = (0, import_react2.useRef)(value);\n  useIsoMorphicEffect(() => {\n    cache.current = value;\n  }, [value]);\n  return cache;\n}\n\n// src/hooks/use-computed.ts\nfunction useComputed(cb, dependencies) {\n  let [value, setValue] = (0, import_react3.useState)(cb);\n  let cbRef = useLatestValue(cb);\n  useIsoMorphicEffect(() => setValue(cbRef.current), [cbRef, setValue, ...dependencies]);\n  return value;\n}\n\n// src/hooks/use-disposables.ts\nvar import_react4 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n// src/utils/micro-task.ts\nfunction microTask(cb) {\n  if (typeof queueMicrotask === \"function\") {\n    queueMicrotask(cb);\n  } else {\n    Promise.resolve().then(cb).catch((e) => setTimeout(() => {\n      throw e;\n    }));\n  }\n}\n\n// src/utils/disposables.ts\nfunction disposables() {\n  let disposables2 = [];\n  let queue = [];\n  let api = {\n    enqueue(fn) {\n      queue.push(fn);\n    },\n    addEventListener(element, name, listener, options) {\n      element.addEventListener(name, listener, options);\n      return api.add(() => element.removeEventListener(name, listener, options));\n    },\n    requestAnimationFrame(...args) {\n      let raf = requestAnimationFrame(...args);\n      return api.add(() => cancelAnimationFrame(raf));\n    },\n    nextFrame(...args) {\n      return api.requestAnimationFrame(() => {\n        return api.requestAnimationFrame(...args);\n      });\n    },\n    setTimeout(...args) {\n      let timer = setTimeout(...args);\n      return api.add(() => clearTimeout(timer));\n    },\n    microTask(...args) {\n      let task = { current: true };\n      microTask(() => {\n        if (task.current) {\n          args[0]();\n        }\n      });\n      return api.add(() => {\n        task.current = false;\n      });\n    },\n    add(cb) {\n      disposables2.push(cb);\n      return () => {\n        let idx = disposables2.indexOf(cb);\n        if (idx >= 0) {\n          let [dispose] = disposables2.splice(idx, 1);\n          dispose();\n        }\n      };\n    },\n    dispose() {\n      for (let dispose of disposables2.splice(0)) {\n        dispose();\n      }\n    },\n    async workQueue() {\n      for (let handle of queue.splice(0)) {\n        await handle();\n      }\n    }\n  };\n  return api;\n}\n\n// src/hooks/use-disposables.ts\nfunction useDisposables() {\n  let [d] = (0, import_react4.useState)(disposables);\n  (0, import_react4.useEffect)(() => () => d.dispose(), [d]);\n  return d;\n}\n\n// src/hooks/use-event.ts\nvar import_react5 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar useEvent = function useEvent2(cb) {\n  let cache = useLatestValue(cb);\n  return import_react5.default.useCallback((...args) => cache.current(...args), [cache]);\n};\n\n// src/hooks/use-id.ts\nvar import_react7 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\n\n// src/hooks/use-server-handoff-complete.ts\nvar import_react6 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar state = { serverHandoffComplete: false };\nfunction useServerHandoffComplete() {\n  let [serverHandoffComplete, setServerHandoffComplete] = (0, import_react6.useState)(state.serverHandoffComplete);\n  (0, import_react6.useEffect)(() => {\n    if (serverHandoffComplete === true)\n      return;\n    setServerHandoffComplete(true);\n  }, [serverHandoffComplete]);\n  (0, import_react6.useEffect)(() => {\n    if (state.serverHandoffComplete === false)\n      state.serverHandoffComplete = true;\n  }, []);\n  return serverHandoffComplete;\n}\n\n// src/hooks/use-id.ts\nvar id = 0;\nfunction generateId() {\n  return ++id;\n}\nvar _a;\nvar useId = (_a = import_react7.default.useId) != null ? _a : function useId2() {\n  let ready = useServerHandoffComplete();\n  let [id2, setId] = import_react7.default.useState(ready ? generateId : null);\n  useIsoMorphicEffect(() => {\n    if (id2 === null)\n      setId(generateId());\n  }, [id2]);\n  return id2 != null ? \"\" + id2 : void 0;\n};\n\n// src/hooks/use-outside-click.ts\nvar import_react9 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n// src/utils/match.ts\nfunction match(value, lookup, ...args) {\n  if (value in lookup) {\n    let returnValue = lookup[value];\n    return typeof returnValue === \"function\" ? returnValue(...args) : returnValue;\n  }\n  let error = new Error(`Tried to handle \"${value}\" but there is no handler defined. Only defined handlers are: ${Object.keys(lookup).map((key) => `\"${key}\"`).join(\", \")}.`);\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(error, match);\n  throw error;\n}\n\n// src/utils/owner.ts\nfunction getOwnerDocument(element) {\n  if (isServer)\n    return null;\n  if (element instanceof Node)\n    return element.ownerDocument;\n  if (element == null ? void 0 : element.hasOwnProperty(\"current\")) {\n    if (element.current instanceof Node)\n      return element.current.ownerDocument;\n  }\n  return document;\n}\n\n// src/utils/focus-management.ts\nvar focusableSelector = [\n  \"[contentEditable=true]\",\n  \"[tabindex]\",\n  \"a[href]\",\n  \"area[href]\",\n  \"button:not([disabled])\",\n  \"iframe\",\n  \"input:not([disabled])\",\n  \"select:not([disabled])\",\n  \"textarea:not([disabled])\"\n].map( false ? 0 : (selector) => `${selector}:not([tabindex='-1'])`).join(\",\");\nfunction getFocusableElements(container = document.body) {\n  if (container == null)\n    return [];\n  return Array.from(container.querySelectorAll(focusableSelector));\n}\nfunction isFocusableElement(element, mode = 0 /* Strict */) {\n  var _a2;\n  if (element === ((_a2 = getOwnerDocument(element)) == null ? void 0 : _a2.body))\n    return false;\n  return match(mode, {\n    [0 /* Strict */]() {\n      return element.matches(focusableSelector);\n    },\n    [1 /* Loose */]() {\n      let next = element;\n      while (next !== null) {\n        if (next.matches(focusableSelector))\n          return true;\n        next = next.parentElement;\n      }\n      return false;\n    }\n  });\n}\nfunction restoreFocusIfNecessary(element) {\n  let ownerDocument = getOwnerDocument(element);\n  disposables().nextFrame(() => {\n    if (ownerDocument && !isFocusableElement(ownerDocument.activeElement, 0 /* Strict */)) {\n      focusElement(element);\n    }\n  });\n}\nfunction focusElement(element) {\n  element == null ? void 0 : element.focus({ preventScroll: true });\n}\nvar selectableSelector = [\"textarea\", \"input\"].join(\",\");\nfunction isSelectableElement(element) {\n  var _a2, _b;\n  return (_b = (_a2 = element == null ? void 0 : element.matches) == null ? void 0 : _a2.call(element, selectableSelector)) != null ? _b : false;\n}\nfunction sortByDomNode(nodes, resolveKey = (i) => i) {\n  return nodes.slice().sort((aItem, zItem) => {\n    let a = resolveKey(aItem);\n    let z = resolveKey(zItem);\n    if (a === null || z === null)\n      return 0;\n    let position = a.compareDocumentPosition(z);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING)\n      return -1;\n    if (position & Node.DOCUMENT_POSITION_PRECEDING)\n      return 1;\n    return 0;\n  });\n}\nfunction focusFrom(current, focus) {\n  return focusIn(getFocusableElements(), focus, true, current);\n}\nfunction focusIn(container, focus, sorted = true, active = null) {\n  let ownerDocument = Array.isArray(container) ? container.length > 0 ? container[0].ownerDocument : document : container.ownerDocument;\n  let elements = Array.isArray(container) ? sorted ? sortByDomNode(container) : container : getFocusableElements(container);\n  active = active != null ? active : ownerDocument.activeElement;\n  let direction = (() => {\n    if (focus & (1 /* First */ | 4 /* Next */))\n      return 1 /* Next */;\n    if (focus & (2 /* Previous */ | 8 /* Last */))\n      return -1 /* Previous */;\n    throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\");\n  })();\n  let startIndex = (() => {\n    if (focus & 1 /* First */)\n      return 0;\n    if (focus & 2 /* Previous */)\n      return Math.max(0, elements.indexOf(active)) - 1;\n    if (focus & 4 /* Next */)\n      return Math.max(0, elements.indexOf(active)) + 1;\n    if (focus & 8 /* Last */)\n      return elements.length - 1;\n    throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\");\n  })();\n  let focusOptions = focus & 32 /* NoScroll */ ? { preventScroll: true } : {};\n  let offset = 0;\n  let total = elements.length;\n  let next = void 0;\n  do {\n    if (offset >= total || offset + total <= 0)\n      return 0 /* Error */;\n    let nextIdx = startIndex + offset;\n    if (focus & 16 /* WrapAround */) {\n      nextIdx = (nextIdx + total) % total;\n    } else {\n      if (nextIdx < 0)\n        return 3 /* Underflow */;\n      if (nextIdx >= total)\n        return 1 /* Overflow */;\n    }\n    next = elements[nextIdx];\n    next == null ? void 0 : next.focus(focusOptions);\n    offset += direction;\n  } while (next !== ownerDocument.activeElement);\n  if (focus & (4 /* Next */ | 2 /* Previous */) && isSelectableElement(next)) {\n    next.select();\n  }\n  if (!next.hasAttribute(\"tabindex\"))\n    next.setAttribute(\"tabindex\", \"0\");\n  return 2 /* Success */;\n}\n\n// src/hooks/use-document-event.ts\nvar import_react8 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useDocumentEvent(type, listener, options) {\n  let listenerRef = useLatestValue(listener);\n  (0, import_react8.useEffect)(() => {\n    function handler(event) {\n      listenerRef.current(event);\n    }\n    document.addEventListener(type, handler, options);\n    return () => document.removeEventListener(type, handler, options);\n  }, [type, options]);\n}\n\n// src/hooks/use-outside-click.ts\nfunction useOutsideClick(containers, cb, enabled = true) {\n  let enabledRef = (0, import_react9.useRef)(false);\n  (0, import_react9.useEffect)( false ? 0 : () => {\n    requestAnimationFrame(() => {\n      enabledRef.current = enabled;\n    });\n  }, [enabled]);\n  function handleOutsideClick(event, resolveTarget) {\n    if (!enabledRef.current)\n      return;\n    if (event.defaultPrevented)\n      return;\n    let _containers = function resolve(containers2) {\n      if (typeof containers2 === \"function\") {\n        return resolve(containers2());\n      }\n      if (Array.isArray(containers2)) {\n        return containers2;\n      }\n      if (containers2 instanceof Set) {\n        return containers2;\n      }\n      return [containers2];\n    }(containers);\n    let target = resolveTarget(event);\n    if (target === null) {\n      return;\n    }\n    if (!target.ownerDocument.documentElement.contains(target))\n      return;\n    for (let container of _containers) {\n      if (container === null)\n        continue;\n      let domNode = container instanceof HTMLElement ? container : container.current;\n      if (domNode == null ? void 0 : domNode.contains(target)) {\n        return;\n      }\n    }\n    if (!isFocusableElement(target, 1 /* Loose */) && target.tabIndex !== -1) {\n      event.preventDefault();\n    }\n    return cb(event, target);\n  }\n  let initialClickTarget = (0, import_react9.useRef)(null);\n  useDocumentEvent(\"mousedown\", (event) => {\n    if (enabledRef.current) {\n      initialClickTarget.current = event.target;\n    }\n  }, true);\n  useDocumentEvent(\"click\", (event) => {\n    if (!initialClickTarget.current) {\n      return;\n    }\n    handleOutsideClick(event, () => {\n      return initialClickTarget.current;\n    });\n    initialClickTarget.current = null;\n  }, true);\n  useDocumentEvent(\"blur\", (event) => handleOutsideClick(event, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);\n}\n\n// src/hooks/use-resolve-button-type.ts\nvar import_react10 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction resolveType(props) {\n  var _a2;\n  if (props.type)\n    return props.type;\n  let tag = (_a2 = props.as) != null ? _a2 : \"button\";\n  if (typeof tag === \"string\" && tag.toLowerCase() === \"button\")\n    return \"button\";\n  return void 0;\n}\nfunction useResolveButtonType(props, ref) {\n  let [type, setType] = (0, import_react10.useState)(() => resolveType(props));\n  useIsoMorphicEffect(() => {\n    setType(resolveType(props));\n  }, [props.type, props.as]);\n  useIsoMorphicEffect(() => {\n    if (type)\n      return;\n    if (!ref.current)\n      return;\n    if (ref.current instanceof HTMLButtonElement && !ref.current.hasAttribute(\"type\")) {\n      setType(\"button\");\n    }\n  }, [type, ref]);\n  return type;\n}\n\n// src/hooks/use-sync-refs.ts\nvar import_react11 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar Optional = Symbol();\nfunction optionalRef(cb, isOptional = true) {\n  return Object.assign(cb, { [Optional]: isOptional });\n}\nfunction useSyncRefs(...refs) {\n  let cache = (0, import_react11.useRef)(refs);\n  (0, import_react11.useEffect)(() => {\n    cache.current = refs;\n  }, [refs]);\n  let syncRefs = useEvent((value) => {\n    for (let ref of cache.current) {\n      if (ref == null)\n        continue;\n      if (typeof ref === \"function\")\n        ref(value);\n      else\n        ref.current = value;\n    }\n  });\n  return refs.every((ref) => ref == null || (ref == null ? void 0 : ref[Optional])) ? void 0 : syncRefs;\n}\n\n// src/hooks/use-tree-walker.ts\nvar import_react12 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useTreeWalker({\n  container,\n  accept,\n  walk,\n  enabled = true\n}) {\n  let acceptRef = (0, import_react12.useRef)(accept);\n  let walkRef = (0, import_react12.useRef)(walk);\n  (0, import_react12.useEffect)(() => {\n    acceptRef.current = accept;\n    walkRef.current = walk;\n  }, [accept, walk]);\n  useIsoMorphicEffect(() => {\n    if (!container)\n      return;\n    if (!enabled)\n      return;\n    let ownerDocument = getOwnerDocument(container);\n    if (!ownerDocument)\n      return;\n    let accept2 = acceptRef.current;\n    let walk2 = walkRef.current;\n    let acceptNode = Object.assign((node) => accept2(node), { acceptNode: accept2 });\n    let walker = ownerDocument.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, acceptNode, false);\n    while (walker.nextNode())\n      walk2(walker.currentNode);\n  }, [container, enabled, acceptRef, walkRef]);\n}\n\n// src/utils/calculate-active-index.ts\nfunction assertNever(x) {\n  throw new Error(\"Unexpected object: \" + x);\n}\nfunction calculateActiveIndex(action, resolvers) {\n  let items = resolvers.resolveItems();\n  if (items.length <= 0)\n    return null;\n  let currentActiveIndex = resolvers.resolveActiveIndex();\n  let activeIndex = currentActiveIndex != null ? currentActiveIndex : -1;\n  let nextActiveIndex = (() => {\n    switch (action.focus) {\n      case 0 /* First */:\n        return items.findIndex((item) => !resolvers.resolveDisabled(item));\n      case 1 /* Previous */: {\n        let idx = items.slice().reverse().findIndex((item, idx2, all) => {\n          if (activeIndex !== -1 && all.length - idx2 - 1 >= activeIndex)\n            return false;\n          return !resolvers.resolveDisabled(item);\n        });\n        if (idx === -1)\n          return idx;\n        return items.length - 1 - idx;\n      }\n      case 2 /* Next */:\n        return items.findIndex((item, idx) => {\n          if (idx <= activeIndex)\n            return false;\n          return !resolvers.resolveDisabled(item);\n        });\n      case 3 /* Last */: {\n        let idx = items.slice().reverse().findIndex((item) => !resolvers.resolveDisabled(item));\n        if (idx === -1)\n          return idx;\n        return items.length - 1 - idx;\n      }\n      case 4 /* Specific */:\n        return items.findIndex((item) => resolvers.resolveId(item) === action.id);\n      case 5 /* Nothing */:\n        return null;\n      default:\n        assertNever(action);\n    }\n  })();\n  return nextActiveIndex === -1 ? currentActiveIndex : nextActiveIndex;\n}\n\n// src/utils/render.ts\nvar import_react13 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction render({\n  ourProps,\n  theirProps,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name\n}) {\n  let props = mergeProps(theirProps, ourProps);\n  if (visible)\n    return _render(props, slot, defaultTag, name);\n  let featureFlags = features != null ? features : 0 /* None */;\n  if (featureFlags & 2 /* Static */) {\n    let { static: isStatic = false, ...rest } = props;\n    if (isStatic)\n      return _render(rest, slot, defaultTag, name);\n  }\n  if (featureFlags & 1 /* RenderStrategy */) {\n    let { unmount = true, ...rest } = props;\n    let strategy = unmount ? 0 /* Unmount */ : 1 /* Hidden */;\n    return match(strategy, {\n      [0 /* Unmount */]() {\n        return null;\n      },\n      [1 /* Hidden */]() {\n        return _render({ ...rest, ...{ hidden: true, style: { display: \"none\" } } }, slot, defaultTag, name);\n      }\n    });\n  }\n  return _render(props, slot, defaultTag, name);\n}\nfunction _render(props, slot = {}, tag, name) {\n  let {\n    as: Component = tag,\n    children,\n    refName = \"ref\",\n    ...rest\n  } = omit(props, [\"unmount\", \"static\"]);\n  let refRelatedProps = props.ref !== void 0 ? { [refName]: props.ref } : {};\n  let resolvedChildren = typeof children === \"function\" ? children(slot) : children;\n  if (rest.className && typeof rest.className === \"function\") {\n    ;\n    rest.className = rest.className(slot);\n  }\n  let dataAttributes = {};\n  if (slot) {\n    let exposeState = false;\n    let states = [];\n    for (let [k, v] of Object.entries(slot)) {\n      if (typeof v === \"boolean\") {\n        exposeState = true;\n      }\n      if (v === true) {\n        states.push(k);\n      }\n    }\n    if (exposeState)\n      dataAttributes[`data-headlessui-state`] = states.join(\" \");\n  }\n  if (Component === import_react13.Fragment) {\n    if (Object.keys(compact(rest)).length > 0) {\n      if (!(0, import_react13.isValidElement)(resolvedChildren) || Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {\n        throw new Error([\n          'Passing props on \"Fragment\"!',\n          \"\",\n          `The current component <${name} /> is rendering a \"Fragment\".`,\n          `However we need to passthrough the following props:`,\n          Object.keys(rest).map((line) => `  - ${line}`).join(\"\\n\"),\n          \"\",\n          \"You can apply a few solutions:\",\n          [\n            'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n            \"Render a single element as the child so that we can forward the props onto that element.\"\n          ].map((line) => `  - ${line}`).join(\"\\n\")\n        ].join(\"\\n\"));\n      }\n      return (0, import_react13.cloneElement)(resolvedChildren, Object.assign({}, mergeProps(resolvedChildren.props, compact(omit(rest, [\"ref\"]))), dataAttributes, refRelatedProps, mergeRefs(resolvedChildren.ref, refRelatedProps.ref)));\n    }\n  }\n  return (0, import_react13.createElement)(Component, Object.assign({}, omit(rest, [\"ref\"]), Component !== import_react13.Fragment && refRelatedProps, Component !== import_react13.Fragment && dataAttributes), resolvedChildren);\n}\nfunction mergeRefs(...refs) {\n  return {\n    ref: refs.every((ref) => ref == null) ? void 0 : (value) => {\n      for (let ref of refs) {\n        if (ref == null)\n          continue;\n        if (typeof ref === \"function\")\n          ref(value);\n        else\n          ref.current = value;\n      }\n    }\n  };\n}\nfunction mergeProps(...listOfProps) {\n  var _a2;\n  if (listOfProps.length === 0)\n    return {};\n  if (listOfProps.length === 1)\n    return listOfProps[0];\n  let target = {};\n  let eventHandlers = {};\n  for (let props of listOfProps) {\n    for (let prop in props) {\n      if (prop.startsWith(\"on\") && typeof props[prop] === \"function\") {\n        (_a2 = eventHandlers[prop]) != null ? _a2 : eventHandlers[prop] = [];\n        eventHandlers[prop].push(props[prop]);\n      } else {\n        target[prop] = props[prop];\n      }\n    }\n  }\n  if (target.disabled || target[\"aria-disabled\"]) {\n    return Object.assign(target, Object.fromEntries(Object.keys(eventHandlers).map((eventName) => [eventName, void 0])));\n  }\n  for (let eventName in eventHandlers) {\n    Object.assign(target, {\n      [eventName](event, ...args) {\n        let handlers = eventHandlers[eventName];\n        for (let handler of handlers) {\n          if ((event instanceof Event || (event == null ? void 0 : event.nativeEvent) instanceof Event) && event.defaultPrevented) {\n            return;\n          }\n          handler(event, ...args);\n        }\n      }\n    });\n  }\n  return target;\n}\nfunction forwardRefWithAs(component) {\n  var _a2;\n  return Object.assign((0, import_react13.forwardRef)(component), {\n    displayName: (_a2 = component.displayName) != null ? _a2 : component.name\n  });\n}\nfunction compact(object) {\n  let clone = Object.assign({}, object);\n  for (let key in clone) {\n    if (clone[key] === void 0)\n      delete clone[key];\n  }\n  return clone;\n}\nfunction omit(object, keysToOmit = []) {\n  let clone = Object.assign({}, object);\n  for (let key of keysToOmit) {\n    if (key in clone)\n      delete clone[key];\n  }\n  return clone;\n}\n\n// src/utils/bugs.ts\nfunction isDisabledReactIssue7711(element) {\n  let parent = element.parentElement;\n  let legend = null;\n  while (parent && !(parent instanceof HTMLFieldSetElement)) {\n    if (parent instanceof HTMLLegendElement)\n      legend = parent;\n    parent = parent.parentElement;\n  }\n  let isParentDisabled = (parent == null ? void 0 : parent.getAttribute(\"disabled\")) === \"\";\n  if (isParentDisabled && isFirstLegend(legend))\n    return false;\n  return isParentDisabled;\n}\nfunction isFirstLegend(element) {\n  if (!element)\n    return false;\n  let previous = element.previousElementSibling;\n  while (previous !== null) {\n    if (previous instanceof HTMLLegendElement)\n      return false;\n    previous = previous.previousElementSibling;\n  }\n  return true;\n}\n\n// src/utils/form.ts\nfunction objectToFormEntries(source = {}, parentKey = null, entries = []) {\n  for (let [key, value] of Object.entries(source)) {\n    append(entries, composeKey(parentKey, key), value);\n  }\n  return entries;\n}\nfunction composeKey(parent, key) {\n  return parent ? parent + \"[\" + key + \"]\" : key;\n}\nfunction append(entries, key, value) {\n  if (Array.isArray(value)) {\n    for (let [subkey, subvalue] of value.entries()) {\n      append(entries, composeKey(key, subkey.toString()), subvalue);\n    }\n  } else if (value instanceof Date) {\n    entries.push([key, value.toISOString()]);\n  } else if (typeof value === \"boolean\") {\n    entries.push([key, value ? \"1\" : \"0\"]);\n  } else if (typeof value === \"string\") {\n    entries.push([key, value]);\n  } else if (typeof value === \"number\") {\n    entries.push([key, `${value}`]);\n  } else if (value === null || value === void 0) {\n    entries.push([key, \"\"]);\n  } else {\n    objectToFormEntries(value, key, entries);\n  }\n}\nfunction attemptSubmit(element) {\n  var _a2;\n  let form = (_a2 = element == null ? void 0 : element.form) != null ? _a2 : element.closest(\"form\");\n  if (!form)\n    return;\n  for (let element2 of form.elements) {\n    if (element2.tagName === \"INPUT\" && element2.type === \"submit\" || element2.tagName === \"BUTTON\" && element2.type === \"submit\" || element2.nodeName === \"INPUT\" && element2.type === \"image\") {\n      element2.click();\n      return;\n    }\n  }\n}\n\n// src/internal/hidden.tsx\nvar DEFAULT_VISUALLY_HIDDEN_TAG = \"div\";\nvar Hidden = forwardRefWithAs(function VisuallyHidden(props, ref) {\n  let { features = 1 /* None */, ...theirProps } = props;\n  let ourProps = {\n    ref,\n    \"aria-hidden\": (features & 2 /* Focusable */) === 2 /* Focusable */ ? true : void 0,\n    style: {\n      position: \"fixed\",\n      top: 1,\n      left: 1,\n      width: 1,\n      height: 0,\n      padding: 0,\n      margin: -1,\n      overflow: \"hidden\",\n      clip: \"rect(0, 0, 0, 0)\",\n      whiteSpace: \"nowrap\",\n      borderWidth: \"0\",\n      ...(features & 4 /* Hidden */) === 4 /* Hidden */ && !((features & 2 /* Focusable */) === 2 /* Focusable */) && { display: \"none\" }\n    }\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_VISUALLY_HIDDEN_TAG,\n    name: \"Hidden\"\n  });\n});\n\n// src/internal/open-closed.tsx\nvar import_react14 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar Context = (0, import_react14.createContext)(null);\nContext.displayName = \"OpenClosedContext\";\nfunction useOpenClosed() {\n  return (0, import_react14.useContext)(Context);\n}\nfunction OpenClosedProvider({ value, children }) {\n  return /* @__PURE__ */ import_react14.default.createElement(Context.Provider, {\n    value\n  }, children);\n}\n\n// src/hooks/use-controllable.ts\nvar import_react15 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useControllable(controlledValue, onChange, defaultValue) {\n  let [internalValue, setInternalValue] = (0, import_react15.useState)(defaultValue);\n  let isControlled = controlledValue !== void 0;\n  return [\n    isControlled ? controlledValue : internalValue,\n    useEvent((value) => {\n      if (isControlled) {\n        return onChange == null ? void 0 : onChange(value);\n      } else {\n        setInternalValue(value);\n        return onChange == null ? void 0 : onChange(value);\n      }\n    })\n  ];\n}\n\n// src/hooks/use-watch.ts\nvar import_react16 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useWatch(cb, dependencies) {\n  let track = (0, import_react16.useRef)([]);\n  let action = useEvent(cb);\n  (0, import_react16.useEffect)(() => {\n    let oldValues = [...track.current];\n    for (let [idx, value] of dependencies.entries()) {\n      if (track.current[idx] !== value) {\n        let returnValue = action(dependencies, oldValues);\n        track.current = dependencies;\n        return returnValue;\n      }\n    }\n  }, [action, ...dependencies]);\n}\n\n// src/components/combobox/combobox.tsx\nfunction adjustOrderedState(state2, adjustment = (i) => i) {\n  let currentActiveOption = state2.activeOptionIndex !== null ? state2.options[state2.activeOptionIndex] : null;\n  let sortedOptions = sortByDomNode(adjustment(state2.options.slice()), (option) => option.dataRef.current.domRef.current);\n  let adjustedActiveOptionIndex = currentActiveOption ? sortedOptions.indexOf(currentActiveOption) : null;\n  if (adjustedActiveOptionIndex === -1) {\n    adjustedActiveOptionIndex = null;\n  }\n  return {\n    options: sortedOptions,\n    activeOptionIndex: adjustedActiveOptionIndex\n  };\n}\nvar reducers = {\n  [1 /* CloseCombobox */](state2) {\n    if (state2.dataRef.current.disabled)\n      return state2;\n    if (state2.comboboxState === 1 /* Closed */)\n      return state2;\n    return { ...state2, activeOptionIndex: null, comboboxState: 1 /* Closed */ };\n  },\n  [0 /* OpenCombobox */](state2) {\n    if (state2.dataRef.current.disabled)\n      return state2;\n    if (state2.comboboxState === 0 /* Open */)\n      return state2;\n    let activeOptionIndex = state2.activeOptionIndex;\n    let { isSelected } = state2.dataRef.current;\n    let optionIdx = state2.options.findIndex((option) => isSelected(option.dataRef.current.value));\n    if (optionIdx !== -1) {\n      activeOptionIndex = optionIdx;\n    }\n    return { ...state2, comboboxState: 0 /* Open */, activeOptionIndex };\n  },\n  [2 /* GoToOption */](state2, action) {\n    var _a2;\n    if (state2.dataRef.current.disabled)\n      return state2;\n    if (state2.dataRef.current.optionsRef.current && !state2.dataRef.current.optionsPropsRef.current.static && state2.comboboxState === 1 /* Closed */) {\n      return state2;\n    }\n    let adjustedState = adjustOrderedState(state2);\n    if (adjustedState.activeOptionIndex === null) {\n      let localActiveOptionIndex = adjustedState.options.findIndex((option) => !option.dataRef.current.disabled);\n      if (localActiveOptionIndex !== -1) {\n        adjustedState.activeOptionIndex = localActiveOptionIndex;\n      }\n    }\n    let activeOptionIndex = calculateActiveIndex(action, {\n      resolveItems: () => adjustedState.options,\n      resolveActiveIndex: () => adjustedState.activeOptionIndex,\n      resolveId: (item) => item.id,\n      resolveDisabled: (item) => item.dataRef.current.disabled\n    });\n    return {\n      ...state2,\n      ...adjustedState,\n      activeOptionIndex,\n      activationTrigger: (_a2 = action.trigger) != null ? _a2 : 1 /* Other */\n    };\n  },\n  [3 /* RegisterOption */]: (state2, action) => {\n    let option = { id: action.id, dataRef: action.dataRef };\n    let adjustedState = adjustOrderedState(state2, (options) => [...options, option]);\n    if (state2.activeOptionIndex === null) {\n      if (state2.dataRef.current.isSelected(action.dataRef.current.value)) {\n        adjustedState.activeOptionIndex = adjustedState.options.indexOf(option);\n      }\n    }\n    let nextState = {\n      ...state2,\n      ...adjustedState,\n      activationTrigger: 1 /* Other */\n    };\n    if (state2.dataRef.current.__demoMode && state2.dataRef.current.value === void 0) {\n      nextState.activeOptionIndex = 0;\n    }\n    return nextState;\n  },\n  [4 /* UnregisterOption */]: (state2, action) => {\n    let adjustedState = adjustOrderedState(state2, (options) => {\n      let idx = options.findIndex((a) => a.id === action.id);\n      if (idx !== -1)\n        options.splice(idx, 1);\n      return options;\n    });\n    return {\n      ...state2,\n      ...adjustedState,\n      activationTrigger: 1 /* Other */\n    };\n  },\n  [5 /* RegisterLabel */]: (state2, action) => {\n    return {\n      ...state2,\n      labelId: action.id\n    };\n  }\n};\nvar ComboboxActionsContext = (0, import_react17.createContext)(null);\nComboboxActionsContext.displayName = \"ComboboxActionsContext\";\nfunction useActions(component) {\n  let context = (0, import_react17.useContext)(ComboboxActionsContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Combobox /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useActions);\n    throw err;\n  }\n  return context;\n}\nvar ComboboxDataContext = (0, import_react17.createContext)(null);\nComboboxDataContext.displayName = \"ComboboxDataContext\";\nfunction useData(component) {\n  let context = (0, import_react17.useContext)(ComboboxDataContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Combobox /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useData);\n    throw err;\n  }\n  return context;\n}\nfunction stateReducer(state2, action) {\n  return match(action.type, reducers, state2, action);\n}\nvar DEFAULT_COMBOBOX_TAG = import_react17.Fragment;\nfunction ComboboxFn(props, ref) {\n  let {\n    value: controlledValue,\n    defaultValue,\n    onChange: controlledOnChange,\n    name,\n    by = (a, z) => a === z,\n    disabled = false,\n    __demoMode = false,\n    nullable = false,\n    multiple = false,\n    ...theirProps\n  } = props;\n  let [value, theirOnChange] = useControllable(controlledValue, controlledOnChange, defaultValue);\n  let [state2, dispatch] = (0, import_react17.useReducer)(stateReducer, {\n    dataRef: (0, import_react17.createRef)(),\n    comboboxState: __demoMode ? 0 /* Open */ : 1 /* Closed */,\n    options: [],\n    activeOptionIndex: null,\n    activationTrigger: 1 /* Other */,\n    labelId: null\n  });\n  let defaultToFirstOption = (0, import_react17.useRef)(false);\n  let optionsPropsRef = (0, import_react17.useRef)({ static: false, hold: false });\n  let labelRef = (0, import_react17.useRef)(null);\n  let inputRef = (0, import_react17.useRef)(null);\n  let buttonRef = (0, import_react17.useRef)(null);\n  let optionsRef = (0, import_react17.useRef)(null);\n  let compare = useEvent(typeof by === \"string\" ? (a, z) => {\n    let property = by;\n    return (a == null ? void 0 : a[property]) === (z == null ? void 0 : z[property]);\n  } : by);\n  let isSelected = (0, import_react17.useCallback)((compareValue) => match(data.mode, {\n    [1 /* Multi */]: () => value.some((option) => compare(option, compareValue)),\n    [0 /* Single */]: () => compare(value, compareValue)\n  }), [value]);\n  let data = (0, import_react17.useMemo)(() => ({\n    ...state2,\n    optionsPropsRef,\n    labelRef,\n    inputRef,\n    buttonRef,\n    optionsRef,\n    value,\n    disabled,\n    mode: multiple ? 1 /* Multi */ : 0 /* Single */,\n    get activeOptionIndex() {\n      if (defaultToFirstOption.current && state2.activeOptionIndex === null && state2.options.length > 0) {\n        let localActiveOptionIndex = state2.options.findIndex((option) => !option.dataRef.current.disabled);\n        if (localActiveOptionIndex !== -1) {\n          return localActiveOptionIndex;\n        }\n      }\n      return state2.activeOptionIndex;\n    },\n    compare,\n    isSelected,\n    nullable,\n    __demoMode\n  }), [value, disabled, multiple, nullable, __demoMode, state2]);\n  useIsoMorphicEffect(() => {\n    state2.dataRef.current = data;\n  }, [data]);\n  useOutsideClick([data.buttonRef, data.inputRef, data.optionsRef], () => dispatch({ type: 1 /* CloseCombobox */ }), data.comboboxState === 0 /* Open */);\n  let slot = (0, import_react17.useMemo)(() => ({\n    open: data.comboboxState === 0 /* Open */,\n    disabled,\n    activeIndex: data.activeOptionIndex,\n    activeOption: data.activeOptionIndex === null ? null : data.options[data.activeOptionIndex].dataRef.current.value,\n    value\n  }), [data, disabled, value]);\n  let selectOption = useEvent((id2) => {\n    let option = data.options.find((item) => item.id === id2);\n    if (!option)\n      return;\n    onChange(option.dataRef.current.value);\n  });\n  let selectActiveOption = useEvent(() => {\n    if (data.activeOptionIndex !== null) {\n      let { dataRef, id: id2 } = data.options[data.activeOptionIndex];\n      onChange(dataRef.current.value);\n      dispatch({ type: 2 /* GoToOption */, focus: 4 /* Specific */, id: id2 });\n    }\n  });\n  let openCombobox = useEvent(() => {\n    dispatch({ type: 0 /* OpenCombobox */ });\n    defaultToFirstOption.current = true;\n  });\n  let closeCombobox = useEvent(() => {\n    dispatch({ type: 1 /* CloseCombobox */ });\n    defaultToFirstOption.current = false;\n  });\n  let goToOption = useEvent((focus, id2, trigger) => {\n    defaultToFirstOption.current = false;\n    if (focus === 4 /* Specific */) {\n      return dispatch({ type: 2 /* GoToOption */, focus: 4 /* Specific */, id: id2, trigger });\n    }\n    return dispatch({ type: 2 /* GoToOption */, focus, trigger });\n  });\n  let registerOption = useEvent((id2, dataRef) => {\n    dispatch({ type: 3 /* RegisterOption */, id: id2, dataRef });\n    return () => dispatch({ type: 4 /* UnregisterOption */, id: id2 });\n  });\n  let registerLabel = useEvent((id2) => {\n    dispatch({ type: 5 /* RegisterLabel */, id: id2 });\n    return () => dispatch({ type: 5 /* RegisterLabel */, id: null });\n  });\n  let onChange = useEvent((value2) => {\n    return match(data.mode, {\n      [0 /* Single */]() {\n        return theirOnChange == null ? void 0 : theirOnChange(value2);\n      },\n      [1 /* Multi */]() {\n        let copy = data.value.slice();\n        let idx = copy.findIndex((item) => compare(item, value2));\n        if (idx === -1) {\n          copy.push(value2);\n        } else {\n          copy.splice(idx, 1);\n        }\n        return theirOnChange == null ? void 0 : theirOnChange(copy);\n      }\n    });\n  });\n  let actions = (0, import_react17.useMemo)(() => ({\n    onChange,\n    registerOption,\n    registerLabel,\n    goToOption,\n    closeCombobox,\n    openCombobox,\n    selectActiveOption,\n    selectOption\n  }), []);\n  let ourProps = ref === null ? {} : { ref };\n  return /* @__PURE__ */ import_react17.default.createElement(ComboboxActionsContext.Provider, {\n    value: actions\n  }, /* @__PURE__ */ import_react17.default.createElement(ComboboxDataContext.Provider, {\n    value: data\n  }, /* @__PURE__ */ import_react17.default.createElement(OpenClosedProvider, {\n    value: match(data.comboboxState, {\n      [0 /* Open */]: 0 /* Open */,\n      [1 /* Closed */]: 1 /* Closed */\n    })\n  }, name != null && value != null && objectToFormEntries({ [name]: value }).map(([name2, value2]) => /* @__PURE__ */ import_react17.default.createElement(Hidden, {\n    features: 4 /* Hidden */,\n    ...compact({\n      key: name2,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: true,\n      readOnly: true,\n      name: name2,\n      value: value2\n    })\n  })), render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_COMBOBOX_TAG,\n    name: \"Combobox\"\n  }))));\n}\nvar ComboboxRoot = forwardRefWithAs(ComboboxFn);\nvar DEFAULT_INPUT_TAG = \"input\";\nvar Input = forwardRefWithAs(function Input2(props, ref) {\n  var _a2, _b;\n  let { value, onChange, displayValue, type = \"text\", ...theirProps } = props;\n  let data = useData(\"Combobox.Input\");\n  let actions = useActions(\"Combobox.Input\");\n  let inputRef = useSyncRefs(data.inputRef, ref);\n  let id2 = `headlessui-combobox-input-${useId()}`;\n  let d = useDisposables();\n  let currentValue = (0, import_react17.useMemo)(() => {\n    var _a3;\n    if (typeof displayValue === \"function\") {\n      return (_a3 = displayValue(data.value)) != null ? _a3 : \"\";\n    } else if (typeof data.value === \"string\") {\n      return data.value;\n    } else {\n      return \"\";\n    }\n  }, [data.value]);\n  useWatch(([currentValue2, state2], [oldCurrentValue, oldState]) => {\n    if (!data.inputRef.current)\n      return;\n    if (oldState === 0 /* Open */ && state2 === 1 /* Closed */) {\n      data.inputRef.current.value = currentValue2;\n    } else if (currentValue2 !== oldCurrentValue) {\n      data.inputRef.current.value = currentValue2;\n    }\n  }, [currentValue, data.comboboxState]);\n  let handleKeyDown = useEvent((event) => {\n    switch (event.key) {\n      case \"Backspace\" /* Backspace */:\n      case \"Delete\" /* Delete */:\n        if (data.mode !== 0 /* Single */)\n          return;\n        if (!data.nullable)\n          return;\n        let input = event.currentTarget;\n        d.requestAnimationFrame(() => {\n          if (input.value === \"\") {\n            actions.onChange(null);\n            if (data.optionsRef.current) {\n              data.optionsRef.current.scrollTop = 0;\n            }\n            actions.goToOption(5 /* Nothing */);\n          }\n        });\n        break;\n      case \"Enter\" /* Enter */:\n        if (data.comboboxState !== 0 /* Open */)\n          return;\n        if (event.nativeEvent.isComposing)\n          return;\n        event.preventDefault();\n        event.stopPropagation();\n        if (data.activeOptionIndex === null) {\n          actions.closeCombobox();\n          return;\n        }\n        actions.selectActiveOption();\n        if (data.mode === 0 /* Single */) {\n          actions.closeCombobox();\n        }\n        break;\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return match(data.comboboxState, {\n          [0 /* Open */]: () => {\n            actions.goToOption(2 /* Next */);\n          },\n          [1 /* Closed */]: () => {\n            actions.openCombobox();\n          }\n        });\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return match(data.comboboxState, {\n          [0 /* Open */]: () => {\n            actions.goToOption(1 /* Previous */);\n          },\n          [1 /* Closed */]: () => {\n            actions.openCombobox();\n            d.nextFrame(() => {\n              if (!data.value) {\n                actions.goToOption(3 /* Last */);\n              }\n            });\n          }\n        });\n      case \"Home\" /* Home */:\n      case \"PageUp\" /* PageUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return actions.goToOption(0 /* First */);\n      case \"End\" /* End */:\n      case \"PageDown\" /* PageDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return actions.goToOption(3 /* Last */);\n      case \"Escape\" /* Escape */:\n        if (data.comboboxState !== 0 /* Open */)\n          return;\n        event.preventDefault();\n        if (data.optionsRef.current && !data.optionsPropsRef.current.static) {\n          event.stopPropagation();\n        }\n        return actions.closeCombobox();\n      case \"Tab\" /* Tab */:\n        if (data.comboboxState !== 0 /* Open */)\n          return;\n        if (data.mode === 0 /* Single */)\n          actions.selectActiveOption();\n        actions.closeCombobox();\n        break;\n    }\n  });\n  let handleChange = useEvent((event) => {\n    actions.openCombobox();\n    onChange == null ? void 0 : onChange(event);\n  });\n  let labelledby = useComputed(() => {\n    if (!data.labelId)\n      return void 0;\n    return [data.labelId].join(\" \");\n  }, [data.labelId]);\n  let slot = (0, import_react17.useMemo)(() => ({ open: data.comboboxState === 0 /* Open */, disabled: data.disabled }), [data]);\n  let ourProps = {\n    ref: inputRef,\n    id: id2,\n    role: \"combobox\",\n    type,\n    \"aria-controls\": (_a2 = data.optionsRef.current) == null ? void 0 : _a2.id,\n    \"aria-expanded\": data.disabled ? void 0 : data.comboboxState === 0 /* Open */,\n    \"aria-activedescendant\": data.activeOptionIndex === null ? void 0 : (_b = data.options[data.activeOptionIndex]) == null ? void 0 : _b.id,\n    \"aria-multiselectable\": data.mode === 1 /* Multi */ ? true : void 0,\n    \"aria-labelledby\": labelledby,\n    disabled: data.disabled,\n    onKeyDown: handleKeyDown,\n    onChange: handleChange\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_INPUT_TAG,\n    name: \"Combobox.Input\"\n  });\n});\nvar DEFAULT_BUTTON_TAG = \"button\";\nvar Button = forwardRefWithAs(function Button2(props, ref) {\n  var _a2;\n  let data = useData(\"Combobox.Button\");\n  let actions = useActions(\"Combobox.Button\");\n  let buttonRef = useSyncRefs(data.buttonRef, ref);\n  let id2 = `headlessui-combobox-button-${useId()}`;\n  let d = useDisposables();\n  let handleKeyDown = useEvent((event) => {\n    switch (event.key) {\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        if (data.comboboxState === 1 /* Closed */) {\n          actions.openCombobox();\n        }\n        return d.nextFrame(() => {\n          var _a3;\n          return (_a3 = data.inputRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n        });\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        if (data.comboboxState === 1 /* Closed */) {\n          actions.openCombobox();\n          d.nextFrame(() => {\n            if (!data.value) {\n              actions.goToOption(3 /* Last */);\n            }\n          });\n        }\n        return d.nextFrame(() => {\n          var _a3;\n          return (_a3 = data.inputRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n        });\n      case \"Escape\" /* Escape */:\n        if (data.comboboxState !== 0 /* Open */)\n          return;\n        event.preventDefault();\n        if (data.optionsRef.current && !data.optionsPropsRef.current.static) {\n          event.stopPropagation();\n        }\n        actions.closeCombobox();\n        return d.nextFrame(() => {\n          var _a3;\n          return (_a3 = data.inputRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n        });\n      default:\n        return;\n    }\n  });\n  let handleClick = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    if (data.comboboxState === 0 /* Open */) {\n      actions.closeCombobox();\n    } else {\n      event.preventDefault();\n      actions.openCombobox();\n    }\n    d.nextFrame(() => {\n      var _a3;\n      return (_a3 = data.inputRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n    });\n  });\n  let labelledby = useComputed(() => {\n    if (!data.labelId)\n      return void 0;\n    return [data.labelId, id2].join(\" \");\n  }, [data.labelId, id2]);\n  let slot = (0, import_react17.useMemo)(() => ({\n    open: data.comboboxState === 0 /* Open */,\n    disabled: data.disabled,\n    value: data.value\n  }), [data]);\n  let theirProps = props;\n  let ourProps = {\n    ref: buttonRef,\n    id: id2,\n    type: useResolveButtonType(props, data.buttonRef),\n    tabIndex: -1,\n    \"aria-haspopup\": true,\n    \"aria-controls\": (_a2 = data.optionsRef.current) == null ? void 0 : _a2.id,\n    \"aria-expanded\": data.disabled ? void 0 : data.comboboxState === 0 /* Open */,\n    \"aria-labelledby\": labelledby,\n    disabled: data.disabled,\n    onClick: handleClick,\n    onKeyDown: handleKeyDown\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: \"Combobox.Button\"\n  });\n});\nvar DEFAULT_LABEL_TAG = \"label\";\nvar Label = forwardRefWithAs(function Label2(props, ref) {\n  let data = useData(\"Combobox.Label\");\n  let id2 = `headlessui-combobox-label-${useId()}`;\n  let actions = useActions(\"Combobox.Label\");\n  let labelRef = useSyncRefs(data.labelRef, ref);\n  useIsoMorphicEffect(() => actions.registerLabel(id2), [id2]);\n  let handleClick = useEvent(() => {\n    var _a2;\n    return (_a2 = data.inputRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });\n  });\n  let slot = (0, import_react17.useMemo)(() => ({ open: data.comboboxState === 0 /* Open */, disabled: data.disabled }), [data]);\n  let theirProps = props;\n  let ourProps = { ref: labelRef, id: id2, onClick: handleClick };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_LABEL_TAG,\n    name: \"Combobox.Label\"\n  });\n});\nvar DEFAULT_OPTIONS_TAG = \"ul\";\nvar OptionsRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nvar Options = forwardRefWithAs(function Options2(props, ref) {\n  var _a2;\n  let { hold = false, ...theirProps } = props;\n  let data = useData(\"Combobox.Options\");\n  let optionsRef = useSyncRefs(data.optionsRef, ref);\n  let id2 = `headlessui-combobox-options-${useId()}`;\n  let usesOpenClosedState = useOpenClosed();\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === 0 /* Open */;\n    }\n    return data.comboboxState === 0 /* Open */;\n  })();\n  useIsoMorphicEffect(() => {\n    var _a3;\n    data.optionsPropsRef.current.static = (_a3 = props.static) != null ? _a3 : false;\n  }, [data.optionsPropsRef, props.static]);\n  useIsoMorphicEffect(() => {\n    data.optionsPropsRef.current.hold = hold;\n  }, [data.optionsPropsRef, hold]);\n  useTreeWalker({\n    container: data.optionsRef.current,\n    enabled: data.comboboxState === 0 /* Open */,\n    accept(node) {\n      if (node.getAttribute(\"role\") === \"option\")\n        return NodeFilter.FILTER_REJECT;\n      if (node.hasAttribute(\"role\"))\n        return NodeFilter.FILTER_SKIP;\n      return NodeFilter.FILTER_ACCEPT;\n    },\n    walk(node) {\n      node.setAttribute(\"role\", \"none\");\n    }\n  });\n  let labelledby = useComputed(() => {\n    var _a3, _b;\n    return (_b = data.labelId) != null ? _b : (_a3 = data.buttonRef.current) == null ? void 0 : _a3.id;\n  }, [data.labelId, data.buttonRef.current]);\n  let slot = (0, import_react17.useMemo)(() => ({ open: data.comboboxState === 0 /* Open */ }), [data]);\n  let ourProps = {\n    \"aria-activedescendant\": data.activeOptionIndex === null ? void 0 : (_a2 = data.options[data.activeOptionIndex]) == null ? void 0 : _a2.id,\n    \"aria-labelledby\": labelledby,\n    role: \"listbox\",\n    id: id2,\n    ref: optionsRef\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTIONS_TAG,\n    features: OptionsRenderFeatures,\n    visible,\n    name: \"Combobox.Options\"\n  });\n});\nvar DEFAULT_OPTION_TAG = \"li\";\nvar Option = forwardRefWithAs(function Option2(props, ref) {\n  var _a2, _b;\n  let { disabled = false, value, ...theirProps } = props;\n  let data = useData(\"Combobox.Option\");\n  let actions = useActions(\"Combobox.Option\");\n  let id2 = `headlessui-combobox-option-${useId()}`;\n  let active = data.activeOptionIndex !== null ? data.options[data.activeOptionIndex].id === id2 : false;\n  let selected = data.isSelected(value);\n  let internalOptionRef = (0, import_react17.useRef)(null);\n  let bag = useLatestValue({\n    disabled,\n    value,\n    domRef: internalOptionRef,\n    textValue: (_b = (_a2 = internalOptionRef.current) == null ? void 0 : _a2.textContent) == null ? void 0 : _b.toLowerCase()\n  });\n  let optionRef = useSyncRefs(ref, internalOptionRef);\n  let select = useEvent(() => actions.selectOption(id2));\n  useIsoMorphicEffect(() => actions.registerOption(id2, bag), [bag, id2]);\n  let enableScrollIntoView = (0, import_react17.useRef)(data.__demoMode ? false : true);\n  useIsoMorphicEffect(() => {\n    if (!data.__demoMode)\n      return;\n    let d = disposables();\n    d.requestAnimationFrame(() => {\n      enableScrollIntoView.current = true;\n    });\n    return d.dispose;\n  }, []);\n  useIsoMorphicEffect(() => {\n    if (data.comboboxState !== 0 /* Open */)\n      return;\n    if (!active)\n      return;\n    if (!enableScrollIntoView.current)\n      return;\n    if (data.activationTrigger === 0 /* Pointer */)\n      return;\n    let d = disposables();\n    d.requestAnimationFrame(() => {\n      var _a3, _b2;\n      (_b2 = (_a3 = internalOptionRef.current) == null ? void 0 : _a3.scrollIntoView) == null ? void 0 : _b2.call(_a3, { block: \"nearest\" });\n    });\n    return d.dispose;\n  }, [internalOptionRef, active, data.comboboxState, data.activationTrigger, data.activeOptionIndex]);\n  let handleClick = useEvent((event) => {\n    if (disabled)\n      return event.preventDefault();\n    select();\n    if (data.mode === 0 /* Single */) {\n      actions.closeCombobox();\n    }\n  });\n  let handleFocus = useEvent(() => {\n    if (disabled)\n      return actions.goToOption(5 /* Nothing */);\n    actions.goToOption(4 /* Specific */, id2);\n  });\n  let handleMove = useEvent(() => {\n    if (disabled)\n      return;\n    if (active)\n      return;\n    actions.goToOption(4 /* Specific */, id2, 0 /* Pointer */);\n  });\n  let handleLeave = useEvent(() => {\n    if (disabled)\n      return;\n    if (!active)\n      return;\n    if (data.optionsPropsRef.current.hold)\n      return;\n    actions.goToOption(5 /* Nothing */);\n  });\n  let slot = (0, import_react17.useMemo)(() => ({ active, selected, disabled }), [active, selected, disabled]);\n  let ourProps = {\n    id: id2,\n    ref: optionRef,\n    role: \"option\",\n    tabIndex: disabled === true ? void 0 : -1,\n    \"aria-disabled\": disabled === true ? true : void 0,\n    \"aria-selected\": selected,\n    disabled: void 0,\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG,\n    name: \"Combobox.Option\"\n  });\n});\nvar Combobox = Object.assign(ComboboxRoot, { Input, Button, Label, Options, Option });\n\n// src/components/dialog/dialog.tsx\nvar import_react28 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\n\n// src/components/focus-trap/focus-trap.tsx\nvar import_react23 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\n\n// src/hooks/use-tab-direction.ts\nvar import_react19 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n// src/hooks/use-window-event.ts\nvar import_react18 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useWindowEvent(type, listener, options) {\n  let listenerRef = useLatestValue(listener);\n  (0, import_react18.useEffect)(() => {\n    function handler(event) {\n      listenerRef.current(event);\n    }\n    window.addEventListener(type, handler, options);\n    return () => window.removeEventListener(type, handler, options);\n  }, [type, options]);\n}\n\n// src/hooks/use-tab-direction.ts\nfunction useTabDirection() {\n  let direction = (0, import_react19.useRef)(0 /* Forwards */);\n  useWindowEvent(\"keydown\", (event) => {\n    if (event.key === \"Tab\") {\n      direction.current = event.shiftKey ? 1 /* Backwards */ : 0 /* Forwards */;\n    }\n  }, true);\n  return direction;\n}\n\n// src/hooks/use-is-mounted.ts\nvar import_react20 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useIsMounted() {\n  let mounted = (0, import_react20.useRef)(false);\n  useIsoMorphicEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  return mounted;\n}\n\n// src/hooks/use-owner.ts\nvar import_react21 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useOwnerDocument(...args) {\n  return (0, import_react21.useMemo)(() => getOwnerDocument(...args), [...args]);\n}\n\n// src/hooks/use-event-listener.ts\nvar import_react22 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useEventListener(element, type, listener, options) {\n  let listenerRef = useLatestValue(listener);\n  (0, import_react22.useEffect)(() => {\n    element = element != null ? element : window;\n    function handler(event) {\n      listenerRef.current(event);\n    }\n    element.addEventListener(type, handler, options);\n    return () => element.removeEventListener(type, handler, options);\n  }, [element, type, options]);\n}\n\n// src/components/focus-trap/focus-trap.tsx\nvar DEFAULT_FOCUS_TRAP_TAG = \"div\";\nvar Features3 = /* @__PURE__ */ ((Features4) => {\n  Features4[Features4[\"None\"] = 1] = \"None\";\n  Features4[Features4[\"InitialFocus\"] = 2] = \"InitialFocus\";\n  Features4[Features4[\"TabLock\"] = 4] = \"TabLock\";\n  Features4[Features4[\"FocusLock\"] = 8] = \"FocusLock\";\n  Features4[Features4[\"RestoreFocus\"] = 16] = \"RestoreFocus\";\n  Features4[Features4[\"All\"] = 30] = \"All\";\n  return Features4;\n})(Features3 || {});\nvar FocusTrap = Object.assign(forwardRefWithAs(function FocusTrap2(props, ref) {\n  let container = (0, import_react23.useRef)(null);\n  let focusTrapRef = useSyncRefs(container, ref);\n  let { initialFocus, containers, features = 30 /* All */, ...theirProps } = props;\n  if (!useServerHandoffComplete()) {\n    features = 1 /* None */;\n  }\n  let ownerDocument = useOwnerDocument(container);\n  useRestoreFocus({ ownerDocument }, Boolean(features & 16 /* RestoreFocus */));\n  let previousActiveElement = useInitialFocus({ ownerDocument, container, initialFocus }, Boolean(features & 2 /* InitialFocus */));\n  useFocusLock({ ownerDocument, container, containers, previousActiveElement }, Boolean(features & 8 /* FocusLock */));\n  let direction = useTabDirection();\n  let handleFocus = useEvent(() => {\n    let el = container.current;\n    if (!el)\n      return;\n    if (false) {} else {\n      match(direction.current, {\n        [0 /* Forwards */]: () => focusIn(el, 1 /* First */),\n        [1 /* Backwards */]: () => focusIn(el, 8 /* Last */)\n      });\n    }\n  });\n  let ourProps = { ref: focusTrapRef };\n  return /* @__PURE__ */ import_react23.default.createElement(import_react23.default.Fragment, null, Boolean(features & 4 /* TabLock */) && /* @__PURE__ */ import_react23.default.createElement(Hidden, {\n    as: \"button\",\n    type: \"button\",\n    onFocus: handleFocus,\n    features: 2 /* Focusable */\n  }), render({\n    ourProps,\n    theirProps,\n    defaultTag: DEFAULT_FOCUS_TRAP_TAG,\n    name: \"FocusTrap\"\n  }), Boolean(features & 4 /* TabLock */) && /* @__PURE__ */ import_react23.default.createElement(Hidden, {\n    as: \"button\",\n    type: \"button\",\n    onFocus: handleFocus,\n    features: 2 /* Focusable */\n  }));\n}), { features: Features3 });\nfunction useRestoreFocus({ ownerDocument }, enabled) {\n  let restoreElement = (0, import_react23.useRef)(null);\n  useEventListener(ownerDocument == null ? void 0 : ownerDocument.defaultView, \"focusout\", (event) => {\n    if (!enabled)\n      return;\n    if (restoreElement.current)\n      return;\n    restoreElement.current = event.target;\n  }, true);\n  useWatch(() => {\n    if (enabled)\n      return;\n    if ((ownerDocument == null ? void 0 : ownerDocument.activeElement) === (ownerDocument == null ? void 0 : ownerDocument.body)) {\n      focusElement(restoreElement.current);\n    }\n    restoreElement.current = null;\n  }, [enabled]);\n  let trulyUnmounted = (0, import_react23.useRef)(false);\n  (0, import_react23.useEffect)(() => {\n    trulyUnmounted.current = false;\n    return () => {\n      trulyUnmounted.current = true;\n      microTask(() => {\n        if (!trulyUnmounted.current)\n          return;\n        focusElement(restoreElement.current);\n        restoreElement.current = null;\n      });\n    };\n  }, []);\n}\nfunction useInitialFocus({\n  ownerDocument,\n  container,\n  initialFocus\n}, enabled) {\n  let previousActiveElement = (0, import_react23.useRef)(null);\n  let mounted = useIsMounted();\n  useWatch(() => {\n    if (!enabled)\n      return;\n    let containerElement = container.current;\n    if (!containerElement)\n      return;\n    microTask(() => {\n      if (!mounted.current) {\n        return;\n      }\n      let activeElement = ownerDocument == null ? void 0 : ownerDocument.activeElement;\n      if (initialFocus == null ? void 0 : initialFocus.current) {\n        if ((initialFocus == null ? void 0 : initialFocus.current) === activeElement) {\n          previousActiveElement.current = activeElement;\n          return;\n        }\n      } else if (containerElement.contains(activeElement)) {\n        previousActiveElement.current = activeElement;\n        return;\n      }\n      if (initialFocus == null ? void 0 : initialFocus.current) {\n        focusElement(initialFocus.current);\n      } else {\n        if (focusIn(containerElement, 1 /* First */) === 0 /* Error */) {\n          console.warn(\"There are no focusable elements inside the <FocusTrap />\");\n        }\n      }\n      previousActiveElement.current = ownerDocument == null ? void 0 : ownerDocument.activeElement;\n    });\n  }, [enabled]);\n  return previousActiveElement;\n}\nfunction useFocusLock({\n  ownerDocument,\n  container,\n  containers,\n  previousActiveElement\n}, enabled) {\n  let mounted = useIsMounted();\n  useEventListener(ownerDocument == null ? void 0 : ownerDocument.defaultView, \"focus\", (event) => {\n    if (!enabled)\n      return;\n    if (!mounted.current)\n      return;\n    let allContainers = new Set(containers == null ? void 0 : containers.current);\n    allContainers.add(container);\n    let previous = previousActiveElement.current;\n    if (!previous)\n      return;\n    let toElement = event.target;\n    if (toElement && toElement instanceof HTMLElement) {\n      if (!contains(allContainers, toElement)) {\n        event.preventDefault();\n        event.stopPropagation();\n        focusElement(previous);\n      } else {\n        previousActiveElement.current = toElement;\n        focusElement(toElement);\n      }\n    } else {\n      focusElement(previousActiveElement.current);\n    }\n  }, true);\n}\nfunction contains(containers, element) {\n  var _a2;\n  for (let container of containers) {\n    if ((_a2 = container.current) == null ? void 0 : _a2.contains(element))\n      return true;\n  }\n  return false;\n}\n\n// src/hooks/use-inert-others.ts\nvar interactables = /* @__PURE__ */ new Set();\nvar originals = /* @__PURE__ */ new Map();\nfunction inert(element) {\n  element.setAttribute(\"aria-hidden\", \"true\");\n  element.inert = true;\n}\nfunction restore(element) {\n  let original = originals.get(element);\n  if (!original)\n    return;\n  if (original[\"aria-hidden\"] === null)\n    element.removeAttribute(\"aria-hidden\");\n  else\n    element.setAttribute(\"aria-hidden\", original[\"aria-hidden\"]);\n  element.inert = original.inert;\n}\nfunction useInertOthers(container, enabled = true) {\n  useIsoMorphicEffect(() => {\n    if (!enabled)\n      return;\n    if (!container.current)\n      return;\n    let element = container.current;\n    let ownerDocument = getOwnerDocument(element);\n    if (!ownerDocument)\n      return;\n    interactables.add(element);\n    for (let original of originals.keys()) {\n      if (original.contains(element)) {\n        restore(original);\n        originals.delete(original);\n      }\n    }\n    ownerDocument.querySelectorAll(\"body > *\").forEach((child) => {\n      if (!(child instanceof HTMLElement))\n        return;\n      for (let interactable of interactables) {\n        if (child.contains(interactable))\n          return;\n      }\n      if (interactables.size === 1) {\n        originals.set(child, {\n          \"aria-hidden\": child.getAttribute(\"aria-hidden\"),\n          inert: child.inert\n        });\n        inert(child);\n      }\n    });\n    return () => {\n      interactables.delete(element);\n      if (interactables.size > 0) {\n        ownerDocument.querySelectorAll(\"body > *\").forEach((child) => {\n          if (!(child instanceof HTMLElement))\n            return;\n          if (originals.has(child))\n            return;\n          for (let interactable of interactables) {\n            if (child.contains(interactable))\n              return;\n          }\n          originals.set(child, {\n            \"aria-hidden\": child.getAttribute(\"aria-hidden\"),\n            inert: child.inert\n          });\n          inert(child);\n        });\n      } else {\n        for (let element2 of originals.keys()) {\n          restore(element2);\n          originals.delete(element2);\n        }\n      }\n    };\n  }, [enabled]);\n}\n\n// src/components/portal/portal.tsx\nvar import_react25 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar import_react_dom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n// src/internal/portal-force-root.tsx\nvar import_react24 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar ForcePortalRootContext = (0, import_react24.createContext)(false);\nfunction usePortalRoot() {\n  return (0, import_react24.useContext)(ForcePortalRootContext);\n}\nfunction ForcePortalRoot(props) {\n  return /* @__PURE__ */ import_react24.default.createElement(ForcePortalRootContext.Provider, {\n    value: props.force\n  }, props.children);\n}\n\n// src/components/portal/portal.tsx\nfunction usePortalTarget(ref) {\n  let forceInRoot = usePortalRoot();\n  let groupTarget = (0, import_react25.useContext)(PortalGroupContext);\n  let ownerDocument = useOwnerDocument(ref);\n  let [target, setTarget] = (0, import_react25.useState)(() => {\n    if (!forceInRoot && groupTarget !== null)\n      return null;\n    if (isServer)\n      return null;\n    let existingRoot = ownerDocument == null ? void 0 : ownerDocument.getElementById(\"headlessui-portal-root\");\n    if (existingRoot)\n      return existingRoot;\n    if (ownerDocument === null)\n      return null;\n    let root = ownerDocument.createElement(\"div\");\n    root.setAttribute(\"id\", \"headlessui-portal-root\");\n    return ownerDocument.body.appendChild(root);\n  });\n  (0, import_react25.useEffect)(() => {\n    if (target === null)\n      return;\n    if (!(ownerDocument == null ? void 0 : ownerDocument.body.contains(target))) {\n      ownerDocument == null ? void 0 : ownerDocument.body.appendChild(target);\n    }\n  }, [target, ownerDocument]);\n  (0, import_react25.useEffect)(() => {\n    if (forceInRoot)\n      return;\n    if (groupTarget === null)\n      return;\n    setTarget(groupTarget.current);\n  }, [groupTarget, setTarget, forceInRoot]);\n  return target;\n}\nvar DEFAULT_PORTAL_TAG = import_react25.Fragment;\nvar PortalRoot = forwardRefWithAs(function Portal(props, ref) {\n  let theirProps = props;\n  let internalPortalRootRef = (0, import_react25.useRef)(null);\n  let portalRef = useSyncRefs(optionalRef((ref2) => {\n    internalPortalRootRef.current = ref2;\n  }), ref);\n  let ownerDocument = useOwnerDocument(internalPortalRootRef);\n  let target = usePortalTarget(internalPortalRootRef);\n  let [element] = (0, import_react25.useState)(() => {\n    var _a2;\n    return isServer ? null : (_a2 = ownerDocument == null ? void 0 : ownerDocument.createElement(\"div\")) != null ? _a2 : null;\n  });\n  let ready = useServerHandoffComplete();\n  let trulyUnmounted = (0, import_react25.useRef)(false);\n  useIsoMorphicEffect(() => {\n    trulyUnmounted.current = false;\n    if (!target || !element)\n      return;\n    if (!target.contains(element)) {\n      element.setAttribute(\"data-headlessui-portal\", \"\");\n      target.appendChild(element);\n    }\n    return () => {\n      trulyUnmounted.current = true;\n      microTask(() => {\n        var _a2;\n        if (!trulyUnmounted.current)\n          return;\n        if (!target || !element)\n          return;\n        target.removeChild(element);\n        if (target.childNodes.length <= 0) {\n          (_a2 = target.parentElement) == null ? void 0 : _a2.removeChild(target);\n        }\n      });\n    };\n  }, [target, element]);\n  if (!ready)\n    return null;\n  let ourProps = { ref: portalRef };\n  return !target || !element ? null : (0, import_react_dom.createPortal)(render({\n    ourProps,\n    theirProps,\n    defaultTag: DEFAULT_PORTAL_TAG,\n    name: \"Portal\"\n  }), element);\n});\nvar DEFAULT_GROUP_TAG = import_react25.Fragment;\nvar PortalGroupContext = (0, import_react25.createContext)(null);\nvar Group = forwardRefWithAs(function Group2(props, ref) {\n  let { target, ...theirProps } = props;\n  let groupRef = useSyncRefs(ref);\n  let ourProps = { ref: groupRef };\n  return /* @__PURE__ */ import_react25.default.createElement(PortalGroupContext.Provider, {\n    value: target\n  }, render({\n    ourProps,\n    theirProps,\n    defaultTag: DEFAULT_GROUP_TAG,\n    name: \"Popover.Group\"\n  }));\n});\nvar Portal2 = Object.assign(PortalRoot, { Group });\n\n// src/components/description/description.tsx\nvar import_react26 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar DescriptionContext = (0, import_react26.createContext)(null);\nfunction useDescriptionContext() {\n  let context = (0, import_react26.useContext)(DescriptionContext);\n  if (context === null) {\n    let err = new Error(\"You used a <Description /> component, but it is not inside a relevant parent.\");\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useDescriptionContext);\n    throw err;\n  }\n  return context;\n}\nfunction useDescriptions() {\n  let [descriptionIds, setDescriptionIds] = (0, import_react26.useState)([]);\n  return [\n    descriptionIds.length > 0 ? descriptionIds.join(\" \") : void 0,\n    (0, import_react26.useMemo)(() => {\n      return function DescriptionProvider(props) {\n        let register = useEvent((value) => {\n          setDescriptionIds((existing) => [...existing, value]);\n          return () => setDescriptionIds((existing) => {\n            let clone = existing.slice();\n            let idx = clone.indexOf(value);\n            if (idx !== -1)\n              clone.splice(idx, 1);\n            return clone;\n          });\n        });\n        let contextBag = (0, import_react26.useMemo)(() => ({ register, slot: props.slot, name: props.name, props: props.props }), [register, props.slot, props.name, props.props]);\n        return /* @__PURE__ */ import_react26.default.createElement(DescriptionContext.Provider, {\n          value: contextBag\n        }, props.children);\n      };\n    }, [setDescriptionIds])\n  ];\n}\nvar DEFAULT_DESCRIPTION_TAG = \"p\";\nvar Description = forwardRefWithAs(function Description2(props, ref) {\n  let context = useDescriptionContext();\n  let id2 = `headlessui-description-${useId()}`;\n  let descriptionRef = useSyncRefs(ref);\n  useIsoMorphicEffect(() => context.register(id2), [id2, context.register]);\n  let theirProps = props;\n  let ourProps = { ref: descriptionRef, ...context.props, id: id2 };\n  return render({\n    ourProps,\n    theirProps,\n    slot: context.slot || {},\n    defaultTag: DEFAULT_DESCRIPTION_TAG,\n    name: context.name || \"Description\"\n  });\n});\n\n// src/internal/stack-context.tsx\nvar import_react27 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar StackContext = (0, import_react27.createContext)(() => {\n});\nStackContext.displayName = \"StackContext\";\nfunction useStackContext() {\n  return (0, import_react27.useContext)(StackContext);\n}\nfunction StackProvider({\n  children,\n  onUpdate,\n  type,\n  element,\n  enabled\n}) {\n  let parentUpdate = useStackContext();\n  let notify = useEvent((...args) => {\n    onUpdate == null ? void 0 : onUpdate(...args);\n    parentUpdate(...args);\n  });\n  useIsoMorphicEffect(() => {\n    let shouldNotify = enabled === void 0 || enabled === true;\n    shouldNotify && notify(0 /* Add */, type, element);\n    return () => {\n      shouldNotify && notify(1 /* Remove */, type, element);\n    };\n  }, [notify, type, element, enabled]);\n  return /* @__PURE__ */ import_react27.default.createElement(StackContext.Provider, {\n    value: notify\n  }, children);\n}\n\n// src/utils/platform.ts\nfunction isIOS() {\n  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;\n}\n\n// src/components/dialog/dialog.tsx\nvar reducers2 = {\n  [0 /* SetTitleId */](state2, action) {\n    if (state2.titleId === action.id)\n      return state2;\n    return { ...state2, titleId: action.id };\n  }\n};\nvar DialogContext = (0, import_react28.createContext)(null);\nDialogContext.displayName = \"DialogContext\";\nfunction useDialogContext(component) {\n  let context = (0, import_react28.useContext)(DialogContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Dialog /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useDialogContext);\n    throw err;\n  }\n  return context;\n}\nfunction useScrollLock(ownerDocument, enabled) {\n  (0, import_react28.useEffect)(() => {\n    var _a2;\n    if (!enabled)\n      return;\n    if (!ownerDocument)\n      return;\n    let d = disposables();\n    function style(node, property, value) {\n      let previous = node.style.getPropertyValue(property);\n      Object.assign(node.style, { [property]: value });\n      return d.add(() => {\n        Object.assign(node.style, { [property]: previous });\n      });\n    }\n    let documentElement = ownerDocument.documentElement;\n    let ownerWindow = (_a2 = ownerDocument.defaultView) != null ? _a2 : window;\n    let scrollbarWidthBefore = ownerWindow.innerWidth - documentElement.clientWidth;\n    style(documentElement, \"overflow\", \"hidden\");\n    if (scrollbarWidthBefore > 0) {\n      let scrollbarWidthAfter = documentElement.clientWidth - documentElement.offsetWidth;\n      let scrollbarWidth = scrollbarWidthBefore - scrollbarWidthAfter;\n      style(documentElement, \"paddingRight\", `${scrollbarWidth}px`);\n    }\n    if (isIOS()) {\n      let scrollPosition = window.pageYOffset;\n      style(documentElement, \"position\", \"fixed\");\n      style(documentElement, \"marginTop\", `-${scrollPosition}px`);\n      style(documentElement, \"width\", `100%`);\n      d.add(() => window.scrollTo(0, scrollPosition));\n    }\n    return d.dispose;\n  }, [ownerDocument, enabled]);\n}\nfunction stateReducer2(state2, action) {\n  return match(action.type, reducers2, state2, action);\n}\nvar DEFAULT_DIALOG_TAG = \"div\";\nvar DialogRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nvar DialogRoot = forwardRefWithAs(function Dialog(props, ref) {\n  let { open, onClose, initialFocus, __demoMode = false, ...theirProps } = props;\n  let [nestedDialogCount, setNestedDialogCount] = (0, import_react28.useState)(0);\n  let usesOpenClosedState = useOpenClosed();\n  if (open === void 0 && usesOpenClosedState !== null) {\n    open = match(usesOpenClosedState, {\n      [0 /* Open */]: true,\n      [1 /* Closed */]: false\n    });\n  }\n  let containers = (0, import_react28.useRef)(/* @__PURE__ */ new Set());\n  let internalDialogRef = (0, import_react28.useRef)(null);\n  let dialogRef = useSyncRefs(internalDialogRef, ref);\n  let mainTreeNode = (0, import_react28.useRef)(null);\n  let ownerDocument = useOwnerDocument(internalDialogRef);\n  let hasOpen = props.hasOwnProperty(\"open\") || usesOpenClosedState !== null;\n  let hasOnClose = props.hasOwnProperty(\"onClose\");\n  if (!hasOpen && !hasOnClose) {\n    throw new Error(`You have to provide an \\`open\\` and an \\`onClose\\` prop to the \\`Dialog\\` component.`);\n  }\n  if (!hasOpen) {\n    throw new Error(`You provided an \\`onClose\\` prop to the \\`Dialog\\`, but forgot an \\`open\\` prop.`);\n  }\n  if (!hasOnClose) {\n    throw new Error(`You provided an \\`open\\` prop to the \\`Dialog\\`, but forgot an \\`onClose\\` prop.`);\n  }\n  if (typeof open !== \"boolean\") {\n    throw new Error(`You provided an \\`open\\` prop to the \\`Dialog\\`, but the value is not a boolean. Received: ${open}`);\n  }\n  if (typeof onClose !== \"function\") {\n    throw new Error(`You provided an \\`onClose\\` prop to the \\`Dialog\\`, but the value is not a function. Received: ${onClose}`);\n  }\n  let dialogState = open ? 0 /* Open */ : 1 /* Closed */;\n  let [state2, dispatch] = (0, import_react28.useReducer)(stateReducer2, {\n    titleId: null,\n    descriptionId: null,\n    panelRef: (0, import_react28.createRef)()\n  });\n  let close = useEvent(() => onClose(false));\n  let setTitleId = useEvent((id3) => dispatch({ type: 0 /* SetTitleId */, id: id3 }));\n  let ready = useServerHandoffComplete();\n  let enabled = ready ? __demoMode ? false : dialogState === 0 /* Open */ : false;\n  let hasNestedDialogs = nestedDialogCount > 1;\n  let hasParentDialog = (0, import_react28.useContext)(DialogContext) !== null;\n  let position = !hasNestedDialogs ? \"leaf\" : \"parent\";\n  useInertOthers(internalDialogRef, hasNestedDialogs ? enabled : false);\n  useOutsideClick(() => {\n    var _a2, _b;\n    let rootContainers = Array.from((_a2 = ownerDocument == null ? void 0 : ownerDocument.querySelectorAll(\"body > *, [data-headlessui-portal]\")) != null ? _a2 : []).filter((container) => {\n      if (!(container instanceof HTMLElement))\n        return false;\n      if (container.contains(mainTreeNode.current))\n        return false;\n      if (state2.panelRef.current && container.contains(state2.panelRef.current))\n        return false;\n      return true;\n    });\n    return [\n      ...rootContainers,\n      (_b = state2.panelRef.current) != null ? _b : internalDialogRef.current\n    ];\n  }, close, enabled && !hasNestedDialogs);\n  useEventListener(ownerDocument == null ? void 0 : ownerDocument.defaultView, \"keydown\", (event) => {\n    if (event.defaultPrevented)\n      return;\n    if (event.key !== \"Escape\" /* Escape */)\n      return;\n    if (dialogState !== 0 /* Open */)\n      return;\n    if (hasNestedDialogs)\n      return;\n    event.preventDefault();\n    event.stopPropagation();\n    close();\n  });\n  useScrollLock(ownerDocument, dialogState === 0 /* Open */ && !hasParentDialog);\n  (0, import_react28.useEffect)(() => {\n    if (dialogState !== 0 /* Open */)\n      return;\n    if (!internalDialogRef.current)\n      return;\n    let observer = new IntersectionObserver((entries) => {\n      for (let entry of entries) {\n        if (entry.boundingClientRect.x === 0 && entry.boundingClientRect.y === 0 && entry.boundingClientRect.width === 0 && entry.boundingClientRect.height === 0) {\n          close();\n        }\n      }\n    });\n    observer.observe(internalDialogRef.current);\n    return () => observer.disconnect();\n  }, [dialogState, internalDialogRef, close]);\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let id2 = `headlessui-dialog-${useId()}`;\n  let contextBag = (0, import_react28.useMemo)(() => [{ dialogState, close, setTitleId }, state2], [dialogState, state2, close, setTitleId]);\n  let slot = (0, import_react28.useMemo)(() => ({ open: dialogState === 0 /* Open */ }), [dialogState]);\n  let ourProps = {\n    ref: dialogRef,\n    id: id2,\n    role: \"dialog\",\n    \"aria-modal\": dialogState === 0 /* Open */ ? true : void 0,\n    \"aria-labelledby\": state2.titleId,\n    \"aria-describedby\": describedby\n  };\n  return /* @__PURE__ */ import_react28.default.createElement(StackProvider, {\n    type: \"Dialog\",\n    enabled: dialogState === 0 /* Open */,\n    element: internalDialogRef,\n    onUpdate: useEvent((message, type, element) => {\n      if (type !== \"Dialog\")\n        return;\n      match(message, {\n        [0 /* Add */]() {\n          containers.current.add(element);\n          setNestedDialogCount((count) => count + 1);\n        },\n        [1 /* Remove */]() {\n          containers.current.add(element);\n          setNestedDialogCount((count) => count - 1);\n        }\n      });\n    })\n  }, /* @__PURE__ */ import_react28.default.createElement(ForcePortalRoot, {\n    force: true\n  }, /* @__PURE__ */ import_react28.default.createElement(Portal2, null, /* @__PURE__ */ import_react28.default.createElement(DialogContext.Provider, {\n    value: contextBag\n  }, /* @__PURE__ */ import_react28.default.createElement(Portal2.Group, {\n    target: internalDialogRef\n  }, /* @__PURE__ */ import_react28.default.createElement(ForcePortalRoot, {\n    force: false\n  }, /* @__PURE__ */ import_react28.default.createElement(DescriptionProvider, {\n    slot,\n    name: \"Dialog.Description\"\n  }, /* @__PURE__ */ import_react28.default.createElement(FocusTrap, {\n    initialFocus,\n    containers,\n    features: enabled ? match(position, {\n      parent: FocusTrap.features.RestoreFocus,\n      leaf: FocusTrap.features.All & ~FocusTrap.features.FocusLock\n    }) : FocusTrap.features.None\n  }, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_DIALOG_TAG,\n    features: DialogRenderFeatures,\n    visible: dialogState === 0 /* Open */,\n    name: \"Dialog\"\n  })))))))), /* @__PURE__ */ import_react28.default.createElement(Hidden, {\n    features: 4 /* Hidden */,\n    ref: mainTreeNode\n  }));\n});\nvar DEFAULT_OVERLAY_TAG = \"div\";\nvar Overlay = forwardRefWithAs(function Overlay2(props, ref) {\n  let [{ dialogState, close }] = useDialogContext(\"Dialog.Overlay\");\n  let overlayRef = useSyncRefs(ref);\n  let id2 = `headlessui-dialog-overlay-${useId()}`;\n  let handleClick = useEvent((event) => {\n    if (event.target !== event.currentTarget)\n      return;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    event.preventDefault();\n    event.stopPropagation();\n    close();\n  });\n  let slot = (0, import_react28.useMemo)(() => ({ open: dialogState === 0 /* Open */ }), [dialogState]);\n  let theirProps = props;\n  let ourProps = {\n    ref: overlayRef,\n    id: id2,\n    \"aria-hidden\": true,\n    onClick: handleClick\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OVERLAY_TAG,\n    name: \"Dialog.Overlay\"\n  });\n});\nvar DEFAULT_BACKDROP_TAG = \"div\";\nvar Backdrop = forwardRefWithAs(function Backdrop2(props, ref) {\n  let [{ dialogState }, state2] = useDialogContext(\"Dialog.Backdrop\");\n  let backdropRef = useSyncRefs(ref);\n  let id2 = `headlessui-dialog-backdrop-${useId()}`;\n  (0, import_react28.useEffect)(() => {\n    if (state2.panelRef.current === null) {\n      throw new Error(`A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.`);\n    }\n  }, [state2.panelRef]);\n  let slot = (0, import_react28.useMemo)(() => ({ open: dialogState === 0 /* Open */ }), [dialogState]);\n  let theirProps = props;\n  let ourProps = {\n    ref: backdropRef,\n    id: id2,\n    \"aria-hidden\": true\n  };\n  return /* @__PURE__ */ import_react28.default.createElement(ForcePortalRoot, {\n    force: true\n  }, /* @__PURE__ */ import_react28.default.createElement(Portal2, null, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BACKDROP_TAG,\n    name: \"Dialog.Backdrop\"\n  })));\n});\nvar DEFAULT_PANEL_TAG = \"div\";\nvar Panel = forwardRefWithAs(function Panel2(props, ref) {\n  let [{ dialogState }, state2] = useDialogContext(\"Dialog.Panel\");\n  let panelRef = useSyncRefs(ref, state2.panelRef);\n  let id2 = `headlessui-dialog-panel-${useId()}`;\n  let slot = (0, import_react28.useMemo)(() => ({ open: dialogState === 0 /* Open */ }), [dialogState]);\n  let handleClick = useEvent((event) => {\n    event.stopPropagation();\n  });\n  let theirProps = props;\n  let ourProps = {\n    ref: panelRef,\n    id: id2,\n    onClick: handleClick\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG,\n    name: \"Dialog.Panel\"\n  });\n});\nvar DEFAULT_TITLE_TAG = \"h2\";\nvar Title = forwardRefWithAs(function Title2(props, ref) {\n  let [{ dialogState, setTitleId }] = useDialogContext(\"Dialog.Title\");\n  let id2 = `headlessui-dialog-title-${useId()}`;\n  let titleRef = useSyncRefs(ref);\n  (0, import_react28.useEffect)(() => {\n    setTitleId(id2);\n    return () => setTitleId(null);\n  }, [id2, setTitleId]);\n  let slot = (0, import_react28.useMemo)(() => ({ open: dialogState === 0 /* Open */ }), [dialogState]);\n  let theirProps = props;\n  let ourProps = { ref: titleRef, id: id2 };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TITLE_TAG,\n    name: \"Dialog.Title\"\n  });\n});\nvar Dialog2 = Object.assign(DialogRoot, { Backdrop, Panel, Overlay, Title, Description });\n\n// src/components/disclosure/disclosure.tsx\nvar import_react29 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar reducers3 = {\n  [0 /* ToggleDisclosure */]: (state2) => ({\n    ...state2,\n    disclosureState: match(state2.disclosureState, {\n      [0 /* Open */]: 1 /* Closed */,\n      [1 /* Closed */]: 0 /* Open */\n    })\n  }),\n  [1 /* CloseDisclosure */]: (state2) => {\n    if (state2.disclosureState === 1 /* Closed */)\n      return state2;\n    return { ...state2, disclosureState: 1 /* Closed */ };\n  },\n  [4 /* LinkPanel */](state2) {\n    if (state2.linkedPanel === true)\n      return state2;\n    return { ...state2, linkedPanel: true };\n  },\n  [5 /* UnlinkPanel */](state2) {\n    if (state2.linkedPanel === false)\n      return state2;\n    return { ...state2, linkedPanel: false };\n  },\n  [2 /* SetButtonId */](state2, action) {\n    if (state2.buttonId === action.buttonId)\n      return state2;\n    return { ...state2, buttonId: action.buttonId };\n  },\n  [3 /* SetPanelId */](state2, action) {\n    if (state2.panelId === action.panelId)\n      return state2;\n    return { ...state2, panelId: action.panelId };\n  }\n};\nvar DisclosureContext = (0, import_react29.createContext)(null);\nDisclosureContext.displayName = \"DisclosureContext\";\nfunction useDisclosureContext(component) {\n  let context = (0, import_react29.useContext)(DisclosureContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Disclosure /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useDisclosureContext);\n    throw err;\n  }\n  return context;\n}\nvar DisclosureAPIContext = (0, import_react29.createContext)(null);\nDisclosureAPIContext.displayName = \"DisclosureAPIContext\";\nfunction useDisclosureAPIContext(component) {\n  let context = (0, import_react29.useContext)(DisclosureAPIContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Disclosure /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useDisclosureAPIContext);\n    throw err;\n  }\n  return context;\n}\nvar DisclosurePanelContext = (0, import_react29.createContext)(null);\nDisclosurePanelContext.displayName = \"DisclosurePanelContext\";\nfunction useDisclosurePanelContext() {\n  return (0, import_react29.useContext)(DisclosurePanelContext);\n}\nfunction stateReducer3(state2, action) {\n  return match(action.type, reducers3, state2, action);\n}\nvar DEFAULT_DISCLOSURE_TAG = import_react29.Fragment;\nvar DisclosureRoot = forwardRefWithAs(function Disclosure(props, ref) {\n  let { defaultOpen = false, ...theirProps } = props;\n  let buttonId = `headlessui-disclosure-button-${useId()}`;\n  let panelId = `headlessui-disclosure-panel-${useId()}`;\n  let internalDisclosureRef = (0, import_react29.useRef)(null);\n  let disclosureRef = useSyncRefs(ref, optionalRef((ref2) => {\n    internalDisclosureRef.current = ref2;\n  }, props.as === void 0 || props.as === import_react29.Fragment));\n  let panelRef = (0, import_react29.useRef)(null);\n  let buttonRef = (0, import_react29.useRef)(null);\n  let reducerBag = (0, import_react29.useReducer)(stateReducer3, {\n    disclosureState: defaultOpen ? 0 /* Open */ : 1 /* Closed */,\n    linkedPanel: false,\n    buttonRef,\n    panelRef,\n    buttonId,\n    panelId\n  });\n  let [{ disclosureState }, dispatch] = reducerBag;\n  (0, import_react29.useEffect)(() => dispatch({ type: 2 /* SetButtonId */, buttonId }), [buttonId, dispatch]);\n  (0, import_react29.useEffect)(() => dispatch({ type: 3 /* SetPanelId */, panelId }), [panelId, dispatch]);\n  let close = useEvent((focusableElement) => {\n    dispatch({ type: 1 /* CloseDisclosure */ });\n    let ownerDocument = getOwnerDocument(internalDisclosureRef);\n    if (!ownerDocument)\n      return;\n    let restoreElement = (() => {\n      if (!focusableElement)\n        return ownerDocument.getElementById(buttonId);\n      if (focusableElement instanceof HTMLElement)\n        return focusableElement;\n      if (focusableElement.current instanceof HTMLElement)\n        return focusableElement.current;\n      return ownerDocument.getElementById(buttonId);\n    })();\n    restoreElement == null ? void 0 : restoreElement.focus();\n  });\n  let api = (0, import_react29.useMemo)(() => ({ close }), [close]);\n  let slot = (0, import_react29.useMemo)(() => ({ open: disclosureState === 0 /* Open */, close }), [disclosureState, close]);\n  let ourProps = {\n    ref: disclosureRef\n  };\n  return /* @__PURE__ */ import_react29.default.createElement(DisclosureContext.Provider, {\n    value: reducerBag\n  }, /* @__PURE__ */ import_react29.default.createElement(DisclosureAPIContext.Provider, {\n    value: api\n  }, /* @__PURE__ */ import_react29.default.createElement(OpenClosedProvider, {\n    value: match(disclosureState, {\n      [0 /* Open */]: 0 /* Open */,\n      [1 /* Closed */]: 1 /* Closed */\n    })\n  }, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_DISCLOSURE_TAG,\n    name: \"Disclosure\"\n  }))));\n});\nvar DEFAULT_BUTTON_TAG2 = \"button\";\nvar Button3 = forwardRefWithAs(function Button4(props, ref) {\n  let [state2, dispatch] = useDisclosureContext(\"Disclosure.Button\");\n  let panelContext = useDisclosurePanelContext();\n  let isWithinPanel = panelContext === null ? false : panelContext === state2.panelId;\n  let internalButtonRef = (0, import_react29.useRef)(null);\n  let buttonRef = useSyncRefs(internalButtonRef, ref, !isWithinPanel ? state2.buttonRef : null);\n  let handleKeyDown = useEvent((event) => {\n    var _a2;\n    if (isWithinPanel) {\n      if (state2.disclosureState === 1 /* Closed */)\n        return;\n      switch (event.key) {\n        case \" \" /* Space */:\n        case \"Enter\" /* Enter */:\n          event.preventDefault();\n          event.stopPropagation();\n          dispatch({ type: 0 /* ToggleDisclosure */ });\n          (_a2 = state2.buttonRef.current) == null ? void 0 : _a2.focus();\n          break;\n      }\n    } else {\n      switch (event.key) {\n        case \" \" /* Space */:\n        case \"Enter\" /* Enter */:\n          event.preventDefault();\n          event.stopPropagation();\n          dispatch({ type: 0 /* ToggleDisclosure */ });\n          break;\n      }\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n        event.preventDefault();\n        break;\n    }\n  });\n  let handleClick = useEvent((event) => {\n    var _a2;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return;\n    if (props.disabled)\n      return;\n    if (isWithinPanel) {\n      dispatch({ type: 0 /* ToggleDisclosure */ });\n      (_a2 = state2.buttonRef.current) == null ? void 0 : _a2.focus();\n    } else {\n      dispatch({ type: 0 /* ToggleDisclosure */ });\n    }\n  });\n  let slot = (0, import_react29.useMemo)(() => ({ open: state2.disclosureState === 0 /* Open */ }), [state2]);\n  let type = useResolveButtonType(props, internalButtonRef);\n  let theirProps = props;\n  let ourProps = isWithinPanel ? { ref: buttonRef, type, onKeyDown: handleKeyDown, onClick: handleClick } : {\n    ref: buttonRef,\n    id: state2.buttonId,\n    type,\n    \"aria-expanded\": props.disabled ? void 0 : state2.disclosureState === 0 /* Open */,\n    \"aria-controls\": state2.linkedPanel ? state2.panelId : void 0,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onClick: handleClick\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG2,\n    name: \"Disclosure.Button\"\n  });\n});\nvar DEFAULT_PANEL_TAG2 = \"div\";\nvar PanelRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nvar Panel3 = forwardRefWithAs(function Panel4(props, ref) {\n  let [state2, dispatch] = useDisclosureContext(\"Disclosure.Panel\");\n  let { close } = useDisclosureAPIContext(\"Disclosure.Panel\");\n  let panelRef = useSyncRefs(ref, state2.panelRef, (el) => {\n    dispatch({ type: el ? 4 /* LinkPanel */ : 5 /* UnlinkPanel */ });\n  });\n  let usesOpenClosedState = useOpenClosed();\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === 0 /* Open */;\n    }\n    return state2.disclosureState === 0 /* Open */;\n  })();\n  let slot = (0, import_react29.useMemo)(() => ({ open: state2.disclosureState === 0 /* Open */, close }), [state2, close]);\n  let theirProps = props;\n  let ourProps = {\n    ref: panelRef,\n    id: state2.panelId\n  };\n  return /* @__PURE__ */ import_react29.default.createElement(DisclosurePanelContext.Provider, {\n    value: state2.panelId\n  }, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG2,\n    features: PanelRenderFeatures,\n    visible,\n    name: \"Disclosure.Panel\"\n  }));\n});\nvar Disclosure2 = Object.assign(DisclosureRoot, { Button: Button3, Panel: Panel3 });\n\n// src/components/listbox/listbox.tsx\nvar import_react30 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nfunction adjustOrderedState2(state2, adjustment = (i) => i) {\n  let currentActiveOption = state2.activeOptionIndex !== null ? state2.options[state2.activeOptionIndex] : null;\n  let sortedOptions = sortByDomNode(adjustment(state2.options.slice()), (option) => option.dataRef.current.domRef.current);\n  let adjustedActiveOptionIndex = currentActiveOption ? sortedOptions.indexOf(currentActiveOption) : null;\n  if (adjustedActiveOptionIndex === -1) {\n    adjustedActiveOptionIndex = null;\n  }\n  return {\n    options: sortedOptions,\n    activeOptionIndex: adjustedActiveOptionIndex\n  };\n}\nvar reducers4 = {\n  [1 /* CloseListbox */](state2) {\n    if (state2.disabled)\n      return state2;\n    if (state2.listboxState === 1 /* Closed */)\n      return state2;\n    return { ...state2, activeOptionIndex: null, listboxState: 1 /* Closed */ };\n  },\n  [0 /* OpenListbox */](state2) {\n    if (state2.disabled)\n      return state2;\n    if (state2.listboxState === 0 /* Open */)\n      return state2;\n    let activeOptionIndex = state2.activeOptionIndex;\n    let { value, mode, compare } = state2.propsRef.current;\n    let optionIdx = state2.options.findIndex((option) => {\n      let optionValue = option.dataRef.current.value;\n      let selected = match(mode, {\n        [1 /* Multi */]: () => value.some((option2) => compare(option2, optionValue)),\n        [0 /* Single */]: () => compare(value, optionValue)\n      });\n      return selected;\n    });\n    if (optionIdx !== -1) {\n      activeOptionIndex = optionIdx;\n    }\n    return { ...state2, listboxState: 0 /* Open */, activeOptionIndex };\n  },\n  [2 /* SetDisabled */](state2, action) {\n    if (state2.disabled === action.disabled)\n      return state2;\n    return { ...state2, disabled: action.disabled };\n  },\n  [3 /* SetOrientation */](state2, action) {\n    if (state2.orientation === action.orientation)\n      return state2;\n    return { ...state2, orientation: action.orientation };\n  },\n  [4 /* GoToOption */](state2, action) {\n    var _a2;\n    if (state2.disabled)\n      return state2;\n    if (state2.listboxState === 1 /* Closed */)\n      return state2;\n    let adjustedState = adjustOrderedState2(state2);\n    let activeOptionIndex = calculateActiveIndex(action, {\n      resolveItems: () => adjustedState.options,\n      resolveActiveIndex: () => adjustedState.activeOptionIndex,\n      resolveId: (option) => option.id,\n      resolveDisabled: (option) => option.dataRef.current.disabled\n    });\n    return {\n      ...state2,\n      ...adjustedState,\n      searchQuery: \"\",\n      activeOptionIndex,\n      activationTrigger: (_a2 = action.trigger) != null ? _a2 : 1 /* Other */\n    };\n  },\n  [5 /* Search */]: (state2, action) => {\n    if (state2.disabled)\n      return state2;\n    if (state2.listboxState === 1 /* Closed */)\n      return state2;\n    let wasAlreadySearching = state2.searchQuery !== \"\";\n    let offset = wasAlreadySearching ? 0 : 1;\n    let searchQuery = state2.searchQuery + action.value.toLowerCase();\n    let reOrderedOptions = state2.activeOptionIndex !== null ? state2.options.slice(state2.activeOptionIndex + offset).concat(state2.options.slice(0, state2.activeOptionIndex + offset)) : state2.options;\n    let matchingOption = reOrderedOptions.find((option) => {\n      var _a2;\n      return !option.dataRef.current.disabled && ((_a2 = option.dataRef.current.textValue) == null ? void 0 : _a2.startsWith(searchQuery));\n    });\n    let matchIdx = matchingOption ? state2.options.indexOf(matchingOption) : -1;\n    if (matchIdx === -1 || matchIdx === state2.activeOptionIndex)\n      return { ...state2, searchQuery };\n    return {\n      ...state2,\n      searchQuery,\n      activeOptionIndex: matchIdx,\n      activationTrigger: 1 /* Other */\n    };\n  },\n  [6 /* ClearSearch */](state2) {\n    if (state2.disabled)\n      return state2;\n    if (state2.listboxState === 1 /* Closed */)\n      return state2;\n    if (state2.searchQuery === \"\")\n      return state2;\n    return { ...state2, searchQuery: \"\" };\n  },\n  [7 /* RegisterOption */]: (state2, action) => {\n    let option = { id: action.id, dataRef: action.dataRef };\n    let adjustedState = adjustOrderedState2(state2, (options) => [...options, option]);\n    if (state2.activeOptionIndex === null) {\n      let { value, mode, compare } = state2.propsRef.current;\n      let optionValue = action.dataRef.current.value;\n      let selected = match(mode, {\n        [1 /* Multi */]: () => value.some((option2) => compare(option2, optionValue)),\n        [0 /* Single */]: () => compare(value, optionValue)\n      });\n      if (selected) {\n        adjustedState.activeOptionIndex = adjustedState.options.indexOf(option);\n      }\n    }\n    return { ...state2, ...adjustedState };\n  },\n  [8 /* UnregisterOption */]: (state2, action) => {\n    let adjustedState = adjustOrderedState2(state2, (options) => {\n      let idx = options.findIndex((a) => a.id === action.id);\n      if (idx !== -1)\n        options.splice(idx, 1);\n      return options;\n    });\n    return {\n      ...state2,\n      ...adjustedState,\n      activationTrigger: 1 /* Other */\n    };\n  }\n};\nvar ListboxContext = (0, import_react30.createContext)(null);\nListboxContext.displayName = \"ListboxContext\";\nfunction useListboxContext(component) {\n  let context = (0, import_react30.useContext)(ListboxContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Listbox /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useListboxContext);\n    throw err;\n  }\n  return context;\n}\nfunction stateReducer4(state2, action) {\n  return match(action.type, reducers4, state2, action);\n}\nvar DEFAULT_LISTBOX_TAG = import_react30.Fragment;\nvar ListboxRoot = forwardRefWithAs(function Listbox(props, ref) {\n  let {\n    value: controlledValue,\n    defaultValue,\n    name,\n    onChange: controlledOnChange,\n    by = (a, z) => a === z,\n    disabled = false,\n    horizontal = false,\n    multiple = false,\n    ...theirProps\n  } = props;\n  const orientation = horizontal ? \"horizontal\" : \"vertical\";\n  let listboxRef = useSyncRefs(ref);\n  let [value, onChange] = useControllable(controlledValue, controlledOnChange, defaultValue);\n  let reducerBag = (0, import_react30.useReducer)(stateReducer4, {\n    listboxState: 1 /* Closed */,\n    propsRef: {\n      current: {\n        value,\n        onChange,\n        mode: multiple ? 1 /* Multi */ : 0 /* Single */,\n        compare: useEvent(typeof by === \"string\" ? (a, z) => {\n          let property = by;\n          return (a == null ? void 0 : a[property]) === (z == null ? void 0 : z[property]);\n        } : by)\n      }\n    },\n    labelRef: (0, import_react30.createRef)(),\n    buttonRef: (0, import_react30.createRef)(),\n    optionsRef: (0, import_react30.createRef)(),\n    disabled,\n    orientation,\n    options: [],\n    searchQuery: \"\",\n    activeOptionIndex: null,\n    activationTrigger: 1 /* Other */\n  });\n  let [{ listboxState, propsRef, optionsRef, buttonRef }, dispatch] = reducerBag;\n  propsRef.current.value = value;\n  propsRef.current.mode = multiple ? 1 /* Multi */ : 0 /* Single */;\n  useIsoMorphicEffect(() => {\n    propsRef.current.onChange = (value2) => {\n      return match(propsRef.current.mode, {\n        [0 /* Single */]() {\n          return onChange(value2);\n        },\n        [1 /* Multi */]() {\n          let copy = propsRef.current.value.slice();\n          let { compare } = propsRef.current;\n          let idx = copy.findIndex((item) => compare(item, value2));\n          if (idx === -1) {\n            copy.push(value2);\n          } else {\n            copy.splice(idx, 1);\n          }\n          return onChange(copy);\n        }\n      });\n    };\n  }, [onChange, propsRef]);\n  useIsoMorphicEffect(() => dispatch({ type: 2 /* SetDisabled */, disabled }), [disabled]);\n  useIsoMorphicEffect(() => dispatch({ type: 3 /* SetOrientation */, orientation }), [orientation]);\n  useOutsideClick([buttonRef, optionsRef], (event, target) => {\n    var _a2;\n    dispatch({ type: 1 /* CloseListbox */ });\n    if (!isFocusableElement(target, 1 /* Loose */)) {\n      event.preventDefault();\n      (_a2 = buttonRef.current) == null ? void 0 : _a2.focus();\n    }\n  }, listboxState === 0 /* Open */);\n  let slot = (0, import_react30.useMemo)(() => ({ open: listboxState === 0 /* Open */, disabled, value }), [listboxState, disabled, value]);\n  let ourProps = { ref: listboxRef };\n  return /* @__PURE__ */ import_react30.default.createElement(ListboxContext.Provider, {\n    value: reducerBag\n  }, /* @__PURE__ */ import_react30.default.createElement(OpenClosedProvider, {\n    value: match(listboxState, {\n      [0 /* Open */]: 0 /* Open */,\n      [1 /* Closed */]: 1 /* Closed */\n    })\n  }, name != null && value != null && objectToFormEntries({ [name]: value }).map(([name2, value2]) => /* @__PURE__ */ import_react30.default.createElement(Hidden, {\n    features: 4 /* Hidden */,\n    ...compact({\n      key: name2,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: true,\n      readOnly: true,\n      name: name2,\n      value: value2\n    })\n  })), render({ ourProps, theirProps, slot, defaultTag: DEFAULT_LISTBOX_TAG, name: \"Listbox\" })));\n});\nvar DEFAULT_BUTTON_TAG3 = \"button\";\nvar Button5 = forwardRefWithAs(function Button6(props, ref) {\n  var _a2;\n  let [state2, dispatch] = useListboxContext(\"Listbox.Button\");\n  let buttonRef = useSyncRefs(state2.buttonRef, ref);\n  let id2 = `headlessui-listbox-button-${useId()}`;\n  let d = useDisposables();\n  let handleKeyDown = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n      case \"Enter\" /* Enter */:\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        dispatch({ type: 0 /* OpenListbox */ });\n        d.nextFrame(() => {\n          if (!state2.propsRef.current.value)\n            dispatch({ type: 4 /* GoToOption */, focus: 0 /* First */ });\n        });\n        break;\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        dispatch({ type: 0 /* OpenListbox */ });\n        d.nextFrame(() => {\n          if (!state2.propsRef.current.value)\n            dispatch({ type: 4 /* GoToOption */, focus: 3 /* Last */ });\n        });\n        break;\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n        event.preventDefault();\n        break;\n    }\n  });\n  let handleClick = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    if (state2.listboxState === 0 /* Open */) {\n      dispatch({ type: 1 /* CloseListbox */ });\n      d.nextFrame(() => {\n        var _a3;\n        return (_a3 = state2.buttonRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n      });\n    } else {\n      event.preventDefault();\n      dispatch({ type: 0 /* OpenListbox */ });\n    }\n  });\n  let labelledby = useComputed(() => {\n    if (!state2.labelRef.current)\n      return void 0;\n    return [state2.labelRef.current.id, id2].join(\" \");\n  }, [state2.labelRef.current, id2]);\n  let slot = (0, import_react30.useMemo)(() => ({\n    open: state2.listboxState === 0 /* Open */,\n    disabled: state2.disabled,\n    value: state2.propsRef.current.value\n  }), [state2]);\n  let theirProps = props;\n  let ourProps = {\n    ref: buttonRef,\n    id: id2,\n    type: useResolveButtonType(props, state2.buttonRef),\n    \"aria-haspopup\": true,\n    \"aria-controls\": (_a2 = state2.optionsRef.current) == null ? void 0 : _a2.id,\n    \"aria-expanded\": state2.disabled ? void 0 : state2.listboxState === 0 /* Open */,\n    \"aria-labelledby\": labelledby,\n    disabled: state2.disabled,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onClick: handleClick\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG3,\n    name: \"Listbox.Button\"\n  });\n});\nvar DEFAULT_LABEL_TAG2 = \"label\";\nvar Label3 = forwardRefWithAs(function Label4(props, ref) {\n  let [state2] = useListboxContext(\"Listbox.Label\");\n  let id2 = `headlessui-listbox-label-${useId()}`;\n  let labelRef = useSyncRefs(state2.labelRef, ref);\n  let handleClick = useEvent(() => {\n    var _a2;\n    return (_a2 = state2.buttonRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });\n  });\n  let slot = (0, import_react30.useMemo)(() => ({ open: state2.listboxState === 0 /* Open */, disabled: state2.disabled }), [state2]);\n  let theirProps = props;\n  let ourProps = { ref: labelRef, id: id2, onClick: handleClick };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_LABEL_TAG2,\n    name: \"Listbox.Label\"\n  });\n});\nvar DEFAULT_OPTIONS_TAG2 = \"ul\";\nvar OptionsRenderFeatures2 = 1 /* RenderStrategy */ | 2 /* Static */;\nvar Options3 = forwardRefWithAs(function Options4(props, ref) {\n  var _a2;\n  let [state2, dispatch] = useListboxContext(\"Listbox.Options\");\n  let optionsRef = useSyncRefs(state2.optionsRef, ref);\n  let id2 = `headlessui-listbox-options-${useId()}`;\n  let d = useDisposables();\n  let searchDisposables = useDisposables();\n  let usesOpenClosedState = useOpenClosed();\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === 0 /* Open */;\n    }\n    return state2.listboxState === 0 /* Open */;\n  })();\n  (0, import_react30.useEffect)(() => {\n    var _a3;\n    let container = state2.optionsRef.current;\n    if (!container)\n      return;\n    if (state2.listboxState !== 0 /* Open */)\n      return;\n    if (container === ((_a3 = getOwnerDocument(container)) == null ? void 0 : _a3.activeElement))\n      return;\n    container.focus({ preventScroll: true });\n  }, [state2.listboxState, state2.optionsRef]);\n  let handleKeyDown = useEvent((event) => {\n    searchDisposables.dispose();\n    switch (event.key) {\n      case \" \" /* Space */:\n        if (state2.searchQuery !== \"\") {\n          event.preventDefault();\n          event.stopPropagation();\n          return dispatch({ type: 5 /* Search */, value: event.key });\n        }\n      case \"Enter\" /* Enter */:\n        event.preventDefault();\n        event.stopPropagation();\n        if (state2.activeOptionIndex !== null) {\n          let { dataRef } = state2.options[state2.activeOptionIndex];\n          state2.propsRef.current.onChange(dataRef.current.value);\n        }\n        if (state2.propsRef.current.mode === 0 /* Single */) {\n          dispatch({ type: 1 /* CloseListbox */ });\n          disposables().nextFrame(() => {\n            var _a3;\n            return (_a3 = state2.buttonRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n          });\n        }\n        break;\n      case match(state2.orientation, { vertical: \"ArrowDown\" /* ArrowDown */, horizontal: \"ArrowRight\" /* ArrowRight */ }):\n        event.preventDefault();\n        event.stopPropagation();\n        return dispatch({ type: 4 /* GoToOption */, focus: 2 /* Next */ });\n      case match(state2.orientation, { vertical: \"ArrowUp\" /* ArrowUp */, horizontal: \"ArrowLeft\" /* ArrowLeft */ }):\n        event.preventDefault();\n        event.stopPropagation();\n        return dispatch({ type: 4 /* GoToOption */, focus: 1 /* Previous */ });\n      case \"Home\" /* Home */:\n      case \"PageUp\" /* PageUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return dispatch({ type: 4 /* GoToOption */, focus: 0 /* First */ });\n      case \"End\" /* End */:\n      case \"PageDown\" /* PageDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return dispatch({ type: 4 /* GoToOption */, focus: 3 /* Last */ });\n      case \"Escape\" /* Escape */:\n        event.preventDefault();\n        event.stopPropagation();\n        dispatch({ type: 1 /* CloseListbox */ });\n        return d.nextFrame(() => {\n          var _a3;\n          return (_a3 = state2.buttonRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n        });\n      case \"Tab\" /* Tab */:\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n      default:\n        if (event.key.length === 1) {\n          dispatch({ type: 5 /* Search */, value: event.key });\n          searchDisposables.setTimeout(() => dispatch({ type: 6 /* ClearSearch */ }), 350);\n        }\n        break;\n    }\n  });\n  let labelledby = useComputed(() => {\n    var _a3, _b, _c;\n    return (_c = (_a3 = state2.labelRef.current) == null ? void 0 : _a3.id) != null ? _c : (_b = state2.buttonRef.current) == null ? void 0 : _b.id;\n  }, [state2.labelRef.current, state2.buttonRef.current]);\n  let slot = (0, import_react30.useMemo)(() => ({ open: state2.listboxState === 0 /* Open */ }), [state2]);\n  let theirProps = props;\n  let ourProps = {\n    \"aria-activedescendant\": state2.activeOptionIndex === null ? void 0 : (_a2 = state2.options[state2.activeOptionIndex]) == null ? void 0 : _a2.id,\n    \"aria-multiselectable\": state2.propsRef.current.mode === 1 /* Multi */ ? true : void 0,\n    \"aria-labelledby\": labelledby,\n    \"aria-orientation\": state2.orientation,\n    id: id2,\n    onKeyDown: handleKeyDown,\n    role: \"listbox\",\n    tabIndex: 0,\n    ref: optionsRef\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTIONS_TAG2,\n    features: OptionsRenderFeatures2,\n    visible,\n    name: \"Listbox.Options\"\n  });\n});\nvar DEFAULT_OPTION_TAG2 = \"li\";\nvar Option3 = forwardRefWithAs(function Option4(props, ref) {\n  let { disabled = false, value, ...theirProps } = props;\n  let [state2, dispatch] = useListboxContext(\"Listbox.Option\");\n  let id2 = `headlessui-listbox-option-${useId()}`;\n  let active = state2.activeOptionIndex !== null ? state2.options[state2.activeOptionIndex].id === id2 : false;\n  let { value: optionValue, compare } = state2.propsRef.current;\n  let selected = match(state2.propsRef.current.mode, {\n    [1 /* Multi */]: () => optionValue.some((option) => compare(option, value)),\n    [0 /* Single */]: () => compare(optionValue, value)\n  });\n  let internalOptionRef = (0, import_react30.useRef)(null);\n  let optionRef = useSyncRefs(ref, internalOptionRef);\n  useIsoMorphicEffect(() => {\n    if (state2.listboxState !== 0 /* Open */)\n      return;\n    if (!active)\n      return;\n    if (state2.activationTrigger === 0 /* Pointer */)\n      return;\n    let d = disposables();\n    d.requestAnimationFrame(() => {\n      var _a2, _b;\n      (_b = (_a2 = internalOptionRef.current) == null ? void 0 : _a2.scrollIntoView) == null ? void 0 : _b.call(_a2, { block: \"nearest\" });\n    });\n    return d.dispose;\n  }, [internalOptionRef, active, state2.listboxState, state2.activationTrigger, state2.activeOptionIndex]);\n  let bag = (0, import_react30.useRef)({ disabled, value, domRef: internalOptionRef });\n  useIsoMorphicEffect(() => {\n    bag.current.disabled = disabled;\n  }, [bag, disabled]);\n  useIsoMorphicEffect(() => {\n    bag.current.value = value;\n  }, [bag, value]);\n  useIsoMorphicEffect(() => {\n    var _a2, _b;\n    bag.current.textValue = (_b = (_a2 = internalOptionRef.current) == null ? void 0 : _a2.textContent) == null ? void 0 : _b.toLowerCase();\n  }, [bag, internalOptionRef]);\n  let select = useEvent(() => state2.propsRef.current.onChange(value));\n  useIsoMorphicEffect(() => {\n    dispatch({ type: 7 /* RegisterOption */, id: id2, dataRef: bag });\n    return () => dispatch({ type: 8 /* UnregisterOption */, id: id2 });\n  }, [bag, id2]);\n  let handleClick = useEvent((event) => {\n    if (disabled)\n      return event.preventDefault();\n    select();\n    if (state2.propsRef.current.mode === 0 /* Single */) {\n      dispatch({ type: 1 /* CloseListbox */ });\n      disposables().nextFrame(() => {\n        var _a2;\n        return (_a2 = state2.buttonRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });\n      });\n    }\n  });\n  let handleFocus = useEvent(() => {\n    if (disabled)\n      return dispatch({ type: 4 /* GoToOption */, focus: 5 /* Nothing */ });\n    dispatch({ type: 4 /* GoToOption */, focus: 4 /* Specific */, id: id2 });\n  });\n  let handleMove = useEvent(() => {\n    if (disabled)\n      return;\n    if (active)\n      return;\n    dispatch({\n      type: 4 /* GoToOption */,\n      focus: 4 /* Specific */,\n      id: id2,\n      trigger: 0 /* Pointer */\n    });\n  });\n  let handleLeave = useEvent(() => {\n    if (disabled)\n      return;\n    if (!active)\n      return;\n    dispatch({ type: 4 /* GoToOption */, focus: 5 /* Nothing */ });\n  });\n  let slot = (0, import_react30.useMemo)(() => ({ active, selected, disabled }), [active, selected, disabled]);\n  let ourProps = {\n    id: id2,\n    ref: optionRef,\n    role: \"option\",\n    tabIndex: disabled === true ? void 0 : -1,\n    \"aria-disabled\": disabled === true ? true : void 0,\n    \"aria-selected\": selected,\n    disabled: void 0,\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG2,\n    name: \"Listbox.Option\"\n  });\n});\nvar Listbox2 = Object.assign(ListboxRoot, { Button: Button5, Label: Label3, Options: Options3, Option: Option3 });\n\n// src/components/menu/menu.tsx\nvar import_react31 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nfunction adjustOrderedState3(state2, adjustment = (i) => i) {\n  let currentActiveItem = state2.activeItemIndex !== null ? state2.items[state2.activeItemIndex] : null;\n  let sortedItems = sortByDomNode(adjustment(state2.items.slice()), (item) => item.dataRef.current.domRef.current);\n  let adjustedActiveItemIndex = currentActiveItem ? sortedItems.indexOf(currentActiveItem) : null;\n  if (adjustedActiveItemIndex === -1) {\n    adjustedActiveItemIndex = null;\n  }\n  return {\n    items: sortedItems,\n    activeItemIndex: adjustedActiveItemIndex\n  };\n}\nvar reducers5 = {\n  [1 /* CloseMenu */](state2) {\n    if (state2.menuState === 1 /* Closed */)\n      return state2;\n    return { ...state2, activeItemIndex: null, menuState: 1 /* Closed */ };\n  },\n  [0 /* OpenMenu */](state2) {\n    if (state2.menuState === 0 /* Open */)\n      return state2;\n    return { ...state2, menuState: 0 /* Open */ };\n  },\n  [2 /* GoToItem */]: (state2, action) => {\n    var _a2;\n    let adjustedState = adjustOrderedState3(state2);\n    let activeItemIndex = calculateActiveIndex(action, {\n      resolveItems: () => adjustedState.items,\n      resolveActiveIndex: () => adjustedState.activeItemIndex,\n      resolveId: (item) => item.id,\n      resolveDisabled: (item) => item.dataRef.current.disabled\n    });\n    return {\n      ...state2,\n      ...adjustedState,\n      searchQuery: \"\",\n      activeItemIndex,\n      activationTrigger: (_a2 = action.trigger) != null ? _a2 : 1 /* Other */\n    };\n  },\n  [3 /* Search */]: (state2, action) => {\n    let wasAlreadySearching = state2.searchQuery !== \"\";\n    let offset = wasAlreadySearching ? 0 : 1;\n    let searchQuery = state2.searchQuery + action.value.toLowerCase();\n    let reOrderedItems = state2.activeItemIndex !== null ? state2.items.slice(state2.activeItemIndex + offset).concat(state2.items.slice(0, state2.activeItemIndex + offset)) : state2.items;\n    let matchingItem = reOrderedItems.find((item) => {\n      var _a2;\n      return ((_a2 = item.dataRef.current.textValue) == null ? void 0 : _a2.startsWith(searchQuery)) && !item.dataRef.current.disabled;\n    });\n    let matchIdx = matchingItem ? state2.items.indexOf(matchingItem) : -1;\n    if (matchIdx === -1 || matchIdx === state2.activeItemIndex)\n      return { ...state2, searchQuery };\n    return {\n      ...state2,\n      searchQuery,\n      activeItemIndex: matchIdx,\n      activationTrigger: 1 /* Other */\n    };\n  },\n  [4 /* ClearSearch */](state2) {\n    if (state2.searchQuery === \"\")\n      return state2;\n    return { ...state2, searchQuery: \"\", searchActiveItemIndex: null };\n  },\n  [5 /* RegisterItem */]: (state2, action) => {\n    let adjustedState = adjustOrderedState3(state2, (items) => [\n      ...items,\n      { id: action.id, dataRef: action.dataRef }\n    ]);\n    return { ...state2, ...adjustedState };\n  },\n  [6 /* UnregisterItem */]: (state2, action) => {\n    let adjustedState = adjustOrderedState3(state2, (items) => {\n      let idx = items.findIndex((a) => a.id === action.id);\n      if (idx !== -1)\n        items.splice(idx, 1);\n      return items;\n    });\n    return {\n      ...state2,\n      ...adjustedState,\n      activationTrigger: 1 /* Other */\n    };\n  }\n};\nvar MenuContext = (0, import_react31.createContext)(null);\nMenuContext.displayName = \"MenuContext\";\nfunction useMenuContext(component) {\n  let context = (0, import_react31.useContext)(MenuContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Menu /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useMenuContext);\n    throw err;\n  }\n  return context;\n}\nfunction stateReducer5(state2, action) {\n  return match(action.type, reducers5, state2, action);\n}\nvar DEFAULT_MENU_TAG = import_react31.Fragment;\nvar MenuRoot = forwardRefWithAs(function Menu(props, ref) {\n  let reducerBag = (0, import_react31.useReducer)(stateReducer5, {\n    menuState: 1 /* Closed */,\n    buttonRef: (0, import_react31.createRef)(),\n    itemsRef: (0, import_react31.createRef)(),\n    items: [],\n    searchQuery: \"\",\n    activeItemIndex: null,\n    activationTrigger: 1 /* Other */\n  });\n  let [{ menuState, itemsRef, buttonRef }, dispatch] = reducerBag;\n  let menuRef = useSyncRefs(ref);\n  useOutsideClick([buttonRef, itemsRef], (event, target) => {\n    var _a2;\n    dispatch({ type: 1 /* CloseMenu */ });\n    if (!isFocusableElement(target, 1 /* Loose */)) {\n      event.preventDefault();\n      (_a2 = buttonRef.current) == null ? void 0 : _a2.focus();\n    }\n  }, menuState === 0 /* Open */);\n  let slot = (0, import_react31.useMemo)(() => ({ open: menuState === 0 /* Open */ }), [menuState]);\n  let theirProps = props;\n  let ourProps = { ref: menuRef };\n  return /* @__PURE__ */ import_react31.default.createElement(MenuContext.Provider, {\n    value: reducerBag\n  }, /* @__PURE__ */ import_react31.default.createElement(OpenClosedProvider, {\n    value: match(menuState, {\n      [0 /* Open */]: 0 /* Open */,\n      [1 /* Closed */]: 1 /* Closed */\n    })\n  }, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_MENU_TAG,\n    name: \"Menu\"\n  })));\n});\nvar DEFAULT_BUTTON_TAG4 = \"button\";\nvar Button7 = forwardRefWithAs(function Button8(props, ref) {\n  var _a2;\n  let [state2, dispatch] = useMenuContext(\"Menu.Button\");\n  let buttonRef = useSyncRefs(state2.buttonRef, ref);\n  let id2 = `headlessui-menu-button-${useId()}`;\n  let d = useDisposables();\n  let handleKeyDown = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n      case \"Enter\" /* Enter */:\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        dispatch({ type: 0 /* OpenMenu */ });\n        d.nextFrame(() => dispatch({ type: 2 /* GoToItem */, focus: 0 /* First */ }));\n        break;\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        dispatch({ type: 0 /* OpenMenu */ });\n        d.nextFrame(() => dispatch({ type: 2 /* GoToItem */, focus: 3 /* Last */ }));\n        break;\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n        event.preventDefault();\n        break;\n    }\n  });\n  let handleClick = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    if (props.disabled)\n      return;\n    if (state2.menuState === 0 /* Open */) {\n      dispatch({ type: 1 /* CloseMenu */ });\n      d.nextFrame(() => {\n        var _a3;\n        return (_a3 = state2.buttonRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n      });\n    } else {\n      event.preventDefault();\n      dispatch({ type: 0 /* OpenMenu */ });\n    }\n  });\n  let slot = (0, import_react31.useMemo)(() => ({ open: state2.menuState === 0 /* Open */ }), [state2]);\n  let theirProps = props;\n  let ourProps = {\n    ref: buttonRef,\n    id: id2,\n    type: useResolveButtonType(props, state2.buttonRef),\n    \"aria-haspopup\": true,\n    \"aria-controls\": (_a2 = state2.itemsRef.current) == null ? void 0 : _a2.id,\n    \"aria-expanded\": props.disabled ? void 0 : state2.menuState === 0 /* Open */,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onClick: handleClick\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG4,\n    name: \"Menu.Button\"\n  });\n});\nvar DEFAULT_ITEMS_TAG = \"div\";\nvar ItemsRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nvar Items = forwardRefWithAs(function Items2(props, ref) {\n  var _a2, _b;\n  let [state2, dispatch] = useMenuContext(\"Menu.Items\");\n  let itemsRef = useSyncRefs(state2.itemsRef, ref);\n  let ownerDocument = useOwnerDocument(state2.itemsRef);\n  let id2 = `headlessui-menu-items-${useId()}`;\n  let searchDisposables = useDisposables();\n  let usesOpenClosedState = useOpenClosed();\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === 0 /* Open */;\n    }\n    return state2.menuState === 0 /* Open */;\n  })();\n  (0, import_react31.useEffect)(() => {\n    let container = state2.itemsRef.current;\n    if (!container)\n      return;\n    if (state2.menuState !== 0 /* Open */)\n      return;\n    if (container === (ownerDocument == null ? void 0 : ownerDocument.activeElement))\n      return;\n    container.focus({ preventScroll: true });\n  }, [state2.menuState, state2.itemsRef, ownerDocument]);\n  useTreeWalker({\n    container: state2.itemsRef.current,\n    enabled: state2.menuState === 0 /* Open */,\n    accept(node) {\n      if (node.getAttribute(\"role\") === \"menuitem\")\n        return NodeFilter.FILTER_REJECT;\n      if (node.hasAttribute(\"role\"))\n        return NodeFilter.FILTER_SKIP;\n      return NodeFilter.FILTER_ACCEPT;\n    },\n    walk(node) {\n      node.setAttribute(\"role\", \"none\");\n    }\n  });\n  let handleKeyDown = useEvent((event) => {\n    var _a3, _b2;\n    searchDisposables.dispose();\n    switch (event.key) {\n      case \" \" /* Space */:\n        if (state2.searchQuery !== \"\") {\n          event.preventDefault();\n          event.stopPropagation();\n          return dispatch({ type: 3 /* Search */, value: event.key });\n        }\n      case \"Enter\" /* Enter */:\n        event.preventDefault();\n        event.stopPropagation();\n        dispatch({ type: 1 /* CloseMenu */ });\n        if (state2.activeItemIndex !== null) {\n          let { dataRef } = state2.items[state2.activeItemIndex];\n          (_b2 = (_a3 = dataRef.current) == null ? void 0 : _a3.domRef.current) == null ? void 0 : _b2.click();\n        }\n        restoreFocusIfNecessary(state2.buttonRef.current);\n        break;\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return dispatch({ type: 2 /* GoToItem */, focus: 2 /* Next */ });\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return dispatch({ type: 2 /* GoToItem */, focus: 1 /* Previous */ });\n      case \"Home\" /* Home */:\n      case \"PageUp\" /* PageUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return dispatch({ type: 2 /* GoToItem */, focus: 0 /* First */ });\n      case \"End\" /* End */:\n      case \"PageDown\" /* PageDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return dispatch({ type: 2 /* GoToItem */, focus: 3 /* Last */ });\n      case \"Escape\" /* Escape */:\n        event.preventDefault();\n        event.stopPropagation();\n        dispatch({ type: 1 /* CloseMenu */ });\n        disposables().nextFrame(() => {\n          var _a4;\n          return (_a4 = state2.buttonRef.current) == null ? void 0 : _a4.focus({ preventScroll: true });\n        });\n        break;\n      case \"Tab\" /* Tab */:\n        event.preventDefault();\n        event.stopPropagation();\n        dispatch({ type: 1 /* CloseMenu */ });\n        disposables().nextFrame(() => {\n          focusFrom(state2.buttonRef.current, event.shiftKey ? 2 /* Previous */ : 4 /* Next */);\n        });\n        break;\n      default:\n        if (event.key.length === 1) {\n          dispatch({ type: 3 /* Search */, value: event.key });\n          searchDisposables.setTimeout(() => dispatch({ type: 4 /* ClearSearch */ }), 350);\n        }\n        break;\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n        event.preventDefault();\n        break;\n    }\n  });\n  let slot = (0, import_react31.useMemo)(() => ({ open: state2.menuState === 0 /* Open */ }), [state2]);\n  let theirProps = props;\n  let ourProps = {\n    \"aria-activedescendant\": state2.activeItemIndex === null ? void 0 : (_a2 = state2.items[state2.activeItemIndex]) == null ? void 0 : _a2.id,\n    \"aria-labelledby\": (_b = state2.buttonRef.current) == null ? void 0 : _b.id,\n    id: id2,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    role: \"menu\",\n    tabIndex: 0,\n    ref: itemsRef\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_ITEMS_TAG,\n    features: ItemsRenderFeatures,\n    visible,\n    name: \"Menu.Items\"\n  });\n});\nvar DEFAULT_ITEM_TAG = import_react31.Fragment;\nvar Item = forwardRefWithAs(function Item2(props, ref) {\n  let { disabled = false, ...theirProps } = props;\n  let [state2, dispatch] = useMenuContext(\"Menu.Item\");\n  let id2 = `headlessui-menu-item-${useId()}`;\n  let active = state2.activeItemIndex !== null ? state2.items[state2.activeItemIndex].id === id2 : false;\n  let internalItemRef = (0, import_react31.useRef)(null);\n  let itemRef = useSyncRefs(ref, internalItemRef);\n  useIsoMorphicEffect(() => {\n    if (state2.menuState !== 0 /* Open */)\n      return;\n    if (!active)\n      return;\n    if (state2.activationTrigger === 0 /* Pointer */)\n      return;\n    let d = disposables();\n    d.requestAnimationFrame(() => {\n      var _a2, _b;\n      (_b = (_a2 = internalItemRef.current) == null ? void 0 : _a2.scrollIntoView) == null ? void 0 : _b.call(_a2, { block: \"nearest\" });\n    });\n    return d.dispose;\n  }, [internalItemRef, active, state2.menuState, state2.activationTrigger, state2.activeItemIndex]);\n  let bag = (0, import_react31.useRef)({ disabled, domRef: internalItemRef });\n  useIsoMorphicEffect(() => {\n    bag.current.disabled = disabled;\n  }, [bag, disabled]);\n  useIsoMorphicEffect(() => {\n    var _a2, _b;\n    bag.current.textValue = (_b = (_a2 = internalItemRef.current) == null ? void 0 : _a2.textContent) == null ? void 0 : _b.toLowerCase();\n  }, [bag, internalItemRef]);\n  useIsoMorphicEffect(() => {\n    dispatch({ type: 5 /* RegisterItem */, id: id2, dataRef: bag });\n    return () => dispatch({ type: 6 /* UnregisterItem */, id: id2 });\n  }, [bag, id2]);\n  let handleClick = useEvent((event) => {\n    if (disabled)\n      return event.preventDefault();\n    dispatch({ type: 1 /* CloseMenu */ });\n    restoreFocusIfNecessary(state2.buttonRef.current);\n  });\n  let handleFocus = useEvent(() => {\n    if (disabled)\n      return dispatch({ type: 2 /* GoToItem */, focus: 5 /* Nothing */ });\n    dispatch({ type: 2 /* GoToItem */, focus: 4 /* Specific */, id: id2 });\n  });\n  let handleMove = useEvent(() => {\n    if (disabled)\n      return;\n    if (active)\n      return;\n    dispatch({\n      type: 2 /* GoToItem */,\n      focus: 4 /* Specific */,\n      id: id2,\n      trigger: 0 /* Pointer */\n    });\n  });\n  let handleLeave = useEvent(() => {\n    if (disabled)\n      return;\n    if (!active)\n      return;\n    dispatch({ type: 2 /* GoToItem */, focus: 5 /* Nothing */ });\n  });\n  let slot = (0, import_react31.useMemo)(() => ({ active, disabled }), [active, disabled]);\n  let ourProps = {\n    id: id2,\n    ref: itemRef,\n    role: \"menuitem\",\n    tabIndex: disabled === true ? void 0 : -1,\n    \"aria-disabled\": disabled === true ? true : void 0,\n    disabled: void 0,\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_ITEM_TAG,\n    name: \"Menu.Item\"\n  });\n});\nvar Menu2 = Object.assign(MenuRoot, { Button: Button7, Items, Item });\n\n// src/components/popover/popover.tsx\nvar import_react32 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar reducers6 = {\n  [0 /* TogglePopover */]: (state2) => ({\n    ...state2,\n    popoverState: match(state2.popoverState, {\n      [0 /* Open */]: 1 /* Closed */,\n      [1 /* Closed */]: 0 /* Open */\n    })\n  }),\n  [1 /* ClosePopover */](state2) {\n    if (state2.popoverState === 1 /* Closed */)\n      return state2;\n    return { ...state2, popoverState: 1 /* Closed */ };\n  },\n  [2 /* SetButton */](state2, action) {\n    if (state2.button === action.button)\n      return state2;\n    return { ...state2, button: action.button };\n  },\n  [3 /* SetButtonId */](state2, action) {\n    if (state2.buttonId === action.buttonId)\n      return state2;\n    return { ...state2, buttonId: action.buttonId };\n  },\n  [4 /* SetPanel */](state2, action) {\n    if (state2.panel === action.panel)\n      return state2;\n    return { ...state2, panel: action.panel };\n  },\n  [5 /* SetPanelId */](state2, action) {\n    if (state2.panelId === action.panelId)\n      return state2;\n    return { ...state2, panelId: action.panelId };\n  }\n};\nvar PopoverContext = (0, import_react32.createContext)(null);\nPopoverContext.displayName = \"PopoverContext\";\nfunction usePopoverContext(component) {\n  let context = (0, import_react32.useContext)(PopoverContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Popover /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, usePopoverContext);\n    throw err;\n  }\n  return context;\n}\nvar PopoverAPIContext = (0, import_react32.createContext)(null);\nPopoverAPIContext.displayName = \"PopoverAPIContext\";\nfunction usePopoverAPIContext(component) {\n  let context = (0, import_react32.useContext)(PopoverAPIContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Popover /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, usePopoverAPIContext);\n    throw err;\n  }\n  return context;\n}\nvar PopoverGroupContext = (0, import_react32.createContext)(null);\nPopoverGroupContext.displayName = \"PopoverGroupContext\";\nfunction usePopoverGroupContext() {\n  return (0, import_react32.useContext)(PopoverGroupContext);\n}\nvar PopoverPanelContext = (0, import_react32.createContext)(null);\nPopoverPanelContext.displayName = \"PopoverPanelContext\";\nfunction usePopoverPanelContext() {\n  return (0, import_react32.useContext)(PopoverPanelContext);\n}\nfunction stateReducer6(state2, action) {\n  return match(action.type, reducers6, state2, action);\n}\nvar DEFAULT_POPOVER_TAG = \"div\";\nvar PopoverRoot = forwardRefWithAs(function Popover(props, ref) {\n  var _a2;\n  let buttonId = `headlessui-popover-button-${useId()}`;\n  let panelId = `headlessui-popover-panel-${useId()}`;\n  let internalPopoverRef = (0, import_react32.useRef)(null);\n  let popoverRef = useSyncRefs(ref, optionalRef((ref2) => {\n    internalPopoverRef.current = ref2;\n  }));\n  let reducerBag = (0, import_react32.useReducer)(stateReducer6, {\n    popoverState: 1 /* Closed */,\n    button: null,\n    buttonId,\n    panel: null,\n    panelId,\n    beforePanelSentinel: (0, import_react32.createRef)(),\n    afterPanelSentinel: (0, import_react32.createRef)()\n  });\n  let [{ popoverState, button, panel, beforePanelSentinel, afterPanelSentinel }, dispatch] = reducerBag;\n  let ownerDocument = useOwnerDocument((_a2 = internalPopoverRef.current) != null ? _a2 : button);\n  (0, import_react32.useEffect)(() => dispatch({ type: 3 /* SetButtonId */, buttonId }), [buttonId, dispatch]);\n  (0, import_react32.useEffect)(() => dispatch({ type: 5 /* SetPanelId */, panelId }), [panelId, dispatch]);\n  let isPortalled = (0, import_react32.useMemo)(() => {\n    if (!button)\n      return false;\n    if (!panel)\n      return false;\n    for (let root of document.querySelectorAll(\"body > *\")) {\n      if (Number(root == null ? void 0 : root.contains(button)) ^ Number(root == null ? void 0 : root.contains(panel))) {\n        return true;\n      }\n    }\n    return false;\n  }, [button, panel]);\n  let registerBag = (0, import_react32.useMemo)(() => ({ buttonId, panelId, close: () => dispatch({ type: 1 /* ClosePopover */ }) }), [buttonId, panelId, dispatch]);\n  let groupContext = usePopoverGroupContext();\n  let registerPopover = groupContext == null ? void 0 : groupContext.registerPopover;\n  let isFocusWithinPopoverGroup = useEvent(() => {\n    var _a3;\n    return (_a3 = groupContext == null ? void 0 : groupContext.isFocusWithinPopoverGroup()) != null ? _a3 : (ownerDocument == null ? void 0 : ownerDocument.activeElement) && ((button == null ? void 0 : button.contains(ownerDocument.activeElement)) || (panel == null ? void 0 : panel.contains(ownerDocument.activeElement)));\n  });\n  (0, import_react32.useEffect)(() => registerPopover == null ? void 0 : registerPopover(registerBag), [registerPopover, registerBag]);\n  useEventListener(ownerDocument == null ? void 0 : ownerDocument.defaultView, \"focus\", (event) => {\n    var _a3, _b, _c, _d;\n    if (popoverState !== 0 /* Open */)\n      return;\n    if (isFocusWithinPopoverGroup())\n      return;\n    if (!button)\n      return;\n    if (!panel)\n      return;\n    if ((_b = (_a3 = beforePanelSentinel.current) == null ? void 0 : _a3.contains) == null ? void 0 : _b.call(_a3, event.target))\n      return;\n    if ((_d = (_c = afterPanelSentinel.current) == null ? void 0 : _c.contains) == null ? void 0 : _d.call(_c, event.target))\n      return;\n    dispatch({ type: 1 /* ClosePopover */ });\n  }, true);\n  useOutsideClick([button, panel], (event, target) => {\n    dispatch({ type: 1 /* ClosePopover */ });\n    if (!isFocusableElement(target, 1 /* Loose */)) {\n      event.preventDefault();\n      button == null ? void 0 : button.focus();\n    }\n  }, popoverState === 0 /* Open */);\n  let close = useEvent((focusableElement) => {\n    dispatch({ type: 1 /* ClosePopover */ });\n    let restoreElement = (() => {\n      if (!focusableElement)\n        return button;\n      if (focusableElement instanceof HTMLElement)\n        return focusableElement;\n      if (\"current\" in focusableElement && focusableElement.current instanceof HTMLElement)\n        return focusableElement.current;\n      return button;\n    })();\n    restoreElement == null ? void 0 : restoreElement.focus();\n  });\n  let api = (0, import_react32.useMemo)(() => ({ close, isPortalled }), [close, isPortalled]);\n  let slot = (0, import_react32.useMemo)(() => ({ open: popoverState === 0 /* Open */, close }), [popoverState, close]);\n  let theirProps = props;\n  let ourProps = { ref: popoverRef };\n  return /* @__PURE__ */ import_react32.default.createElement(PopoverContext.Provider, {\n    value: reducerBag\n  }, /* @__PURE__ */ import_react32.default.createElement(PopoverAPIContext.Provider, {\n    value: api\n  }, /* @__PURE__ */ import_react32.default.createElement(OpenClosedProvider, {\n    value: match(popoverState, {\n      [0 /* Open */]: 0 /* Open */,\n      [1 /* Closed */]: 1 /* Closed */\n    })\n  }, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_POPOVER_TAG,\n    name: \"Popover\"\n  }))));\n});\nvar DEFAULT_BUTTON_TAG5 = \"button\";\nvar Button9 = forwardRefWithAs(function Button10(props, ref) {\n  let [state2, dispatch] = usePopoverContext(\"Popover.Button\");\n  let { isPortalled } = usePopoverAPIContext(\"Popover.Button\");\n  let internalButtonRef = (0, import_react32.useRef)(null);\n  let sentinelId = `headlessui-focus-sentinel-${useId()}`;\n  let groupContext = usePopoverGroupContext();\n  let closeOthers = groupContext == null ? void 0 : groupContext.closeOthers;\n  let panelContext = usePopoverPanelContext();\n  let isWithinPanel = panelContext === null ? false : panelContext === state2.panelId;\n  let buttonRef = useSyncRefs(internalButtonRef, ref, isWithinPanel ? null : (button) => dispatch({ type: 2 /* SetButton */, button }));\n  let withinPanelButtonRef = useSyncRefs(internalButtonRef, ref);\n  let ownerDocument = useOwnerDocument(internalButtonRef);\n  let handleKeyDown = useEvent((event) => {\n    var _a2, _b, _c;\n    if (isWithinPanel) {\n      if (state2.popoverState === 1 /* Closed */)\n        return;\n      switch (event.key) {\n        case \" \" /* Space */:\n        case \"Enter\" /* Enter */:\n          event.preventDefault();\n          (_b = (_a2 = event.target).click) == null ? void 0 : _b.call(_a2);\n          dispatch({ type: 1 /* ClosePopover */ });\n          (_c = state2.button) == null ? void 0 : _c.focus();\n          break;\n      }\n    } else {\n      switch (event.key) {\n        case \" \" /* Space */:\n        case \"Enter\" /* Enter */:\n          event.preventDefault();\n          event.stopPropagation();\n          if (state2.popoverState === 1 /* Closed */)\n            closeOthers == null ? void 0 : closeOthers(state2.buttonId);\n          dispatch({ type: 0 /* TogglePopover */ });\n          break;\n        case \"Escape\" /* Escape */:\n          if (state2.popoverState !== 0 /* Open */)\n            return closeOthers == null ? void 0 : closeOthers(state2.buttonId);\n          if (!internalButtonRef.current)\n            return;\n          if ((ownerDocument == null ? void 0 : ownerDocument.activeElement) && !internalButtonRef.current.contains(ownerDocument.activeElement)) {\n            return;\n          }\n          event.preventDefault();\n          event.stopPropagation();\n          dispatch({ type: 1 /* ClosePopover */ });\n          break;\n      }\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    if (isWithinPanel)\n      return;\n    if (event.key === \" \" /* Space */) {\n      event.preventDefault();\n    }\n  });\n  let handleClick = useEvent((event) => {\n    var _a2, _b;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return;\n    if (props.disabled)\n      return;\n    if (isWithinPanel) {\n      dispatch({ type: 1 /* ClosePopover */ });\n      (_a2 = state2.button) == null ? void 0 : _a2.focus();\n    } else {\n      event.preventDefault();\n      event.stopPropagation();\n      if (state2.popoverState === 1 /* Closed */)\n        closeOthers == null ? void 0 : closeOthers(state2.buttonId);\n      dispatch({ type: 0 /* TogglePopover */ });\n      (_b = state2.button) == null ? void 0 : _b.focus();\n    }\n  });\n  let handleMouseDown = useEvent((event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  });\n  let visible = state2.popoverState === 0 /* Open */;\n  let slot = (0, import_react32.useMemo)(() => ({ open: visible }), [visible]);\n  let type = useResolveButtonType(props, internalButtonRef);\n  let theirProps = props;\n  let ourProps = isWithinPanel ? {\n    ref: withinPanelButtonRef,\n    type,\n    onKeyDown: handleKeyDown,\n    onClick: handleClick\n  } : {\n    ref: buttonRef,\n    id: state2.buttonId,\n    type,\n    \"aria-expanded\": props.disabled ? void 0 : state2.popoverState === 0 /* Open */,\n    \"aria-controls\": state2.panel ? state2.panelId : void 0,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onClick: handleClick,\n    onMouseDown: handleMouseDown\n  };\n  let direction = useTabDirection();\n  let handleFocus = useEvent(() => {\n    let el = state2.panel;\n    if (!el)\n      return;\n    function run() {\n      match(direction.current, {\n        [0 /* Forwards */]: () => focusIn(el, 1 /* First */),\n        [1 /* Backwards */]: () => focusIn(el, 8 /* Last */)\n      });\n    }\n    if (false) {} else {\n      run();\n    }\n  });\n  return /* @__PURE__ */ import_react32.default.createElement(import_react32.default.Fragment, null, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG5,\n    name: \"Popover.Button\"\n  }), visible && !isWithinPanel && isPortalled && /* @__PURE__ */ import_react32.default.createElement(Hidden, {\n    id: sentinelId,\n    features: 2 /* Focusable */,\n    as: \"button\",\n    type: \"button\",\n    onFocus: handleFocus\n  }));\n});\nvar DEFAULT_OVERLAY_TAG2 = \"div\";\nvar OverlayRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nvar Overlay3 = forwardRefWithAs(function Overlay4(props, ref) {\n  let [{ popoverState }, dispatch] = usePopoverContext(\"Popover.Overlay\");\n  let overlayRef = useSyncRefs(ref);\n  let id2 = `headlessui-popover-overlay-${useId()}`;\n  let usesOpenClosedState = useOpenClosed();\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === 0 /* Open */;\n    }\n    return popoverState === 0 /* Open */;\n  })();\n  let handleClick = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    dispatch({ type: 1 /* ClosePopover */ });\n  });\n  let slot = (0, import_react32.useMemo)(() => ({ open: popoverState === 0 /* Open */ }), [popoverState]);\n  let theirProps = props;\n  let ourProps = {\n    ref: overlayRef,\n    id: id2,\n    \"aria-hidden\": true,\n    onClick: handleClick\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OVERLAY_TAG2,\n    features: OverlayRenderFeatures,\n    visible,\n    name: \"Popover.Overlay\"\n  });\n});\nvar DEFAULT_PANEL_TAG3 = \"div\";\nvar PanelRenderFeatures2 = 1 /* RenderStrategy */ | 2 /* Static */;\nvar Panel5 = forwardRefWithAs(function Panel6(props, ref) {\n  let { focus = false, ...theirProps } = props;\n  let [state2, dispatch] = usePopoverContext(\"Popover.Panel\");\n  let { close, isPortalled } = usePopoverAPIContext(\"Popover.Panel\");\n  let beforePanelSentinelId = `headlessui-focus-sentinel-before-${useId()}`;\n  let afterPanelSentinelId = `headlessui-focus-sentinel-after-${useId()}`;\n  let internalPanelRef = (0, import_react32.useRef)(null);\n  let panelRef = useSyncRefs(internalPanelRef, ref, (panel) => {\n    dispatch({ type: 4 /* SetPanel */, panel });\n  });\n  let ownerDocument = useOwnerDocument(internalPanelRef);\n  let usesOpenClosedState = useOpenClosed();\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === 0 /* Open */;\n    }\n    return state2.popoverState === 0 /* Open */;\n  })();\n  let handleKeyDown = useEvent((event) => {\n    var _a2;\n    switch (event.key) {\n      case \"Escape\" /* Escape */:\n        if (state2.popoverState !== 0 /* Open */)\n          return;\n        if (!internalPanelRef.current)\n          return;\n        if ((ownerDocument == null ? void 0 : ownerDocument.activeElement) && !internalPanelRef.current.contains(ownerDocument.activeElement)) {\n          return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        dispatch({ type: 1 /* ClosePopover */ });\n        (_a2 = state2.button) == null ? void 0 : _a2.focus();\n        break;\n    }\n  });\n  (0, import_react32.useEffect)(() => {\n    var _a2;\n    if (props.static)\n      return;\n    if (state2.popoverState === 1 /* Closed */ && ((_a2 = props.unmount) != null ? _a2 : true)) {\n      dispatch({ type: 4 /* SetPanel */, panel: null });\n    }\n  }, [state2.popoverState, props.unmount, props.static, dispatch]);\n  (0, import_react32.useEffect)(() => {\n    if (!focus)\n      return;\n    if (state2.popoverState !== 0 /* Open */)\n      return;\n    if (!internalPanelRef.current)\n      return;\n    let activeElement = ownerDocument == null ? void 0 : ownerDocument.activeElement;\n    if (internalPanelRef.current.contains(activeElement))\n      return;\n    focusIn(internalPanelRef.current, 1 /* First */);\n  }, [focus, internalPanelRef, state2.popoverState]);\n  let slot = (0, import_react32.useMemo)(() => ({ open: state2.popoverState === 0 /* Open */, close }), [state2, close]);\n  let ourProps = {\n    ref: panelRef,\n    id: state2.panelId,\n    onKeyDown: handleKeyDown,\n    onBlur: focus && state2.popoverState === 0 /* Open */ ? (event) => {\n      var _a2, _b, _c, _d, _e;\n      let el = event.relatedTarget;\n      if (!el)\n        return;\n      if (!internalPanelRef.current)\n        return;\n      if ((_a2 = internalPanelRef.current) == null ? void 0 : _a2.contains(el))\n        return;\n      dispatch({ type: 1 /* ClosePopover */ });\n      if (((_c = (_b = state2.beforePanelSentinel.current) == null ? void 0 : _b.contains) == null ? void 0 : _c.call(_b, el)) || ((_e = (_d = state2.afterPanelSentinel.current) == null ? void 0 : _d.contains) == null ? void 0 : _e.call(_d, el))) {\n        el.focus({ preventScroll: true });\n      }\n    } : void 0,\n    tabIndex: -1\n  };\n  let direction = useTabDirection();\n  let handleBeforeFocus = useEvent(() => {\n    let el = internalPanelRef.current;\n    if (!el)\n      return;\n    function run() {\n      match(direction.current, {\n        [0 /* Forwards */]: () => {\n          focusIn(el, 1 /* First */);\n        },\n        [1 /* Backwards */]: () => {\n          var _a2;\n          (_a2 = state2.button) == null ? void 0 : _a2.focus({ preventScroll: true });\n        }\n      });\n    }\n    if (false) {} else {\n      run();\n    }\n  });\n  let handleAfterFocus = useEvent(() => {\n    let el = internalPanelRef.current;\n    if (!el)\n      return;\n    function run() {\n      match(direction.current, {\n        [0 /* Forwards */]: () => {\n          var _a2, _b, _c;\n          if (!state2.button)\n            return;\n          let elements = getFocusableElements();\n          let idx = elements.indexOf(state2.button);\n          let before = elements.slice(0, idx + 1);\n          let after = elements.slice(idx + 1);\n          let combined = [...after, ...before];\n          for (let element of combined.slice()) {\n            if (((_b = (_a2 = element == null ? void 0 : element.id) == null ? void 0 : _a2.startsWith) == null ? void 0 : _b.call(_a2, \"headlessui-focus-sentinel-\")) || ((_c = state2.panel) == null ? void 0 : _c.contains(element))) {\n              let idx2 = combined.indexOf(element);\n              if (idx2 !== -1)\n                combined.splice(idx2, 1);\n            }\n          }\n          focusIn(combined, 1 /* First */, false);\n        },\n        [1 /* Backwards */]: () => focusIn(el, 8 /* Last */)\n      });\n    }\n    if (false) {} else {\n      run();\n    }\n  });\n  return /* @__PURE__ */ import_react32.default.createElement(PopoverPanelContext.Provider, {\n    value: state2.panelId\n  }, visible && isPortalled && /* @__PURE__ */ import_react32.default.createElement(Hidden, {\n    id: beforePanelSentinelId,\n    ref: state2.beforePanelSentinel,\n    features: 2 /* Focusable */,\n    as: \"button\",\n    type: \"button\",\n    onFocus: handleBeforeFocus\n  }), render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG3,\n    features: PanelRenderFeatures2,\n    visible,\n    name: \"Popover.Panel\"\n  }), visible && isPortalled && /* @__PURE__ */ import_react32.default.createElement(Hidden, {\n    id: afterPanelSentinelId,\n    ref: state2.afterPanelSentinel,\n    features: 2 /* Focusable */,\n    as: \"button\",\n    type: \"button\",\n    onFocus: handleAfterFocus\n  }));\n});\nvar DEFAULT_GROUP_TAG2 = \"div\";\nvar Group3 = forwardRefWithAs(function Group4(props, ref) {\n  let internalGroupRef = (0, import_react32.useRef)(null);\n  let groupRef = useSyncRefs(internalGroupRef, ref);\n  let [popovers, setPopovers] = (0, import_react32.useState)([]);\n  let unregisterPopover = useEvent((registerbag) => {\n    setPopovers((existing) => {\n      let idx = existing.indexOf(registerbag);\n      if (idx !== -1) {\n        let clone = existing.slice();\n        clone.splice(idx, 1);\n        return clone;\n      }\n      return existing;\n    });\n  });\n  let registerPopover = useEvent((registerbag) => {\n    setPopovers((existing) => [...existing, registerbag]);\n    return () => unregisterPopover(registerbag);\n  });\n  let isFocusWithinPopoverGroup = useEvent(() => {\n    var _a2;\n    let ownerDocument = getOwnerDocument(internalGroupRef);\n    if (!ownerDocument)\n      return false;\n    let element = ownerDocument.activeElement;\n    if ((_a2 = internalGroupRef.current) == null ? void 0 : _a2.contains(element))\n      return true;\n    return popovers.some((bag) => {\n      var _a3, _b;\n      return ((_a3 = ownerDocument.getElementById(bag.buttonId)) == null ? void 0 : _a3.contains(element)) || ((_b = ownerDocument.getElementById(bag.panelId)) == null ? void 0 : _b.contains(element));\n    });\n  });\n  let closeOthers = useEvent((buttonId) => {\n    for (let popover of popovers) {\n      if (popover.buttonId !== buttonId)\n        popover.close();\n    }\n  });\n  let contextBag = (0, import_react32.useMemo)(() => ({\n    registerPopover,\n    unregisterPopover,\n    isFocusWithinPopoverGroup,\n    closeOthers\n  }), [registerPopover, unregisterPopover, isFocusWithinPopoverGroup, closeOthers]);\n  let slot = (0, import_react32.useMemo)(() => ({}), []);\n  let theirProps = props;\n  let ourProps = { ref: groupRef };\n  return /* @__PURE__ */ import_react32.default.createElement(PopoverGroupContext.Provider, {\n    value: contextBag\n  }, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_GROUP_TAG2,\n    name: \"Popover.Group\"\n  }));\n});\nvar Popover2 = Object.assign(PopoverRoot, { Button: Button9, Overlay: Overlay3, Panel: Panel5, Group: Group3 });\n\n// src/components/radio-group/radio-group.tsx\nvar import_react35 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\n\n// src/hooks/use-flags.ts\nvar import_react33 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction useFlags(initialFlags = 0) {\n  let [flags, setFlags] = (0, import_react33.useState)(initialFlags);\n  let addFlag = (0, import_react33.useCallback)((flag) => setFlags((flags2) => flags2 | flag), [flags]);\n  let hasFlag = (0, import_react33.useCallback)((flag) => Boolean(flags & flag), [flags]);\n  let removeFlag = (0, import_react33.useCallback)((flag) => setFlags((flags2) => flags2 & ~flag), [setFlags]);\n  let toggleFlag = (0, import_react33.useCallback)((flag) => setFlags((flags2) => flags2 ^ flag), [setFlags]);\n  return { addFlag, hasFlag, removeFlag, toggleFlag };\n}\n\n// src/components/label/label.tsx\nvar import_react34 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar LabelContext = (0, import_react34.createContext)(null);\nfunction useLabelContext() {\n  let context = (0, import_react34.useContext)(LabelContext);\n  if (context === null) {\n    let err = new Error(\"You used a <Label /> component, but it is not inside a relevant parent.\");\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useLabelContext);\n    throw err;\n  }\n  return context;\n}\nfunction useLabels() {\n  let [labelIds, setLabelIds] = (0, import_react34.useState)([]);\n  return [\n    labelIds.length > 0 ? labelIds.join(\" \") : void 0,\n    (0, import_react34.useMemo)(() => {\n      return function LabelProvider(props) {\n        let register = useEvent((value) => {\n          setLabelIds((existing) => [...existing, value]);\n          return () => setLabelIds((existing) => {\n            let clone = existing.slice();\n            let idx = clone.indexOf(value);\n            if (idx !== -1)\n              clone.splice(idx, 1);\n            return clone;\n          });\n        });\n        let contextBag = (0, import_react34.useMemo)(() => ({ register, slot: props.slot, name: props.name, props: props.props }), [register, props.slot, props.name, props.props]);\n        return /* @__PURE__ */ import_react34.default.createElement(LabelContext.Provider, {\n          value: contextBag\n        }, props.children);\n      };\n    }, [setLabelIds])\n  ];\n}\nvar DEFAULT_LABEL_TAG3 = \"label\";\nvar Label5 = forwardRefWithAs(function Label6(props, ref) {\n  let { passive = false, ...theirProps } = props;\n  let context = useLabelContext();\n  let id2 = `headlessui-label-${useId()}`;\n  let labelRef = useSyncRefs(ref);\n  useIsoMorphicEffect(() => context.register(id2), [id2, context.register]);\n  let ourProps = { ref: labelRef, ...context.props, id: id2 };\n  if (passive) {\n    if (\"onClick\" in ourProps) {\n      delete ourProps[\"onClick\"];\n    }\n    if (\"onClick\" in theirProps) {\n      delete theirProps[\"onClick\"];\n    }\n  }\n  return render({\n    ourProps,\n    theirProps,\n    slot: context.slot || {},\n    defaultTag: DEFAULT_LABEL_TAG3,\n    name: context.name || \"Label\"\n  });\n});\n\n// src/components/radio-group/radio-group.tsx\nvar reducers7 = {\n  [0 /* RegisterOption */](state2, action) {\n    let nextOptions = [\n      ...state2.options,\n      { id: action.id, element: action.element, propsRef: action.propsRef }\n    ];\n    return {\n      ...state2,\n      options: sortByDomNode(nextOptions, (option) => option.element.current)\n    };\n  },\n  [1 /* UnregisterOption */](state2, action) {\n    let options = state2.options.slice();\n    let idx = state2.options.findIndex((radio) => radio.id === action.id);\n    if (idx === -1)\n      return state2;\n    options.splice(idx, 1);\n    return { ...state2, options };\n  }\n};\nvar RadioGroupContext = (0, import_react35.createContext)(null);\nRadioGroupContext.displayName = \"RadioGroupContext\";\nfunction useRadioGroupContext(component) {\n  let context = (0, import_react35.useContext)(RadioGroupContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <RadioGroup /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useRadioGroupContext);\n    throw err;\n  }\n  return context;\n}\nfunction stateReducer7(state2, action) {\n  return match(action.type, reducers7, state2, action);\n}\nvar DEFAULT_RADIO_GROUP_TAG = \"div\";\nvar RadioGroupRoot = forwardRefWithAs(function RadioGroup(props, ref) {\n  let {\n    value: controlledValue,\n    defaultValue,\n    name,\n    onChange: controlledOnChange,\n    by = (a, z) => a === z,\n    disabled = false,\n    ...theirProps\n  } = props;\n  let compare = useEvent(typeof by === \"string\" ? (a, z) => {\n    let property = by;\n    return (a == null ? void 0 : a[property]) === (z == null ? void 0 : z[property]);\n  } : by);\n  let [state2, dispatch] = (0, import_react35.useReducer)(stateReducer7, { options: [] });\n  let options = state2.options;\n  let [labelledby, LabelProvider] = useLabels();\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let id2 = `headlessui-radiogroup-${useId()}`;\n  let internalRadioGroupRef = (0, import_react35.useRef)(null);\n  let radioGroupRef = useSyncRefs(internalRadioGroupRef, ref);\n  let [value, onChange] = useControllable(controlledValue, controlledOnChange, defaultValue);\n  let firstOption = (0, import_react35.useMemo)(() => options.find((option) => {\n    if (option.propsRef.current.disabled)\n      return false;\n    return true;\n  }), [options]);\n  let containsCheckedOption = (0, import_react35.useMemo)(() => options.some((option) => compare(option.propsRef.current.value, value)), [options, value]);\n  let triggerChange = useEvent((nextValue) => {\n    var _a2;\n    if (disabled)\n      return false;\n    if (compare(nextValue, value))\n      return false;\n    let nextOption = (_a2 = options.find((option) => compare(option.propsRef.current.value, nextValue))) == null ? void 0 : _a2.propsRef.current;\n    if (nextOption == null ? void 0 : nextOption.disabled)\n      return false;\n    onChange == null ? void 0 : onChange(nextValue);\n    return true;\n  });\n  useTreeWalker({\n    container: internalRadioGroupRef.current,\n    accept(node) {\n      if (node.getAttribute(\"role\") === \"radio\")\n        return NodeFilter.FILTER_REJECT;\n      if (node.hasAttribute(\"role\"))\n        return NodeFilter.FILTER_SKIP;\n      return NodeFilter.FILTER_ACCEPT;\n    },\n    walk(node) {\n      node.setAttribute(\"role\", \"none\");\n    }\n  });\n  let handleKeyDown = useEvent((event) => {\n    let container = internalRadioGroupRef.current;\n    if (!container)\n      return;\n    let ownerDocument = getOwnerDocument(container);\n    let all = options.filter((option) => option.propsRef.current.disabled === false).map((radio) => radio.element.current);\n    switch (event.key) {\n      case \"Enter\" /* Enter */:\n        attemptSubmit(event.currentTarget);\n        break;\n      case \"ArrowLeft\" /* ArrowLeft */:\n      case \"ArrowUp\" /* ArrowUp */:\n        {\n          event.preventDefault();\n          event.stopPropagation();\n          let result = focusIn(all, 2 /* Previous */ | 16 /* WrapAround */);\n          if (result === 2 /* Success */) {\n            let activeOption = options.find((option) => option.element.current === (ownerDocument == null ? void 0 : ownerDocument.activeElement));\n            if (activeOption)\n              triggerChange(activeOption.propsRef.current.value);\n          }\n        }\n        break;\n      case \"ArrowRight\" /* ArrowRight */:\n      case \"ArrowDown\" /* ArrowDown */:\n        {\n          event.preventDefault();\n          event.stopPropagation();\n          let result = focusIn(all, 4 /* Next */ | 16 /* WrapAround */);\n          if (result === 2 /* Success */) {\n            let activeOption = options.find((option) => option.element.current === (ownerDocument == null ? void 0 : ownerDocument.activeElement));\n            if (activeOption)\n              triggerChange(activeOption.propsRef.current.value);\n          }\n        }\n        break;\n      case \" \" /* Space */:\n        {\n          event.preventDefault();\n          event.stopPropagation();\n          let activeOption = options.find((option) => option.element.current === (ownerDocument == null ? void 0 : ownerDocument.activeElement));\n          if (activeOption)\n            triggerChange(activeOption.propsRef.current.value);\n        }\n        break;\n    }\n  });\n  let registerOption = useEvent((option) => {\n    dispatch({ type: 0 /* RegisterOption */, ...option });\n    return () => dispatch({ type: 1 /* UnregisterOption */, id: option.id });\n  });\n  let api = (0, import_react35.useMemo)(() => ({\n    registerOption,\n    firstOption,\n    containsCheckedOption,\n    change: triggerChange,\n    disabled,\n    value,\n    compare\n  }), [registerOption, firstOption, containsCheckedOption, triggerChange, disabled, value, compare]);\n  let ourProps = {\n    ref: radioGroupRef,\n    id: id2,\n    role: \"radiogroup\",\n    \"aria-labelledby\": labelledby,\n    \"aria-describedby\": describedby,\n    onKeyDown: handleKeyDown\n  };\n  let slot = (0, import_react35.useMemo)(() => ({ value }), [value]);\n  return /* @__PURE__ */ import_react35.default.createElement(DescriptionProvider, {\n    name: \"RadioGroup.Description\"\n  }, /* @__PURE__ */ import_react35.default.createElement(LabelProvider, {\n    name: \"RadioGroup.Label\"\n  }, /* @__PURE__ */ import_react35.default.createElement(RadioGroupContext.Provider, {\n    value: api\n  }, name != null && value != null && objectToFormEntries({ [name]: value }).map(([name2, value2]) => /* @__PURE__ */ import_react35.default.createElement(Hidden, {\n    features: 4 /* Hidden */,\n    ...compact({\n      key: name2,\n      as: \"input\",\n      type: \"radio\",\n      checked: value2 != null,\n      hidden: true,\n      readOnly: true,\n      name: name2,\n      value: value2\n    })\n  })), render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_RADIO_GROUP_TAG,\n    name: \"RadioGroup\"\n  }))));\n});\nvar DEFAULT_OPTION_TAG3 = \"div\";\nvar Option5 = forwardRefWithAs(function Option6(props, ref) {\n  let internalOptionRef = (0, import_react35.useRef)(null);\n  let optionRef = useSyncRefs(internalOptionRef, ref);\n  let id2 = `headlessui-radiogroup-option-${useId()}`;\n  let [labelledby, LabelProvider] = useLabels();\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let { addFlag, removeFlag, hasFlag } = useFlags(1 /* Empty */);\n  let { value, disabled = false, ...theirProps } = props;\n  let propsRef = (0, import_react35.useRef)({ value, disabled });\n  useIsoMorphicEffect(() => {\n    propsRef.current.value = value;\n  }, [value, propsRef]);\n  useIsoMorphicEffect(() => {\n    propsRef.current.disabled = disabled;\n  }, [disabled, propsRef]);\n  let {\n    registerOption,\n    disabled: radioGroupDisabled,\n    change,\n    firstOption,\n    containsCheckedOption,\n    value: radioGroupValue,\n    compare\n  } = useRadioGroupContext(\"RadioGroup.Option\");\n  useIsoMorphicEffect(() => registerOption({ id: id2, element: internalOptionRef, propsRef }), [id2, registerOption, internalOptionRef, props]);\n  let handleClick = useEvent((event) => {\n    var _a2;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    if (!change(value))\n      return;\n    addFlag(2 /* Active */);\n    (_a2 = internalOptionRef.current) == null ? void 0 : _a2.focus();\n  });\n  let handleFocus = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    addFlag(2 /* Active */);\n  });\n  let handleBlur = useEvent(() => removeFlag(2 /* Active */));\n  let isFirstOption = (firstOption == null ? void 0 : firstOption.id) === id2;\n  let isDisabled = radioGroupDisabled || disabled;\n  let checked = compare(radioGroupValue, value);\n  let ourProps = {\n    ref: optionRef,\n    id: id2,\n    role: \"radio\",\n    \"aria-checked\": checked ? \"true\" : \"false\",\n    \"aria-labelledby\": labelledby,\n    \"aria-describedby\": describedby,\n    \"aria-disabled\": isDisabled ? true : void 0,\n    tabIndex: (() => {\n      if (isDisabled)\n        return -1;\n      if (checked)\n        return 0;\n      if (!containsCheckedOption && isFirstOption)\n        return 0;\n      return -1;\n    })(),\n    onClick: isDisabled ? void 0 : handleClick,\n    onFocus: isDisabled ? void 0 : handleFocus,\n    onBlur: isDisabled ? void 0 : handleBlur\n  };\n  let slot = (0, import_react35.useMemo)(() => ({ checked, disabled: isDisabled, active: hasFlag(2 /* Active */) }), [checked, isDisabled, hasFlag]);\n  return /* @__PURE__ */ import_react35.default.createElement(DescriptionProvider, {\n    name: \"RadioGroup.Description\"\n  }, /* @__PURE__ */ import_react35.default.createElement(LabelProvider, {\n    name: \"RadioGroup.Label\"\n  }, render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG3,\n    name: \"RadioGroup.Option\"\n  })));\n});\nvar RadioGroup2 = Object.assign(RadioGroupRoot, { Option: Option5, Label: Label5, Description });\n\n// src/components/switch/switch.tsx\nvar import_react36 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nvar GroupContext = (0, import_react36.createContext)(null);\nGroupContext.displayName = \"GroupContext\";\nvar DEFAULT_GROUP_TAG3 = import_react36.Fragment;\nfunction Group5(props) {\n  let [switchElement, setSwitchElement] = (0, import_react36.useState)(null);\n  let [labelledby, LabelProvider] = useLabels();\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let context = (0, import_react36.useMemo)(() => ({ switch: switchElement, setSwitch: setSwitchElement, labelledby, describedby }), [switchElement, setSwitchElement, labelledby, describedby]);\n  let ourProps = {};\n  let theirProps = props;\n  return /* @__PURE__ */ import_react36.default.createElement(DescriptionProvider, {\n    name: \"Switch.Description\"\n  }, /* @__PURE__ */ import_react36.default.createElement(LabelProvider, {\n    name: \"Switch.Label\",\n    props: {\n      onClick() {\n        if (!switchElement)\n          return;\n        switchElement.click();\n        switchElement.focus({ preventScroll: true });\n      }\n    }\n  }, /* @__PURE__ */ import_react36.default.createElement(GroupContext.Provider, {\n    value: context\n  }, render({\n    ourProps,\n    theirProps,\n    defaultTag: DEFAULT_GROUP_TAG3,\n    name: \"Switch.Group\"\n  }))));\n}\nvar DEFAULT_SWITCH_TAG = \"button\";\nvar SwitchRoot = forwardRefWithAs(function Switch(props, ref) {\n  let {\n    checked: controlledChecked,\n    defaultChecked = false,\n    onChange: controlledOnChange,\n    name,\n    value,\n    ...theirProps\n  } = props;\n  let id2 = `headlessui-switch-${useId()}`;\n  let groupContext = (0, import_react36.useContext)(GroupContext);\n  let internalSwitchRef = (0, import_react36.useRef)(null);\n  let switchRef = useSyncRefs(internalSwitchRef, ref, groupContext === null ? null : groupContext.setSwitch);\n  let [checked, onChange] = useControllable(controlledChecked, controlledOnChange, defaultChecked);\n  let toggle = useEvent(() => onChange == null ? void 0 : onChange(!checked));\n  let handleClick = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    event.preventDefault();\n    toggle();\n  });\n  let handleKeyUp = useEvent((event) => {\n    if (event.key === \" \" /* Space */) {\n      event.preventDefault();\n      toggle();\n    } else if (event.key === \"Enter\" /* Enter */) {\n      attemptSubmit(event.currentTarget);\n    }\n  });\n  let handleKeyPress = useEvent((event) => event.preventDefault());\n  let slot = (0, import_react36.useMemo)(() => ({ checked }), [checked]);\n  let ourProps = {\n    id: id2,\n    ref: switchRef,\n    role: \"switch\",\n    type: useResolveButtonType(props, internalSwitchRef),\n    tabIndex: 0,\n    \"aria-checked\": checked,\n    \"aria-labelledby\": groupContext == null ? void 0 : groupContext.labelledby,\n    \"aria-describedby\": groupContext == null ? void 0 : groupContext.describedby,\n    onClick: handleClick,\n    onKeyUp: handleKeyUp,\n    onKeyPress: handleKeyPress\n  };\n  return /* @__PURE__ */ import_react36.default.createElement(import_react36.default.Fragment, null, name != null && checked && /* @__PURE__ */ import_react36.default.createElement(Hidden, {\n    features: 4 /* Hidden */,\n    ...compact({\n      as: \"input\",\n      type: \"checkbox\",\n      hidden: true,\n      readOnly: true,\n      checked,\n      name,\n      value\n    })\n  }), render({ ourProps, theirProps, slot, defaultTag: DEFAULT_SWITCH_TAG, name: \"Switch\" }));\n});\nvar Switch2 = Object.assign(SwitchRoot, { Group: Group5, Label: Label5, Description });\n\n// src/components/tabs/tabs.tsx\nvar import_react38 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\n\n// src/internal/focus-sentinel.tsx\nvar import_react37 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\nfunction FocusSentinel({ onFocus }) {\n  let [enabled, setEnabled] = (0, import_react37.useState)(true);\n  if (!enabled)\n    return null;\n  return /* @__PURE__ */ import_react37.default.createElement(Hidden, {\n    as: \"button\",\n    type: \"button\",\n    features: 2 /* Focusable */,\n    onFocus: (event) => {\n      event.preventDefault();\n      let frame;\n      let tries = 50;\n      function forwardFocus() {\n        if (tries-- <= 0) {\n          if (frame)\n            cancelAnimationFrame(frame);\n          return;\n        }\n        if (onFocus()) {\n          setEnabled(false);\n          cancelAnimationFrame(frame);\n          return;\n        }\n        frame = requestAnimationFrame(forwardFocus);\n      }\n      frame = requestAnimationFrame(forwardFocus);\n    }\n  });\n}\n\n// src/components/tabs/tabs.tsx\nvar reducers8 = {\n  [0 /* SetSelectedIndex */](state2, action) {\n    let focusableTabs = state2.tabs.filter((tab) => {\n      var _a2;\n      return !((_a2 = tab.current) == null ? void 0 : _a2.hasAttribute(\"disabled\"));\n    });\n    if (action.index < 0) {\n      return { ...state2, selectedIndex: state2.tabs.indexOf(focusableTabs[0]) };\n    } else if (action.index > state2.tabs.length) {\n      return {\n        ...state2,\n        selectedIndex: state2.tabs.indexOf(focusableTabs[focusableTabs.length - 1])\n      };\n    }\n    let before = state2.tabs.slice(0, action.index);\n    let after = state2.tabs.slice(action.index);\n    let next = [...after, ...before].find((tab) => focusableTabs.includes(tab));\n    if (!next)\n      return state2;\n    return { ...state2, selectedIndex: state2.tabs.indexOf(next) };\n  },\n  [1 /* RegisterTab */](state2, action) {\n    var _a2;\n    if (state2.tabs.includes(action.tab))\n      return state2;\n    let activeTab = state2.tabs[state2.selectedIndex];\n    let adjustedTabs = sortByDomNode([...state2.tabs, action.tab], (tab) => tab.current);\n    let selectedIndex = (_a2 = adjustedTabs.indexOf(activeTab)) != null ? _a2 : state2.selectedIndex;\n    if (selectedIndex === -1)\n      selectedIndex = state2.selectedIndex;\n    return { ...state2, tabs: adjustedTabs, selectedIndex };\n  },\n  [2 /* UnregisterTab */](state2, action) {\n    return { ...state2, tabs: state2.tabs.filter((tab) => tab !== action.tab) };\n  },\n  [3 /* RegisterPanel */](state2, action) {\n    if (state2.panels.includes(action.panel))\n      return state2;\n    return {\n      ...state2,\n      panels: sortByDomNode([...state2.panels, action.panel], (panel) => panel.current)\n    };\n  },\n  [4 /* UnregisterPanel */](state2, action) {\n    return { ...state2, panels: state2.panels.filter((panel) => panel !== action.panel) };\n  }\n};\nvar TabsSSRContext = (0, import_react38.createContext)(null);\nTabsSSRContext.displayName = \"TabsSSRContext\";\nfunction useSSRTabsCounter(component) {\n  let context = (0, import_react38.useContext)(TabsSSRContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Tab.Group /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useSSRTabsCounter);\n    throw err;\n  }\n  return context;\n}\nvar TabsDataContext = (0, import_react38.createContext)(null);\nTabsDataContext.displayName = \"TabsDataContext\";\nfunction useData2(component) {\n  let context = (0, import_react38.useContext)(TabsDataContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Tab.Group /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useData2);\n    throw err;\n  }\n  return context;\n}\nvar TabsActionsContext = (0, import_react38.createContext)(null);\nTabsActionsContext.displayName = \"TabsActionsContext\";\nfunction useActions2(component) {\n  let context = (0, import_react38.useContext)(TabsActionsContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Tab.Group /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useActions2);\n    throw err;\n  }\n  return context;\n}\nfunction stateReducer8(state2, action) {\n  return match(action.type, reducers8, state2, action);\n}\nvar DEFAULT_TABS_TAG = import_react38.Fragment;\nvar Tabs = forwardRefWithAs(function Tabs2(props, ref) {\n  let {\n    defaultIndex = 0,\n    vertical = false,\n    manual = false,\n    onChange,\n    selectedIndex = null,\n    ...theirProps\n  } = props;\n  const orientation = vertical ? \"vertical\" : \"horizontal\";\n  const activation = manual ? \"manual\" : \"auto\";\n  let isControlled = selectedIndex !== null;\n  let tabsRef = useSyncRefs(ref);\n  let [state2, dispatch] = (0, import_react38.useReducer)(stateReducer8, {\n    selectedIndex: selectedIndex != null ? selectedIndex : defaultIndex,\n    tabs: [],\n    panels: []\n  });\n  let slot = (0, import_react38.useMemo)(() => ({ selectedIndex: state2.selectedIndex }), [state2.selectedIndex]);\n  let onChangeRef = useLatestValue(onChange || (() => {\n  }));\n  let stableTabsRef = useLatestValue(state2.tabs);\n  let tabsData = (0, import_react38.useMemo)(() => ({ orientation, activation, ...state2 }), [orientation, activation, state2]);\n  let realSelectedIndex = useLatestValue(isControlled ? props.selectedIndex : state2.selectedIndex);\n  let tabsActions = (0, import_react38.useMemo)(() => ({\n    registerTab(tab) {\n      dispatch({ type: 1 /* RegisterTab */, tab });\n      return () => dispatch({ type: 2 /* UnregisterTab */, tab });\n    },\n    registerPanel(panel) {\n      dispatch({ type: 3 /* RegisterPanel */, panel });\n      return () => dispatch({ type: 4 /* UnregisterPanel */, panel });\n    },\n    change(index) {\n      if (realSelectedIndex.current !== index) {\n        onChangeRef.current(index);\n      }\n      if (!isControlled) {\n        dispatch({ type: 0 /* SetSelectedIndex */, index });\n      }\n    }\n  }), [dispatch, isControlled]);\n  useIsoMorphicEffect(() => {\n    dispatch({ type: 0 /* SetSelectedIndex */, index: selectedIndex != null ? selectedIndex : defaultIndex });\n  }, [selectedIndex]);\n  let SSRCounter = (0, import_react38.useRef)({ tabs: [], panels: [] });\n  let ourProps = { ref: tabsRef };\n  return /* @__PURE__ */ import_react38.default.createElement(TabsSSRContext.Provider, {\n    value: SSRCounter\n  }, /* @__PURE__ */ import_react38.default.createElement(TabsActionsContext.Provider, {\n    value: tabsActions\n  }, /* @__PURE__ */ import_react38.default.createElement(TabsDataContext.Provider, {\n    value: tabsData\n  }, tabsData.tabs.length <= 0 && /* @__PURE__ */ import_react38.default.createElement(FocusSentinel, {\n    onFocus: () => {\n      var _a2, _b;\n      for (let tab of stableTabsRef.current) {\n        if (((_a2 = tab.current) == null ? void 0 : _a2.tabIndex) === 0) {\n          (_b = tab.current) == null ? void 0 : _b.focus();\n          return true;\n        }\n      }\n      return false;\n    }\n  }), render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TABS_TAG,\n    name: \"Tabs\"\n  }))));\n});\nvar DEFAULT_LIST_TAG = \"div\";\nvar List = forwardRefWithAs(function List2(props, ref) {\n  let { orientation, selectedIndex } = useData2(\"Tab.List\");\n  let listRef = useSyncRefs(ref);\n  let slot = { selectedIndex };\n  let theirProps = props;\n  let ourProps = {\n    ref: listRef,\n    role: \"tablist\",\n    \"aria-orientation\": orientation\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_LIST_TAG,\n    name: \"Tabs.List\"\n  });\n});\nvar DEFAULT_TAB_TAG = \"button\";\nvar TabRoot = forwardRefWithAs(function Tab(props, ref) {\n  var _a2, _b;\n  let id2 = `headlessui-tabs-tab-${useId()}`;\n  let { orientation, activation, selectedIndex, tabs, panels } = useData2(\"Tab\");\n  let actions = useActions2(\"Tab\");\n  let SSRContext = useSSRTabsCounter(\"Tab\");\n  let internalTabRef = (0, import_react38.useRef)(null);\n  let tabRef = useSyncRefs(internalTabRef, ref);\n  useIsoMorphicEffect(() => actions.registerTab(internalTabRef), [actions, internalTabRef]);\n  let mySSRIndex = SSRContext.current.tabs.indexOf(id2);\n  if (mySSRIndex === -1)\n    mySSRIndex = SSRContext.current.tabs.push(id2) - 1;\n  let myIndex = tabs.indexOf(internalTabRef);\n  if (myIndex === -1)\n    myIndex = mySSRIndex;\n  let selected = myIndex === selectedIndex;\n  let handleKeyDown = useEvent((event) => {\n    let list = tabs.map((tab) => tab.current).filter(Boolean);\n    if (event.key === \" \" /* Space */ || event.key === \"Enter\" /* Enter */) {\n      event.preventDefault();\n      event.stopPropagation();\n      actions.change(myIndex);\n      return;\n    }\n    switch (event.key) {\n      case \"Home\" /* Home */:\n      case \"PageUp\" /* PageUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return focusIn(list, 1 /* First */);\n      case \"End\" /* End */:\n      case \"PageDown\" /* PageDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return focusIn(list, 8 /* Last */);\n    }\n    if (match(orientation, {\n      vertical() {\n        if (event.key === \"ArrowUp\" /* ArrowUp */)\n          return focusIn(list, 2 /* Previous */ | 16 /* WrapAround */);\n        if (event.key === \"ArrowDown\" /* ArrowDown */)\n          return focusIn(list, 4 /* Next */ | 16 /* WrapAround */);\n        return;\n      },\n      horizontal() {\n        if (event.key === \"ArrowLeft\" /* ArrowLeft */)\n          return focusIn(list, 2 /* Previous */ | 16 /* WrapAround */);\n        if (event.key === \"ArrowRight\" /* ArrowRight */)\n          return focusIn(list, 4 /* Next */ | 16 /* WrapAround */);\n        return;\n      }\n    })) {\n      return event.preventDefault();\n    }\n  });\n  let handleFocus = useEvent(() => {\n    var _a3;\n    (_a3 = internalTabRef.current) == null ? void 0 : _a3.focus();\n  });\n  let ready = (0, import_react38.useRef)(false);\n  let handleSelection = useEvent(() => {\n    var _a3;\n    if (ready.current)\n      return;\n    ready.current = true;\n    (_a3 = internalTabRef.current) == null ? void 0 : _a3.focus();\n    actions.change(myIndex);\n    microTask(() => {\n      ready.current = false;\n    });\n  });\n  let handleMouseDown = useEvent((event) => {\n    event.preventDefault();\n  });\n  let slot = (0, import_react38.useMemo)(() => ({ selected }), [selected]);\n  let theirProps = props;\n  let ourProps = {\n    ref: tabRef,\n    onKeyDown: handleKeyDown,\n    onFocus: activation === \"manual\" ? handleFocus : handleSelection,\n    onMouseDown: handleMouseDown,\n    onClick: handleSelection,\n    id: id2,\n    role: \"tab\",\n    type: useResolveButtonType(props, internalTabRef),\n    \"aria-controls\": (_b = (_a2 = panels[myIndex]) == null ? void 0 : _a2.current) == null ? void 0 : _b.id,\n    \"aria-selected\": selected,\n    tabIndex: selected ? 0 : -1\n  };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TAB_TAG,\n    name: \"Tabs.Tab\"\n  });\n});\nvar DEFAULT_PANELS_TAG = \"div\";\nvar Panels = forwardRefWithAs(function Panels2(props, ref) {\n  let { selectedIndex } = useData2(\"Tab.Panels\");\n  let panelsRef = useSyncRefs(ref);\n  let slot = (0, import_react38.useMemo)(() => ({ selectedIndex }), [selectedIndex]);\n  let theirProps = props;\n  let ourProps = { ref: panelsRef };\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANELS_TAG,\n    name: \"Tabs.Panels\"\n  });\n});\nvar DEFAULT_PANEL_TAG4 = \"div\";\nvar PanelRenderFeatures3 = 1 /* RenderStrategy */ | 2 /* Static */;\nvar Panel7 = forwardRefWithAs(function Panel8(props, ref) {\n  var _a2, _b, _c, _d;\n  let { selectedIndex, tabs, panels } = useData2(\"Tab.Panel\");\n  let actions = useActions2(\"Tab.Panel\");\n  let SSRContext = useSSRTabsCounter(\"Tab.Panel\");\n  let id2 = `headlessui-tabs-panel-${useId()}`;\n  let internalPanelRef = (0, import_react38.useRef)(null);\n  let panelRef = useSyncRefs(internalPanelRef, ref);\n  useIsoMorphicEffect(() => actions.registerPanel(internalPanelRef), [actions, internalPanelRef]);\n  let mySSRIndex = SSRContext.current.panels.indexOf(id2);\n  if (mySSRIndex === -1)\n    mySSRIndex = SSRContext.current.panels.push(id2) - 1;\n  let myIndex = panels.indexOf(internalPanelRef);\n  if (myIndex === -1)\n    myIndex = mySSRIndex;\n  let selected = myIndex === selectedIndex;\n  let slot = (0, import_react38.useMemo)(() => ({ selected }), [selected]);\n  let theirProps = props;\n  let ourProps = {\n    ref: panelRef,\n    id: id2,\n    role: \"tabpanel\",\n    \"aria-labelledby\": (_b = (_a2 = tabs[myIndex]) == null ? void 0 : _a2.current) == null ? void 0 : _b.id,\n    tabIndex: selected ? 0 : -1\n  };\n  if (!selected && ((_c = props.unmount) != null ? _c : true) && !((_d = props.static) != null ? _d : false)) {\n    return /* @__PURE__ */ import_react38.default.createElement(Hidden, {\n      as: \"span\",\n      ...ourProps\n    });\n  }\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG4,\n    features: PanelRenderFeatures3,\n    visible: selected,\n    name: \"Tabs.Panel\"\n  });\n});\nvar Tab2 = Object.assign(TabRoot, { Group: Tabs, List, Panels, Panel: Panel7 });\n\n// src/components/transitions/transition.tsx\nvar import_react39 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), 1);\n\n// src/utils/once.ts\nfunction once(cb) {\n  let state2 = { called: false };\n  return (...args) => {\n    if (state2.called)\n      return;\n    state2.called = true;\n    return cb(...args);\n  };\n}\n\n// src/components/transitions/utils/transition.ts\nfunction addClasses(node, ...classes) {\n  node && classes.length > 0 && node.classList.add(...classes);\n}\nfunction removeClasses(node, ...classes) {\n  node && classes.length > 0 && node.classList.remove(...classes);\n}\nfunction waitForTransition(node, done) {\n  let d = disposables();\n  if (!node)\n    return d.dispose;\n  let { transitionDuration, transitionDelay } = getComputedStyle(node);\n  let [durationMs, delayMs] = [transitionDuration, transitionDelay].map((value) => {\n    let [resolvedValue = 0] = value.split(\",\").filter(Boolean).map((v) => v.includes(\"ms\") ? parseFloat(v) : parseFloat(v) * 1e3).sort((a, z) => z - a);\n    return resolvedValue;\n  });\n  let totalDuration = durationMs + delayMs;\n  if (totalDuration !== 0) {\n    let listeners = [];\n    if (false) {} else {\n      listeners.push(d.addEventListener(node, \"transitionrun\", (event) => {\n        if (event.target !== event.currentTarget)\n          return;\n        listeners.splice(0).forEach((dispose) => dispose());\n        listeners.push(d.addEventListener(node, \"transitionend\", (event2) => {\n          if (event2.target !== event2.currentTarget)\n            return;\n          done(\"ended\" /* Ended */);\n          listeners.splice(0).forEach((dispose) => dispose());\n        }), d.addEventListener(node, \"transitioncancel\", (event2) => {\n          if (event2.target !== event2.currentTarget)\n            return;\n          done(\"cancelled\" /* Cancelled */);\n          listeners.splice(0).forEach((dispose) => dispose());\n        }));\n      }));\n    }\n  } else {\n    done(\"ended\" /* Ended */);\n  }\n  d.add(() => done(\"cancelled\" /* Cancelled */));\n  return d.dispose;\n}\nfunction transition(node, classes, show, done) {\n  let direction = show ? \"enter\" : \"leave\";\n  let d = disposables();\n  let _done = done !== void 0 ? once(done) : () => {\n  };\n  if (direction === \"enter\") {\n    node.removeAttribute(\"hidden\");\n    node.style.display = \"\";\n  }\n  let base = match(direction, {\n    enter: () => classes.enter,\n    leave: () => classes.leave\n  });\n  let to = match(direction, {\n    enter: () => classes.enterTo,\n    leave: () => classes.leaveTo\n  });\n  let from = match(direction, {\n    enter: () => classes.enterFrom,\n    leave: () => classes.leaveFrom\n  });\n  removeClasses(node, ...classes.enter, ...classes.enterTo, ...classes.enterFrom, ...classes.leave, ...classes.leaveFrom, ...classes.leaveTo, ...classes.entered);\n  addClasses(node, ...base, ...from);\n  d.nextFrame(() => {\n    removeClasses(node, ...from);\n    addClasses(node, ...to);\n    waitForTransition(node, (reason) => {\n      if (reason === \"ended\" /* Ended */) {\n        removeClasses(node, ...base);\n        addClasses(node, ...classes.entered);\n      }\n      return _done(reason);\n    });\n  });\n  return d.dispose;\n}\n\n// src/hooks/use-transition.ts\nfunction useTransition({ container, direction, classes, onStart, onStop }) {\n  let mounted = useIsMounted();\n  let d = useDisposables();\n  let latestDirection = useLatestValue(direction);\n  useIsoMorphicEffect(() => {\n    let dd = disposables();\n    d.add(dd.dispose);\n    let node = container.current;\n    if (!node)\n      return;\n    if (latestDirection.current === \"idle\")\n      return;\n    if (!mounted.current)\n      return;\n    dd.dispose();\n    onStart.current(latestDirection.current);\n    dd.add(transition(node, classes.current, latestDirection.current === \"enter\", (reason) => {\n      dd.dispose();\n      match(reason, {\n        [\"ended\" /* Ended */]() {\n          onStop.current(latestDirection.current);\n        },\n        [\"cancelled\" /* Cancelled */]: () => {\n        }\n      });\n    }));\n    return dd.dispose;\n  }, [direction]);\n}\n\n// src/components/transitions/transition.tsx\nfunction splitClasses(classes = \"\") {\n  return classes.split(\" \").filter((className) => className.trim().length > 1);\n}\nvar TransitionContext = (0, import_react39.createContext)(null);\nTransitionContext.displayName = \"TransitionContext\";\nfunction useTransitionContext() {\n  let context = (0, import_react39.useContext)(TransitionContext);\n  if (context === null) {\n    throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  }\n  return context;\n}\nfunction useParentNesting() {\n  let context = (0, import_react39.useContext)(NestingContext);\n  if (context === null) {\n    throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  }\n  return context;\n}\nvar NestingContext = (0, import_react39.createContext)(null);\nNestingContext.displayName = \"NestingContext\";\nfunction hasChildren(bag) {\n  if (\"children\" in bag)\n    return hasChildren(bag.children);\n  return bag.current.filter(({ el }) => el.current !== null).filter(({ state: state2 }) => state2 === \"visible\" /* Visible */).length > 0;\n}\nfunction useNesting(done, parent) {\n  let doneRef = useLatestValue(done);\n  let transitionableChildren = (0, import_react39.useRef)([]);\n  let mounted = useIsMounted();\n  let d = useDisposables();\n  let unregister = useEvent((container, strategy = 1 /* Hidden */) => {\n    let idx = transitionableChildren.current.findIndex(({ el }) => el === container);\n    if (idx === -1)\n      return;\n    match(strategy, {\n      [0 /* Unmount */]() {\n        transitionableChildren.current.splice(idx, 1);\n      },\n      [1 /* Hidden */]() {\n        transitionableChildren.current[idx].state = \"hidden\" /* Hidden */;\n      }\n    });\n    d.microTask(() => {\n      var _a2;\n      if (!hasChildren(transitionableChildren) && mounted.current) {\n        (_a2 = doneRef.current) == null ? void 0 : _a2.call(doneRef);\n      }\n    });\n  });\n  let register = useEvent((container) => {\n    let child = transitionableChildren.current.find(({ el }) => el === container);\n    if (!child) {\n      transitionableChildren.current.push({ el: container, state: \"visible\" /* Visible */ });\n    } else if (child.state !== \"visible\" /* Visible */) {\n      child.state = \"visible\" /* Visible */;\n    }\n    return () => unregister(container, 0 /* Unmount */);\n  });\n  let todos = (0, import_react39.useRef)([]);\n  let wait = (0, import_react39.useRef)(Promise.resolve());\n  let chains = (0, import_react39.useRef)({\n    enter: [],\n    leave: [],\n    idle: []\n  });\n  let onStart = useEvent((container, direction, cb) => {\n    todos.current.splice(0);\n    if (parent) {\n      parent.chains.current[direction] = parent.chains.current[direction].filter(([containerInParent]) => containerInParent !== container);\n    }\n    parent == null ? void 0 : parent.chains.current[direction].push([\n      container,\n      new Promise((resolve) => {\n        todos.current.push(resolve);\n      })\n    ]);\n    parent == null ? void 0 : parent.chains.current[direction].push([\n      container,\n      new Promise((resolve) => {\n        Promise.all(chains.current[direction].map(([_container, promise]) => promise)).then(() => resolve());\n      })\n    ]);\n    if (direction === \"enter\") {\n      wait.current = wait.current.then(() => parent == null ? void 0 : parent.wait.current).then(() => cb(direction));\n    } else {\n      cb(direction);\n    }\n  });\n  let onStop = useEvent((_container, direction, cb) => {\n    Promise.all(chains.current[direction].splice(0).map(([_container2, promise]) => promise)).then(() => {\n      var _a2;\n      (_a2 = todos.current.shift()) == null ? void 0 : _a2();\n    }).then(() => cb(direction));\n  });\n  return (0, import_react39.useMemo)(() => ({\n    children: transitionableChildren,\n    register,\n    unregister,\n    onStart,\n    onStop,\n    wait,\n    chains\n  }), [register, unregister, transitionableChildren, onStart, onStop, chains, wait]);\n}\nfunction noop() {\n}\nvar eventNames = [\"beforeEnter\", \"afterEnter\", \"beforeLeave\", \"afterLeave\"];\nfunction ensureEventHooksExist(events) {\n  var _a2;\n  let result = {};\n  for (let name of eventNames) {\n    result[name] = (_a2 = events[name]) != null ? _a2 : noop;\n  }\n  return result;\n}\nfunction useEvents(events) {\n  let eventsRef = (0, import_react39.useRef)(ensureEventHooksExist(events));\n  (0, import_react39.useEffect)(() => {\n    eventsRef.current = ensureEventHooksExist(events);\n  }, [events]);\n  return eventsRef;\n}\nvar DEFAULT_TRANSITION_CHILD_TAG = \"div\";\nvar TransitionChildRenderFeatures = 1 /* RenderStrategy */;\nvar TransitionChild = forwardRefWithAs(function TransitionChild2(props, ref) {\n  let {\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave,\n    enter,\n    enterFrom,\n    enterTo,\n    entered,\n    leave,\n    leaveFrom,\n    leaveTo,\n    ...rest\n  } = props;\n  let container = (0, import_react39.useRef)(null);\n  let transitionRef = useSyncRefs(container, ref);\n  let strategy = rest.unmount ? 0 /* Unmount */ : 1 /* Hidden */;\n  let { show, appear, initial } = useTransitionContext();\n  let [state2, setState] = (0, import_react39.useState)(show ? \"visible\" /* Visible */ : \"hidden\" /* Hidden */);\n  let parentNesting = useParentNesting();\n  let { register, unregister } = parentNesting;\n  let prevShow = (0, import_react39.useRef)(null);\n  (0, import_react39.useEffect)(() => register(container), [register, container]);\n  (0, import_react39.useEffect)(() => {\n    if (strategy !== 1 /* Hidden */)\n      return;\n    if (!container.current)\n      return;\n    if (show && state2 !== \"visible\" /* Visible */) {\n      setState(\"visible\" /* Visible */);\n      return;\n    }\n    return match(state2, {\n      [\"hidden\" /* Hidden */]: () => unregister(container),\n      [\"visible\" /* Visible */]: () => register(container)\n    });\n  }, [state2, container, register, unregister, show, strategy]);\n  let classes = useLatestValue({\n    enter: splitClasses(enter),\n    enterFrom: splitClasses(enterFrom),\n    enterTo: splitClasses(enterTo),\n    entered: splitClasses(entered),\n    leave: splitClasses(leave),\n    leaveFrom: splitClasses(leaveFrom),\n    leaveTo: splitClasses(leaveTo)\n  });\n  let events = useEvents({\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave\n  });\n  let ready = useServerHandoffComplete();\n  (0, import_react39.useEffect)(() => {\n    if (ready && state2 === \"visible\" /* Visible */ && container.current === null) {\n      throw new Error(\"Did you forget to passthrough the `ref` to the actual DOM node?\");\n    }\n  }, [container, state2, ready]);\n  let skip = initial && !appear;\n  let transitionDirection = (() => {\n    if (!ready)\n      return \"idle\";\n    if (skip)\n      return \"idle\";\n    if (prevShow.current === show)\n      return \"idle\";\n    return show ? \"enter\" : \"leave\";\n  })();\n  let beforeEvent = useEvent((direction) => {\n    return match(direction, {\n      enter: () => events.current.beforeEnter(),\n      leave: () => events.current.beforeLeave(),\n      idle: () => {\n      }\n    });\n  });\n  let afterEvent = useEvent((direction) => {\n    return match(direction, {\n      enter: () => events.current.afterEnter(),\n      leave: () => events.current.afterLeave(),\n      idle: () => {\n      }\n    });\n  });\n  let nesting = useNesting(() => {\n    setState(\"hidden\" /* Hidden */);\n    unregister(container);\n  }, parentNesting);\n  useTransition({\n    container,\n    classes,\n    direction: transitionDirection,\n    onStart: useLatestValue((direction) => {\n      nesting.onStart(container, direction, beforeEvent);\n    }),\n    onStop: useLatestValue((direction) => {\n      nesting.onStop(container, direction, afterEvent);\n      if (direction === \"leave\" && !hasChildren(nesting)) {\n        setState(\"hidden\" /* Hidden */);\n        unregister(container);\n      }\n    })\n  });\n  (0, import_react39.useEffect)(() => {\n    if (!skip)\n      return;\n    if (strategy === 1 /* Hidden */) {\n      prevShow.current = null;\n    } else {\n      prevShow.current = show;\n    }\n  }, [show, skip, state2]);\n  let theirProps = rest;\n  let ourProps = { ref: transitionRef };\n  return /* @__PURE__ */ import_react39.default.createElement(NestingContext.Provider, {\n    value: nesting\n  }, /* @__PURE__ */ import_react39.default.createElement(OpenClosedProvider, {\n    value: match(state2, {\n      [\"visible\" /* Visible */]: 0 /* Open */,\n      [\"hidden\" /* Hidden */]: 1 /* Closed */\n    })\n  }, render({\n    ourProps,\n    theirProps,\n    defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n    features: TransitionChildRenderFeatures,\n    visible: state2 === \"visible\" /* Visible */,\n    name: \"Transition.Child\"\n  })));\n});\nvar TransitionRoot = forwardRefWithAs(function Transition(props, ref) {\n  let { show, appear = false, unmount, ...theirProps } = props;\n  let internalTransitionRef = (0, import_react39.useRef)(null);\n  let transitionRef = useSyncRefs(internalTransitionRef, ref);\n  useServerHandoffComplete();\n  let usesOpenClosedState = useOpenClosed();\n  if (show === void 0 && usesOpenClosedState !== null) {\n    show = match(usesOpenClosedState, {\n      [0 /* Open */]: true,\n      [1 /* Closed */]: false\n    });\n  }\n  if (![true, false].includes(show)) {\n    throw new Error(\"A <Transition /> is used but it is missing a `show={true | false}` prop.\");\n  }\n  let [state2, setState] = (0, import_react39.useState)(show ? \"visible\" /* Visible */ : \"hidden\" /* Hidden */);\n  let nestingBag = useNesting(() => {\n    setState(\"hidden\" /* Hidden */);\n  });\n  let [initial, setInitial] = (0, import_react39.useState)(true);\n  let changes = (0, import_react39.useRef)([show]);\n  useIsoMorphicEffect(() => {\n    if (initial === false) {\n      return;\n    }\n    if (changes.current[changes.current.length - 1] !== show) {\n      changes.current.push(show);\n      setInitial(false);\n    }\n  }, [changes, show]);\n  let transitionBag = (0, import_react39.useMemo)(() => ({ show, appear, initial }), [show, appear, initial]);\n  (0, import_react39.useEffect)(() => {\n    if (show) {\n      setState(\"visible\" /* Visible */);\n    } else if (!hasChildren(nestingBag)) {\n      setState(\"hidden\" /* Hidden */);\n    } else if (true) {\n      let node = internalTransitionRef.current;\n      if (!node)\n        return;\n      let rect = node.getBoundingClientRect();\n      if (rect.x === 0 && rect.y === 0 && rect.width === 0 && rect.height === 0) {\n        setState(\"hidden\" /* Hidden */);\n      }\n    }\n  }, [show, nestingBag]);\n  let sharedProps = { unmount };\n  return /* @__PURE__ */ import_react39.default.createElement(NestingContext.Provider, {\n    value: nestingBag\n  }, /* @__PURE__ */ import_react39.default.createElement(TransitionContext.Provider, {\n    value: transitionBag\n  }, render({\n    ourProps: {\n      ...sharedProps,\n      as: import_react39.Fragment,\n      children: /* @__PURE__ */ import_react39.default.createElement(TransitionChild, {\n        ref: transitionRef,\n        ...sharedProps,\n        ...theirProps\n      })\n    },\n    theirProps: {},\n    defaultTag: import_react39.Fragment,\n    features: TransitionChildRenderFeatures,\n    visible: state2 === \"visible\" /* Visible */,\n    name: \"Transition\"\n  })));\n});\nvar Child = forwardRefWithAs(function Child2(props, ref) {\n  let hasTransitionContext = (0, import_react39.useContext)(TransitionContext) !== null;\n  let hasOpenClosedContext = useOpenClosed() !== null;\n  return /* @__PURE__ */ import_react39.default.createElement(import_react39.default.Fragment, null, !hasTransitionContext && hasOpenClosedContext ? /* @__PURE__ */ import_react39.default.createElement(TransitionRoot, {\n    ref,\n    ...props\n  }) : /* @__PURE__ */ import_react39.default.createElement(TransitionChild, {\n    ref,\n    ...props\n  }));\n});\nvar Transition2 = Object.assign(TransitionRoot, { Child, Root: TransitionRoot });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9oZWFkbGVzc3VpLmRldi5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHFGQUFxRiw4QkFBOEI7QUFDdE4sb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyx3R0FBTzs7QUFFNUM7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBTzs7QUFFbkM7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx3R0FBTzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0dBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHdHQUFPOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9B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Q0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxLQUFLLHFCQUFxQjtBQUMzQiwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsd0dBQU87QUFDNUMsdUJBQXVCLG1CQUFPLENBQUMsZ0hBQVc7O0FBRTFDO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsd0dBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEM7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLFFBQVEsK0NBQStDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJEQUEyRCx1QkFBdUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTSxTQUFTLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Qsa0RBQWtELDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2d1aWxoZXJtZWZyZWl0YXMuY29tLy4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvaGVhZGxlc3N1aS5kZXYuY2pzP2NiMDciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsIG1vZCkpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBDb21ib2JveDogKCkgPT4gQ29tYm9ib3gsXG4gIERpYWxvZzogKCkgPT4gRGlhbG9nMixcbiAgRGlzY2xvc3VyZTogKCkgPT4gRGlzY2xvc3VyZTIsXG4gIEZvY3VzVHJhcDogKCkgPT4gRm9jdXNUcmFwLFxuICBMaXN0Ym94OiAoKSA9PiBMaXN0Ym94MixcbiAgTWVudTogKCkgPT4gTWVudTIsXG4gIFBvcG92ZXI6ICgpID0+IFBvcG92ZXIyLFxuICBQb3J0YWw6ICgpID0+IFBvcnRhbDIsXG4gIFJhZGlvR3JvdXA6ICgpID0+IFJhZGlvR3JvdXAyLFxuICBTd2l0Y2g6ICgpID0+IFN3aXRjaDIsXG4gIFRhYjogKCkgPT4gVGFiMixcbiAgVHJhbnNpdGlvbjogKCkgPT4gVHJhbnNpdGlvbjJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvY29tcG9uZW50cy9jb21ib2JveC9jb21ib2JveC50c3hcbnZhciBpbXBvcnRfcmVhY3QxNyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcblxuLy8gc3JjL2hvb2tzL3VzZS1jb21wdXRlZC50c1xudmFyIGltcG9ydF9yZWFjdDMgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8vIHNyYy9ob29rcy91c2UtaXNvLW1vcnBoaWMtZWZmZWN0LnRzXG52YXIgaW1wb3J0X3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyBzcmMvdXRpbHMvc3NyLnRzXG52YXIgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIjtcblxuLy8gc3JjL2hvb2tzL3VzZS1pc28tbW9ycGhpYy1lZmZlY3QudHNcbnZhciB1c2VJc29Nb3JwaGljRWZmZWN0ID0gaXNTZXJ2ZXIgPyBpbXBvcnRfcmVhY3QudXNlRWZmZWN0IDogaW1wb3J0X3JlYWN0LnVzZUxheW91dEVmZmVjdDtcblxuLy8gc3JjL2hvb2tzL3VzZS1sYXRlc3QtdmFsdWUudHNcbnZhciBpbXBvcnRfcmVhY3QyID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlTGF0ZXN0VmFsdWUodmFsdWUpIHtcbiAgbGV0IGNhY2hlID0gKDAsIGltcG9ydF9yZWFjdDIudXNlUmVmKSh2YWx1ZSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIGNhY2hlLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBjYWNoZTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1jb21wdXRlZC50c1xuZnVuY3Rpb24gdXNlQ29tcHV0ZWQoY2IsIGRlcGVuZGVuY2llcykge1xuICBsZXQgW3ZhbHVlLCBzZXRWYWx1ZV0gPSAoMCwgaW1wb3J0X3JlYWN0My51c2VTdGF0ZSkoY2IpO1xuICBsZXQgY2JSZWYgPSB1c2VMYXRlc3RWYWx1ZShjYik7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4gc2V0VmFsdWUoY2JSZWYuY3VycmVudCksIFtjYlJlZiwgc2V0VmFsdWUsIC4uLmRlcGVuZGVuY2llc10pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9ob29rcy91c2UtZGlzcG9zYWJsZXMudHNcbnZhciBpbXBvcnRfcmVhY3Q0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyBzcmMvdXRpbHMvbWljcm8tdGFzay50c1xuZnVuY3Rpb24gbWljcm9UYXNrKGNiKSB7XG4gIGlmICh0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHF1ZXVlTWljcm90YXNrKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNiKS5jYXRjaCgoZSkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvZGlzcG9zYWJsZXMudHNcbmZ1bmN0aW9uIGRpc3Bvc2FibGVzKCkge1xuICBsZXQgZGlzcG9zYWJsZXMyID0gW107XG4gIGxldCBxdWV1ZSA9IFtdO1xuICBsZXQgYXBpID0ge1xuICAgIGVucXVldWUoZm4pIHtcbiAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgIH0sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBuYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBhcGkuYWRkKCgpID0+IGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykpO1xuICAgIH0sXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLmFyZ3MpIHtcbiAgICAgIGxldCByYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoLi4uYXJncyk7XG4gICAgICByZXR1cm4gYXBpLmFkZCgoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpKTtcbiAgICB9LFxuICAgIG5leHRGcmFtZSguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gYXBpLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBhcGkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRUaW1lb3V0KC4uLmFyZ3MpIHtcbiAgICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoLi4uYXJncyk7XG4gICAgICByZXR1cm4gYXBpLmFkZCgoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpKTtcbiAgICB9LFxuICAgIG1pY3JvVGFzayguLi5hcmdzKSB7XG4gICAgICBsZXQgdGFzayA9IHsgY3VycmVudDogdHJ1ZSB9O1xuICAgICAgbWljcm9UYXNrKCgpID0+IHtcbiAgICAgICAgaWYgKHRhc2suY3VycmVudCkge1xuICAgICAgICAgIGFyZ3NbMF0oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXBpLmFkZCgoKSA9PiB7XG4gICAgICAgIHRhc2suY3VycmVudCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhZGQoY2IpIHtcbiAgICAgIGRpc3Bvc2FibGVzMi5wdXNoKGNiKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxldCBpZHggPSBkaXNwb3NhYmxlczIuaW5kZXhPZihjYik7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIGxldCBbZGlzcG9zZV0gPSBkaXNwb3NhYmxlczIuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIGZvciAobGV0IGRpc3Bvc2Ugb2YgZGlzcG9zYWJsZXMyLnNwbGljZSgwKSkge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyB3b3JrUXVldWUoKSB7XG4gICAgICBmb3IgKGxldCBoYW5kbGUgb2YgcXVldWUuc3BsaWNlKDApKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGFwaTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1kaXNwb3NhYmxlcy50c1xuZnVuY3Rpb24gdXNlRGlzcG9zYWJsZXMoKSB7XG4gIGxldCBbZF0gPSAoMCwgaW1wb3J0X3JlYWN0NC51c2VTdGF0ZSkoZGlzcG9zYWJsZXMpO1xuICAoMCwgaW1wb3J0X3JlYWN0NC51c2VFZmZlY3QpKCgpID0+ICgpID0+IGQuZGlzcG9zZSgpLCBbZF0pO1xuICByZXR1cm4gZDtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1ldmVudC50c1xudmFyIGltcG9ydF9yZWFjdDUgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSwgMSk7XG52YXIgdXNlRXZlbnQgPSBmdW5jdGlvbiB1c2VFdmVudDIoY2IpIHtcbiAgbGV0IGNhY2hlID0gdXNlTGF0ZXN0VmFsdWUoY2IpO1xuICByZXR1cm4gaW1wb3J0X3JlYWN0NS5kZWZhdWx0LnVzZUNhbGxiYWNrKCguLi5hcmdzKSA9PiBjYWNoZS5jdXJyZW50KC4uLmFyZ3MpLCBbY2FjaGVdKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2UtaWQudHNcbnZhciBpbXBvcnRfcmVhY3Q3ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xuXG4vLyBzcmMvaG9va3MvdXNlLXNlcnZlci1oYW5kb2ZmLWNvbXBsZXRlLnRzXG52YXIgaW1wb3J0X3JlYWN0NiA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBzdGF0ZSA9IHsgc2VydmVySGFuZG9mZkNvbXBsZXRlOiBmYWxzZSB9O1xuZnVuY3Rpb24gdXNlU2VydmVySGFuZG9mZkNvbXBsZXRlKCkge1xuICBsZXQgW3NlcnZlckhhbmRvZmZDb21wbGV0ZSwgc2V0U2VydmVySGFuZG9mZkNvbXBsZXRlXSA9ICgwLCBpbXBvcnRfcmVhY3Q2LnVzZVN0YXRlKShzdGF0ZS5zZXJ2ZXJIYW5kb2ZmQ29tcGxldGUpO1xuICAoMCwgaW1wb3J0X3JlYWN0Ni51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBpZiAoc2VydmVySGFuZG9mZkNvbXBsZXRlID09PSB0cnVlKVxuICAgICAgcmV0dXJuO1xuICAgIHNldFNlcnZlckhhbmRvZmZDb21wbGV0ZSh0cnVlKTtcbiAgfSwgW3NlcnZlckhhbmRvZmZDb21wbGV0ZV0pO1xuICAoMCwgaW1wb3J0X3JlYWN0Ni51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBpZiAoc3RhdGUuc2VydmVySGFuZG9mZkNvbXBsZXRlID09PSBmYWxzZSlcbiAgICAgIHN0YXRlLnNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IHRydWU7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHNlcnZlckhhbmRvZmZDb21wbGV0ZTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1pZC50c1xudmFyIGlkID0gMDtcbmZ1bmN0aW9uIGdlbmVyYXRlSWQoKSB7XG4gIHJldHVybiArK2lkO1xufVxudmFyIF9hO1xudmFyIHVzZUlkID0gKF9hID0gaW1wb3J0X3JlYWN0Ny5kZWZhdWx0LnVzZUlkKSAhPSBudWxsID8gX2EgOiBmdW5jdGlvbiB1c2VJZDIoKSB7XG4gIGxldCByZWFkeSA9IHVzZVNlcnZlckhhbmRvZmZDb21wbGV0ZSgpO1xuICBsZXQgW2lkMiwgc2V0SWRdID0gaW1wb3J0X3JlYWN0Ny5kZWZhdWx0LnVzZVN0YXRlKHJlYWR5ID8gZ2VuZXJhdGVJZCA6IG51bGwpO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaWQyID09PSBudWxsKVxuICAgICAgc2V0SWQoZ2VuZXJhdGVJZCgpKTtcbiAgfSwgW2lkMl0pO1xuICByZXR1cm4gaWQyICE9IG51bGwgPyBcIlwiICsgaWQyIDogdm9pZCAwO1xufTtcblxuLy8gc3JjL2hvb2tzL3VzZS1vdXRzaWRlLWNsaWNrLnRzXG52YXIgaW1wb3J0X3JlYWN0OSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gc3JjL3V0aWxzL21hdGNoLnRzXG5mdW5jdGlvbiBtYXRjaCh2YWx1ZSwgbG9va3VwLCAuLi5hcmdzKSB7XG4gIGlmICh2YWx1ZSBpbiBsb29rdXApIHtcbiAgICBsZXQgcmV0dXJuVmFsdWUgPSBsb29rdXBbdmFsdWVdO1xuICAgIHJldHVybiB0eXBlb2YgcmV0dXJuVmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHJldHVyblZhbHVlKC4uLmFyZ3MpIDogcmV0dXJuVmFsdWU7XG4gIH1cbiAgbGV0IGVycm9yID0gbmV3IEVycm9yKGBUcmllZCB0byBoYW5kbGUgXCIke3ZhbHVlfVwiIGJ1dCB0aGVyZSBpcyBubyBoYW5kbGVyIGRlZmluZWQuIE9ubHkgZGVmaW5lZCBoYW5kbGVycyBhcmU6ICR7T2JqZWN0LmtleXMobG9va3VwKS5tYXAoKGtleSkgPT4gYFwiJHtrZXl9XCJgKS5qb2luKFwiLCBcIil9LmApO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIG1hdGNoKTtcbiAgdGhyb3cgZXJyb3I7XG59XG5cbi8vIHNyYy91dGlscy9vd25lci50c1xuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudChlbGVtZW50KSB7XG4gIGlmIChpc1NlcnZlcilcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKVxuICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGlmIChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50Lmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSkge1xuICAgIGlmIChlbGVtZW50LmN1cnJlbnQgaW5zdGFuY2VvZiBOb2RlKVxuICAgICAgcmV0dXJuIGVsZW1lbnQuY3VycmVudC5vd25lckRvY3VtZW50O1xuICB9XG4gIHJldHVybiBkb2N1bWVudDtcbn1cblxuLy8gc3JjL3V0aWxzL2ZvY3VzLW1hbmFnZW1lbnQudHNcbnZhciBmb2N1c2FibGVTZWxlY3RvciA9IFtcbiAgXCJbY29udGVudEVkaXRhYmxlPXRydWVdXCIsXG4gIFwiW3RhYmluZGV4XVwiLFxuICBcImFbaHJlZl1cIixcbiAgXCJhcmVhW2hyZWZdXCIsXG4gIFwiYnV0dG9uOm5vdChbZGlzYWJsZWRdKVwiLFxuICBcImlmcmFtZVwiLFxuICBcImlucHV0Om5vdChbZGlzYWJsZWRdKVwiLFxuICBcInNlbGVjdDpub3QoW2Rpc2FibGVkXSlcIixcbiAgXCJ0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSlcIlxuXS5tYXAoZmFsc2UgPyAoc2VsZWN0b3IpID0+IGAke3NlbGVjdG9yfTpub3QoW3RhYmluZGV4PSctMSddKTpub3QoW3N0eWxlKj0nZGlzcGxheTogbm9uZSddKWAgOiAoc2VsZWN0b3IpID0+IGAke3NlbGVjdG9yfTpub3QoW3RhYmluZGV4PSctMSddKWApLmpvaW4oXCIsXCIpO1xuZnVuY3Rpb24gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoY29udGFpbmVyID0gZG9jdW1lbnQuYm9keSkge1xuICBpZiAoY29udGFpbmVyID09IG51bGwpXG4gICAgcmV0dXJuIFtdO1xuICByZXR1cm4gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGVTZWxlY3RvcikpO1xufVxuZnVuY3Rpb24gaXNGb2N1c2FibGVFbGVtZW50KGVsZW1lbnQsIG1vZGUgPSAwIC8qIFN0cmljdCAqLykge1xuICB2YXIgX2EyO1xuICBpZiAoZWxlbWVudCA9PT0gKChfYTIgPSBnZXRPd25lckRvY3VtZW50KGVsZW1lbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmJvZHkpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG1hdGNoKG1vZGUsIHtcbiAgICBbMCAvKiBTdHJpY3QgKi9dKCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhmb2N1c2FibGVTZWxlY3Rvcik7XG4gICAgfSxcbiAgICBbMSAvKiBMb29zZSAqL10oKSB7XG4gICAgICBsZXQgbmV4dCA9IGVsZW1lbnQ7XG4gICAgICB3aGlsZSAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dC5tYXRjaGVzKGZvY3VzYWJsZVNlbGVjdG9yKSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzdG9yZUZvY3VzSWZOZWNlc3NhcnkoZWxlbWVudCkge1xuICBsZXQgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnQoZWxlbWVudCk7XG4gIGRpc3Bvc2FibGVzKCkubmV4dEZyYW1lKCgpID0+IHtcbiAgICBpZiAob3duZXJEb2N1bWVudCAmJiAhaXNGb2N1c2FibGVFbGVtZW50KG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgMCAvKiBTdHJpY3QgKi8pKSB7XG4gICAgICBmb2N1c0VsZW1lbnQoZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZvY3VzRWxlbWVudChlbGVtZW50KSB7XG4gIGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xufVxudmFyIHNlbGVjdGFibGVTZWxlY3RvciA9IFtcInRleHRhcmVhXCIsIFwiaW5wdXRcIl0uam9pbihcIixcIik7XG5mdW5jdGlvbiBpc1NlbGVjdGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIHJldHVybiAoX2IgPSAoX2EyID0gZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5tYXRjaGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoZWxlbWVudCwgc2VsZWN0YWJsZVNlbGVjdG9yKSkgIT0gbnVsbCA/IF9iIDogZmFsc2U7XG59XG5mdW5jdGlvbiBzb3J0QnlEb21Ob2RlKG5vZGVzLCByZXNvbHZlS2V5ID0gKGkpID0+IGkpIHtcbiAgcmV0dXJuIG5vZGVzLnNsaWNlKCkuc29ydCgoYUl0ZW0sIHpJdGVtKSA9PiB7XG4gICAgbGV0IGEgPSByZXNvbHZlS2V5KGFJdGVtKTtcbiAgICBsZXQgeiA9IHJlc29sdmVLZXkoekl0ZW0pO1xuICAgIGlmIChhID09PSBudWxsIHx8IHogPT09IG51bGwpXG4gICAgICByZXR1cm4gMDtcbiAgICBsZXQgcG9zaXRpb24gPSBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHopO1xuICAgIGlmIChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIGlmIChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKVxuICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxuZnVuY3Rpb24gZm9jdXNGcm9tKGN1cnJlbnQsIGZvY3VzKSB7XG4gIHJldHVybiBmb2N1c0luKGdldEZvY3VzYWJsZUVsZW1lbnRzKCksIGZvY3VzLCB0cnVlLCBjdXJyZW50KTtcbn1cbmZ1bmN0aW9uIGZvY3VzSW4oY29udGFpbmVyLCBmb2N1cywgc29ydGVkID0gdHJ1ZSwgYWN0aXZlID0gbnVsbCkge1xuICBsZXQgb3duZXJEb2N1bWVudCA9IEFycmF5LmlzQXJyYXkoY29udGFpbmVyKSA/IGNvbnRhaW5lci5sZW5ndGggPiAwID8gY29udGFpbmVyWzBdLm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudCA6IGNvbnRhaW5lci5vd25lckRvY3VtZW50O1xuICBsZXQgZWxlbWVudHMgPSBBcnJheS5pc0FycmF5KGNvbnRhaW5lcikgPyBzb3J0ZWQgPyBzb3J0QnlEb21Ob2RlKGNvbnRhaW5lcikgOiBjb250YWluZXIgOiBnZXRGb2N1c2FibGVFbGVtZW50cyhjb250YWluZXIpO1xuICBhY3RpdmUgPSBhY3RpdmUgIT0gbnVsbCA/IGFjdGl2ZSA6IG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgbGV0IGRpcmVjdGlvbiA9ICgoKSA9PiB7XG4gICAgaWYgKGZvY3VzICYgKDEgLyogRmlyc3QgKi8gfCA0IC8qIE5leHQgKi8pKVxuICAgICAgcmV0dXJuIDEgLyogTmV4dCAqLztcbiAgICBpZiAoZm9jdXMgJiAoMiAvKiBQcmV2aW91cyAqLyB8IDggLyogTGFzdCAqLykpXG4gICAgICByZXR1cm4gLTEgLyogUHJldmlvdXMgKi87XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBGb2N1cy5GaXJzdCwgRm9jdXMuUHJldmlvdXMsIEZvY3VzLk5leHQgb3IgRm9jdXMuTGFzdFwiKTtcbiAgfSkoKTtcbiAgbGV0IHN0YXJ0SW5kZXggPSAoKCkgPT4ge1xuICAgIGlmIChmb2N1cyAmIDEgLyogRmlyc3QgKi8pXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAoZm9jdXMgJiAyIC8qIFByZXZpb3VzICovKVxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGVsZW1lbnRzLmluZGV4T2YoYWN0aXZlKSkgLSAxO1xuICAgIGlmIChmb2N1cyAmIDQgLyogTmV4dCAqLylcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBlbGVtZW50cy5pbmRleE9mKGFjdGl2ZSkpICsgMTtcbiAgICBpZiAoZm9jdXMgJiA4IC8qIExhc3QgKi8pXG4gICAgICByZXR1cm4gZWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEZvY3VzLkZpcnN0LCBGb2N1cy5QcmV2aW91cywgRm9jdXMuTmV4dCBvciBGb2N1cy5MYXN0XCIpO1xuICB9KSgpO1xuICBsZXQgZm9jdXNPcHRpb25zID0gZm9jdXMgJiAzMiAvKiBOb1Njcm9sbCAqLyA/IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9IDoge307XG4gIGxldCBvZmZzZXQgPSAwO1xuICBsZXQgdG90YWwgPSBlbGVtZW50cy5sZW5ndGg7XG4gIGxldCBuZXh0ID0gdm9pZCAwO1xuICBkbyB7XG4gICAgaWYgKG9mZnNldCA+PSB0b3RhbCB8fCBvZmZzZXQgKyB0b3RhbCA8PSAwKVxuICAgICAgcmV0dXJuIDAgLyogRXJyb3IgKi87XG4gICAgbGV0IG5leHRJZHggPSBzdGFydEluZGV4ICsgb2Zmc2V0O1xuICAgIGlmIChmb2N1cyAmIDE2IC8qIFdyYXBBcm91bmQgKi8pIHtcbiAgICAgIG5leHRJZHggPSAobmV4dElkeCArIHRvdGFsKSAlIHRvdGFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dElkeCA8IDApXG4gICAgICAgIHJldHVybiAzIC8qIFVuZGVyZmxvdyAqLztcbiAgICAgIGlmIChuZXh0SWR4ID49IHRvdGFsKVxuICAgICAgICByZXR1cm4gMSAvKiBPdmVyZmxvdyAqLztcbiAgICB9XG4gICAgbmV4dCA9IGVsZW1lbnRzW25leHRJZHhdO1xuICAgIG5leHQgPT0gbnVsbCA/IHZvaWQgMCA6IG5leHQuZm9jdXMoZm9jdXNPcHRpb25zKTtcbiAgICBvZmZzZXQgKz0gZGlyZWN0aW9uO1xuICB9IHdoaWxlIChuZXh0ICE9PSBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoZm9jdXMgJiAoNCAvKiBOZXh0ICovIHwgMiAvKiBQcmV2aW91cyAqLykgJiYgaXNTZWxlY3RhYmxlRWxlbWVudChuZXh0KSkge1xuICAgIG5leHQuc2VsZWN0KCk7XG4gIH1cbiAgaWYgKCFuZXh0Lmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpKVxuICAgIG5leHQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICByZXR1cm4gMiAvKiBTdWNjZXNzICovO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLWRvY3VtZW50LWV2ZW50LnRzXG52YXIgaW1wb3J0X3JlYWN0OCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIHVzZURvY3VtZW50RXZlbnQodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgbGV0IGxpc3RlbmVyUmVmID0gdXNlTGF0ZXN0VmFsdWUobGlzdGVuZXIpO1xuICAoMCwgaW1wb3J0X3JlYWN0OC51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBsaXN0ZW5lclJlZi5jdXJyZW50KGV2ZW50KTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfSwgW3R5cGUsIG9wdGlvbnNdKTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1vdXRzaWRlLWNsaWNrLnRzXG5mdW5jdGlvbiB1c2VPdXRzaWRlQ2xpY2soY29udGFpbmVycywgY2IsIGVuYWJsZWQgPSB0cnVlKSB7XG4gIGxldCBlbmFibGVkUmVmID0gKDAsIGltcG9ydF9yZWFjdDkudXNlUmVmKShmYWxzZSk7XG4gICgwLCBpbXBvcnRfcmVhY3Q5LnVzZUVmZmVjdCkoZmFsc2UgPyAoKSA9PiB7XG4gICAgZW5hYmxlZFJlZi5jdXJyZW50ID0gZW5hYmxlZDtcbiAgfSA6ICgpID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZW5hYmxlZFJlZi5jdXJyZW50ID0gZW5hYmxlZDtcbiAgICB9KTtcbiAgfSwgW2VuYWJsZWRdKTtcbiAgZnVuY3Rpb24gaGFuZGxlT3V0c2lkZUNsaWNrKGV2ZW50LCByZXNvbHZlVGFyZ2V0KSB7XG4gICAgaWYgKCFlbmFibGVkUmVmLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IF9jb250YWluZXJzID0gZnVuY3Rpb24gcmVzb2x2ZShjb250YWluZXJzMikge1xuICAgICAgaWYgKHR5cGVvZiBjb250YWluZXJzMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGNvbnRhaW5lcnMyKCkpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGFpbmVyczIpKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXJzMjtcbiAgICAgIH1cbiAgICAgIGlmIChjb250YWluZXJzMiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyczI7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2NvbnRhaW5lcnMyXTtcbiAgICB9KGNvbnRhaW5lcnMpO1xuICAgIGxldCB0YXJnZXQgPSByZXNvbHZlVGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpXG4gICAgICByZXR1cm47XG4gICAgZm9yIChsZXQgY29udGFpbmVyIG9mIF9jb250YWluZXJzKSB7XG4gICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGxldCBkb21Ob2RlID0gY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBjb250YWluZXIgOiBjb250YWluZXIuY3VycmVudDtcbiAgICAgIGlmIChkb21Ob2RlID09IG51bGwgPyB2b2lkIDAgOiBkb21Ob2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRm9jdXNhYmxlRWxlbWVudCh0YXJnZXQsIDEgLyogTG9vc2UgKi8pICYmIHRhcmdldC50YWJJbmRleCAhPT0gLTEpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIHJldHVybiBjYihldmVudCwgdGFyZ2V0KTtcbiAgfVxuICBsZXQgaW5pdGlhbENsaWNrVGFyZ2V0ID0gKDAsIGltcG9ydF9yZWFjdDkudXNlUmVmKShudWxsKTtcbiAgdXNlRG9jdW1lbnRFdmVudChcIm1vdXNlZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZW5hYmxlZFJlZi5jdXJyZW50KSB7XG4gICAgICBpbml0aWFsQ2xpY2tUYXJnZXQuY3VycmVudCA9IGV2ZW50LnRhcmdldDtcbiAgICB9XG4gIH0sIHRydWUpO1xuICB1c2VEb2N1bWVudEV2ZW50KFwiY2xpY2tcIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKCFpbml0aWFsQ2xpY2tUYXJnZXQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVPdXRzaWRlQ2xpY2soZXZlbnQsICgpID0+IHtcbiAgICAgIHJldHVybiBpbml0aWFsQ2xpY2tUYXJnZXQuY3VycmVudDtcbiAgICB9KTtcbiAgICBpbml0aWFsQ2xpY2tUYXJnZXQuY3VycmVudCA9IG51bGw7XG4gIH0sIHRydWUpO1xuICB1c2VEb2N1bWVudEV2ZW50KFwiYmx1clwiLCAoZXZlbnQpID0+IGhhbmRsZU91dHNpZGVDbGljayhldmVudCwgKCkgPT4gd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCA/IHdpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50IDogbnVsbCksIHRydWUpO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXJlc29sdmUtYnV0dG9uLXR5cGUudHNcbnZhciBpbXBvcnRfcmVhY3QxMCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIHJlc29sdmVUeXBlKHByb3BzKSB7XG4gIHZhciBfYTI7XG4gIGlmIChwcm9wcy50eXBlKVxuICAgIHJldHVybiBwcm9wcy50eXBlO1xuICBsZXQgdGFnID0gKF9hMiA9IHByb3BzLmFzKSAhPSBudWxsID8gX2EyIDogXCJidXR0b25cIjtcbiAgaWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIgJiYgdGFnLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCIpXG4gICAgcmV0dXJuIFwiYnV0dG9uXCI7XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiB1c2VSZXNvbHZlQnV0dG9uVHlwZShwcm9wcywgcmVmKSB7XG4gIGxldCBbdHlwZSwgc2V0VHlwZV0gPSAoMCwgaW1wb3J0X3JlYWN0MTAudXNlU3RhdGUpKCgpID0+IHJlc29sdmVUeXBlKHByb3BzKSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIHNldFR5cGUocmVzb2x2ZVR5cGUocHJvcHMpKTtcbiAgfSwgW3Byb3BzLnR5cGUsIHByb3BzLmFzXSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcmVmLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlZi5jdXJyZW50IGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQgJiYgIXJlZi5jdXJyZW50Lmhhc0F0dHJpYnV0ZShcInR5cGVcIikpIHtcbiAgICAgIHNldFR5cGUoXCJidXR0b25cIik7XG4gICAgfVxuICB9LCBbdHlwZSwgcmVmXSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXN5bmMtcmVmcy50c1xudmFyIGltcG9ydF9yZWFjdDExID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIE9wdGlvbmFsID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBvcHRpb25hbFJlZihjYiwgaXNPcHRpb25hbCA9IHRydWUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY2IsIHsgW09wdGlvbmFsXTogaXNPcHRpb25hbCB9KTtcbn1cbmZ1bmN0aW9uIHVzZVN5bmNSZWZzKC4uLnJlZnMpIHtcbiAgbGV0IGNhY2hlID0gKDAsIGltcG9ydF9yZWFjdDExLnVzZVJlZikocmVmcyk7XG4gICgwLCBpbXBvcnRfcmVhY3QxMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBjYWNoZS5jdXJyZW50ID0gcmVmcztcbiAgfSwgW3JlZnNdKTtcbiAgbGV0IHN5bmNSZWZzID0gdXNlRXZlbnQoKHZhbHVlKSA9PiB7XG4gICAgZm9yIChsZXQgcmVmIG9mIGNhY2hlLmN1cnJlbnQpIHtcbiAgICAgIGlmIChyZWYgPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZWYodmFsdWUpO1xuICAgICAgZWxzZVxuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZWZzLmV2ZXJ5KChyZWYpID0+IHJlZiA9PSBudWxsIHx8IChyZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZltPcHRpb25hbF0pKSA/IHZvaWQgMCA6IHN5bmNSZWZzO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXRyZWUtd2Fsa2VyLnRzXG52YXIgaW1wb3J0X3JlYWN0MTIgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VUcmVlV2Fsa2VyKHtcbiAgY29udGFpbmVyLFxuICBhY2NlcHQsXG4gIHdhbGssXG4gIGVuYWJsZWQgPSB0cnVlXG59KSB7XG4gIGxldCBhY2NlcHRSZWYgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlUmVmKShhY2NlcHQpO1xuICBsZXQgd2Fsa1JlZiA9ICgwLCBpbXBvcnRfcmVhY3QxMi51c2VSZWYpKHdhbGspO1xuICAoMCwgaW1wb3J0X3JlYWN0MTIudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgYWNjZXB0UmVmLmN1cnJlbnQgPSBhY2NlcHQ7XG4gICAgd2Fsa1JlZi5jdXJyZW50ID0gd2FsaztcbiAgfSwgW2FjY2VwdCwgd2Fsa10pO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lcilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIWVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50KGNvbnRhaW5lcik7XG4gICAgaWYgKCFvd25lckRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBhY2NlcHQyID0gYWNjZXB0UmVmLmN1cnJlbnQ7XG4gICAgbGV0IHdhbGsyID0gd2Fsa1JlZi5jdXJyZW50O1xuICAgIGxldCBhY2NlcHROb2RlID0gT2JqZWN0LmFzc2lnbigobm9kZSkgPT4gYWNjZXB0Mihub2RlKSwgeyBhY2NlcHROb2RlOiBhY2NlcHQyIH0pO1xuICAgIGxldCB3YWxrZXIgPSBvd25lckRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoY29udGFpbmVyLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgYWNjZXB0Tm9kZSwgZmFsc2UpO1xuICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSlcbiAgICAgIHdhbGsyKHdhbGtlci5jdXJyZW50Tm9kZSk7XG4gIH0sIFtjb250YWluZXIsIGVuYWJsZWQsIGFjY2VwdFJlZiwgd2Fsa1JlZl0pO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsY3VsYXRlLWFjdGl2ZS1pbmRleC50c1xuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoeCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG9iamVjdDogXCIgKyB4KTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFjdGl2ZUluZGV4KGFjdGlvbiwgcmVzb2x2ZXJzKSB7XG4gIGxldCBpdGVtcyA9IHJlc29sdmVycy5yZXNvbHZlSXRlbXMoKTtcbiAgaWYgKGl0ZW1zLmxlbmd0aCA8PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgY3VycmVudEFjdGl2ZUluZGV4ID0gcmVzb2x2ZXJzLnJlc29sdmVBY3RpdmVJbmRleCgpO1xuICBsZXQgYWN0aXZlSW5kZXggPSBjdXJyZW50QWN0aXZlSW5kZXggIT0gbnVsbCA/IGN1cnJlbnRBY3RpdmVJbmRleCA6IC0xO1xuICBsZXQgbmV4dEFjdGl2ZUluZGV4ID0gKCgpID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbi5mb2N1cykge1xuICAgICAgY2FzZSAwIC8qIEZpcnN0ICovOlxuICAgICAgICByZXR1cm4gaXRlbXMuZmluZEluZGV4KChpdGVtKSA9PiAhcmVzb2x2ZXJzLnJlc29sdmVEaXNhYmxlZChpdGVtKSk7XG4gICAgICBjYXNlIDEgLyogUHJldmlvdXMgKi86IHtcbiAgICAgICAgbGV0IGlkeCA9IGl0ZW1zLnNsaWNlKCkucmV2ZXJzZSgpLmZpbmRJbmRleCgoaXRlbSwgaWR4MiwgYWxsKSA9PiB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUluZGV4ICE9PSAtMSAmJiBhbGwubGVuZ3RoIC0gaWR4MiAtIDEgPj0gYWN0aXZlSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICFyZXNvbHZlcnMucmVzb2x2ZURpc2FibGVkKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpXG4gICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCAtIDEgLSBpZHg7XG4gICAgICB9XG4gICAgICBjYXNlIDIgLyogTmV4dCAqLzpcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbmRJbmRleCgoaXRlbSwgaWR4KSA9PiB7XG4gICAgICAgICAgaWYgKGlkeCA8PSBhY3RpdmVJbmRleClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gIXJlc29sdmVycy5yZXNvbHZlRGlzYWJsZWQoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAzIC8qIExhc3QgKi86IHtcbiAgICAgICAgbGV0IGlkeCA9IGl0ZW1zLnNsaWNlKCkucmV2ZXJzZSgpLmZpbmRJbmRleCgoaXRlbSkgPT4gIXJlc29sdmVycy5yZXNvbHZlRGlzYWJsZWQoaXRlbSkpO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSlcbiAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICByZXR1cm4gaXRlbXMubGVuZ3RoIC0gMSAtIGlkeDtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBTcGVjaWZpYyAqLzpcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbmRJbmRleCgoaXRlbSkgPT4gcmVzb2x2ZXJzLnJlc29sdmVJZChpdGVtKSA9PT0gYWN0aW9uLmlkKTtcbiAgICAgIGNhc2UgNSAvKiBOb3RoaW5nICovOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydE5ldmVyKGFjdGlvbik7XG4gICAgfVxuICB9KSgpO1xuICByZXR1cm4gbmV4dEFjdGl2ZUluZGV4ID09PSAtMSA/IGN1cnJlbnRBY3RpdmVJbmRleCA6IG5leHRBY3RpdmVJbmRleDtcbn1cblxuLy8gc3JjL3V0aWxzL3JlbmRlci50c1xudmFyIGltcG9ydF9yZWFjdDEzID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gcmVuZGVyKHtcbiAgb3VyUHJvcHMsXG4gIHRoZWlyUHJvcHMsXG4gIHNsb3QsXG4gIGRlZmF1bHRUYWcsXG4gIGZlYXR1cmVzLFxuICB2aXNpYmxlID0gdHJ1ZSxcbiAgbmFtZVxufSkge1xuICBsZXQgcHJvcHMgPSBtZXJnZVByb3BzKHRoZWlyUHJvcHMsIG91clByb3BzKTtcbiAgaWYgKHZpc2libGUpXG4gICAgcmV0dXJuIF9yZW5kZXIocHJvcHMsIHNsb3QsIGRlZmF1bHRUYWcsIG5hbWUpO1xuICBsZXQgZmVhdHVyZUZsYWdzID0gZmVhdHVyZXMgIT0gbnVsbCA/IGZlYXR1cmVzIDogMCAvKiBOb25lICovO1xuICBpZiAoZmVhdHVyZUZsYWdzICYgMiAvKiBTdGF0aWMgKi8pIHtcbiAgICBsZXQgeyBzdGF0aWM6IGlzU3RhdGljID0gZmFsc2UsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGlmIChpc1N0YXRpYylcbiAgICAgIHJldHVybiBfcmVuZGVyKHJlc3QsIHNsb3QsIGRlZmF1bHRUYWcsIG5hbWUpO1xuICB9XG4gIGlmIChmZWF0dXJlRmxhZ3MgJiAxIC8qIFJlbmRlclN0cmF0ZWd5ICovKSB7XG4gICAgbGV0IHsgdW5tb3VudCA9IHRydWUsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGxldCBzdHJhdGVneSA9IHVubW91bnQgPyAwIC8qIFVubW91bnQgKi8gOiAxIC8qIEhpZGRlbiAqLztcbiAgICByZXR1cm4gbWF0Y2goc3RyYXRlZ3ksIHtcbiAgICAgIFswIC8qIFVubW91bnQgKi9dKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBbMSAvKiBIaWRkZW4gKi9dKCkge1xuICAgICAgICByZXR1cm4gX3JlbmRlcih7IC4uLnJlc3QsIC4uLnsgaGlkZGVuOiB0cnVlLCBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH0gfSwgc2xvdCwgZGVmYXVsdFRhZywgbmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIF9yZW5kZXIocHJvcHMsIHNsb3QsIGRlZmF1bHRUYWcsIG5hbWUpO1xufVxuZnVuY3Rpb24gX3JlbmRlcihwcm9wcywgc2xvdCA9IHt9LCB0YWcsIG5hbWUpIHtcbiAgbGV0IHtcbiAgICBhczogQ29tcG9uZW50ID0gdGFnLFxuICAgIGNoaWxkcmVuLFxuICAgIHJlZk5hbWUgPSBcInJlZlwiLFxuICAgIC4uLnJlc3RcbiAgfSA9IG9taXQocHJvcHMsIFtcInVubW91bnRcIiwgXCJzdGF0aWNcIl0pO1xuICBsZXQgcmVmUmVsYXRlZFByb3BzID0gcHJvcHMucmVmICE9PSB2b2lkIDAgPyB7IFtyZWZOYW1lXTogcHJvcHMucmVmIH0gOiB7fTtcbiAgbGV0IHJlc29sdmVkQ2hpbGRyZW4gPSB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKHNsb3QpIDogY2hpbGRyZW47XG4gIGlmIChyZXN0LmNsYXNzTmFtZSAmJiB0eXBlb2YgcmVzdC5jbGFzc05hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIDtcbiAgICByZXN0LmNsYXNzTmFtZSA9IHJlc3QuY2xhc3NOYW1lKHNsb3QpO1xuICB9XG4gIGxldCBkYXRhQXR0cmlidXRlcyA9IHt9O1xuICBpZiAoc2xvdCkge1xuICAgIGxldCBleHBvc2VTdGF0ZSA9IGZhbHNlO1xuICAgIGxldCBzdGF0ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc2xvdCkpIHtcbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgZXhwb3NlU3RhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHYgPT09IHRydWUpIHtcbiAgICAgICAgc3RhdGVzLnB1c2goayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHBvc2VTdGF0ZSlcbiAgICAgIGRhdGFBdHRyaWJ1dGVzW2BkYXRhLWhlYWRsZXNzdWktc3RhdGVgXSA9IHN0YXRlcy5qb2luKFwiIFwiKTtcbiAgfVxuICBpZiAoQ29tcG9uZW50ID09PSBpbXBvcnRfcmVhY3QxMy5GcmFnbWVudCkge1xuICAgIGlmIChPYmplY3Qua2V5cyhjb21wYWN0KHJlc3QpKS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoISgwLCBpbXBvcnRfcmVhY3QxMy5pc1ZhbGlkRWxlbWVudCkocmVzb2x2ZWRDaGlsZHJlbikgfHwgQXJyYXkuaXNBcnJheShyZXNvbHZlZENoaWxkcmVuKSAmJiByZXNvbHZlZENoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAnUGFzc2luZyBwcm9wcyBvbiBcIkZyYWdtZW50XCIhJyxcbiAgICAgICAgICBcIlwiLFxuICAgICAgICAgIGBUaGUgY3VycmVudCBjb21wb25lbnQgPCR7bmFtZX0gLz4gaXMgcmVuZGVyaW5nIGEgXCJGcmFnbWVudFwiLmAsXG4gICAgICAgICAgYEhvd2V2ZXIgd2UgbmVlZCB0byBwYXNzdGhyb3VnaCB0aGUgZm9sbG93aW5nIHByb3BzOmAsXG4gICAgICAgICAgT2JqZWN0LmtleXMocmVzdCkubWFwKChsaW5lKSA9PiBgICAtICR7bGluZX1gKS5qb2luKFwiXFxuXCIpLFxuICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgXCJZb3UgY2FuIGFwcGx5IGEgZmV3IHNvbHV0aW9uczpcIixcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnQWRkIGFuIGBhcz1cIi4uLlwiYCBwcm9wLCB0byBlbnN1cmUgdGhhdCB3ZSByZW5kZXIgYW4gYWN0dWFsIGVsZW1lbnQgaW5zdGVhZCBvZiBhIFwiRnJhZ21lbnRcIi4nLFxuICAgICAgICAgICAgXCJSZW5kZXIgYSBzaW5nbGUgZWxlbWVudCBhcyB0aGUgY2hpbGQgc28gdGhhdCB3ZSBjYW4gZm9yd2FyZCB0aGUgcHJvcHMgb250byB0aGF0IGVsZW1lbnQuXCJcbiAgICAgICAgICBdLm1hcCgobGluZSkgPT4gYCAgLSAke2xpbmV9YCkuam9pbihcIlxcblwiKVxuICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3QxMy5jbG9uZUVsZW1lbnQpKHJlc29sdmVkQ2hpbGRyZW4sIE9iamVjdC5hc3NpZ24oe30sIG1lcmdlUHJvcHMocmVzb2x2ZWRDaGlsZHJlbi5wcm9wcywgY29tcGFjdChvbWl0KHJlc3QsIFtcInJlZlwiXSkpKSwgZGF0YUF0dHJpYnV0ZXMsIHJlZlJlbGF0ZWRQcm9wcywgbWVyZ2VSZWZzKHJlc29sdmVkQ2hpbGRyZW4ucmVmLCByZWZSZWxhdGVkUHJvcHMucmVmKSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKDAsIGltcG9ydF9yZWFjdDEzLmNyZWF0ZUVsZW1lbnQpKENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgb21pdChyZXN0LCBbXCJyZWZcIl0pLCBDb21wb25lbnQgIT09IGltcG9ydF9yZWFjdDEzLkZyYWdtZW50ICYmIHJlZlJlbGF0ZWRQcm9wcywgQ29tcG9uZW50ICE9PSBpbXBvcnRfcmVhY3QxMy5GcmFnbWVudCAmJiBkYXRhQXR0cmlidXRlcyksIHJlc29sdmVkQ2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gbWVyZ2VSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuIHtcbiAgICByZWY6IHJlZnMuZXZlcnkoKHJlZikgPT4gcmVmID09IG51bGwpID8gdm9pZCAwIDogKHZhbHVlKSA9PiB7XG4gICAgICBmb3IgKGxldCByZWYgb2YgcmVmcykge1xuICAgICAgICBpZiAocmVmID09IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5saXN0T2ZQcm9wcykge1xuICB2YXIgX2EyO1xuICBpZiAobGlzdE9mUHJvcHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB7fTtcbiAgaWYgKGxpc3RPZlByb3BzLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gbGlzdE9mUHJvcHNbMF07XG4gIGxldCB0YXJnZXQgPSB7fTtcbiAgbGV0IGV2ZW50SGFuZGxlcnMgPSB7fTtcbiAgZm9yIChsZXQgcHJvcHMgb2YgbGlzdE9mUHJvcHMpIHtcbiAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcC5zdGFydHNXaXRoKFwib25cIikgJiYgdHlwZW9mIHByb3BzW3Byb3BdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgKF9hMiA9IGV2ZW50SGFuZGxlcnNbcHJvcF0pICE9IG51bGwgPyBfYTIgOiBldmVudEhhbmRsZXJzW3Byb3BdID0gW107XG4gICAgICAgIGV2ZW50SGFuZGxlcnNbcHJvcF0ucHVzaChwcm9wc1twcm9wXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHRhcmdldC5kaXNhYmxlZCB8fCB0YXJnZXRbXCJhcmlhLWRpc2FibGVkXCJdKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoZXZlbnRIYW5kbGVycykubWFwKChldmVudE5hbWUpID0+IFtldmVudE5hbWUsIHZvaWQgMF0pKSk7XG4gIH1cbiAgZm9yIChsZXQgZXZlbnROYW1lIGluIGV2ZW50SGFuZGxlcnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgW2V2ZW50TmFtZV0oZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgaWYgKChldmVudCBpbnN0YW5jZW9mIEV2ZW50IHx8IChldmVudCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnQubmF0aXZlRXZlbnQpIGluc3RhbmNlb2YgRXZlbnQpICYmIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlcihldmVudCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZm9yd2FyZFJlZldpdGhBcyhjb21wb25lbnQpIHtcbiAgdmFyIF9hMjtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKDAsIGltcG9ydF9yZWFjdDEzLmZvcndhcmRSZWYpKGNvbXBvbmVudCksIHtcbiAgICBkaXNwbGF5TmFtZTogKF9hMiA9IGNvbXBvbmVudC5kaXNwbGF5TmFtZSkgIT0gbnVsbCA/IF9hMiA6IGNvbXBvbmVudC5uYW1lXG4gIH0pO1xufVxuZnVuY3Rpb24gY29tcGFjdChvYmplY3QpIHtcbiAgbGV0IGNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0KTtcbiAgZm9yIChsZXQga2V5IGluIGNsb25lKSB7XG4gICAgaWYgKGNsb25lW2tleV0gPT09IHZvaWQgMClcbiAgICAgIGRlbGV0ZSBjbG9uZVtrZXldO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIG9taXQob2JqZWN0LCBrZXlzVG9PbWl0ID0gW10pIHtcbiAgbGV0IGNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0KTtcbiAgZm9yIChsZXQga2V5IG9mIGtleXNUb09taXQpIHtcbiAgICBpZiAoa2V5IGluIGNsb25lKVxuICAgICAgZGVsZXRlIGNsb25lW2tleV07XG4gIH1cbiAgcmV0dXJuIGNsb25lO1xufVxuXG4vLyBzcmMvdXRpbHMvYnVncy50c1xuZnVuY3Rpb24gaXNEaXNhYmxlZFJlYWN0SXNzdWU3NzExKGVsZW1lbnQpIHtcbiAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgbGV0IGxlZ2VuZCA9IG51bGw7XG4gIHdoaWxlIChwYXJlbnQgJiYgIShwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRmllbGRTZXRFbGVtZW50KSkge1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBIVE1MTGVnZW5kRWxlbWVudClcbiAgICAgIGxlZ2VuZCA9IHBhcmVudDtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgfVxuICBsZXQgaXNQYXJlbnREaXNhYmxlZCA9IChwYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkgPT09IFwiXCI7XG4gIGlmIChpc1BhcmVudERpc2FibGVkICYmIGlzRmlyc3RMZWdlbmQobGVnZW5kKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc1BhcmVudERpc2FibGVkO1xufVxuZnVuY3Rpb24gaXNGaXJzdExlZ2VuZChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgd2hpbGUgKHByZXZpb3VzICE9PSBudWxsKSB7XG4gICAgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgSFRNTExlZ2VuZEVsZW1lbnQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcHJldmlvdXMgPSBwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvdXRpbHMvZm9ybS50c1xuZnVuY3Rpb24gb2JqZWN0VG9Gb3JtRW50cmllcyhzb3VyY2UgPSB7fSwgcGFyZW50S2V5ID0gbnVsbCwgZW50cmllcyA9IFtdKSB7XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgYXBwZW5kKGVudHJpZXMsIGNvbXBvc2VLZXkocGFyZW50S2V5LCBrZXkpLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGVudHJpZXM7XG59XG5mdW5jdGlvbiBjb21wb3NlS2V5KHBhcmVudCwga2V5KSB7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQgKyBcIltcIiArIGtleSArIFwiXVwiIDoga2V5O1xufVxuZnVuY3Rpb24gYXBwZW5kKGVudHJpZXMsIGtleSwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgW3N1YmtleSwgc3VidmFsdWVdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgYXBwZW5kKGVudHJpZXMsIGNvbXBvc2VLZXkoa2V5LCBzdWJrZXkudG9TdHJpbmcoKSksIHN1YnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgZW50cmllcy5wdXNoKFtrZXksIHZhbHVlLnRvSVNPU3RyaW5nKCldKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgZW50cmllcy5wdXNoKFtrZXksIHZhbHVlID8gXCIxXCIgOiBcIjBcIl0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGVudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGVudHJpZXMucHVzaChba2V5LCBgJHt2YWx1ZX1gXSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGVudHJpZXMucHVzaChba2V5LCBcIlwiXSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0VG9Gb3JtRW50cmllcyh2YWx1ZSwga2V5LCBlbnRyaWVzKTtcbiAgfVxufVxuZnVuY3Rpb24gYXR0ZW1wdFN1Ym1pdChlbGVtZW50KSB7XG4gIHZhciBfYTI7XG4gIGxldCBmb3JtID0gKF9hMiA9IGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnQuZm9ybSkgIT0gbnVsbCA/IF9hMiA6IGVsZW1lbnQuY2xvc2VzdChcImZvcm1cIik7XG4gIGlmICghZm9ybSlcbiAgICByZXR1cm47XG4gIGZvciAobGV0IGVsZW1lbnQyIG9mIGZvcm0uZWxlbWVudHMpIHtcbiAgICBpZiAoZWxlbWVudDIudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIGVsZW1lbnQyLnR5cGUgPT09IFwic3VibWl0XCIgfHwgZWxlbWVudDIudGFnTmFtZSA9PT0gXCJCVVRUT05cIiAmJiBlbGVtZW50Mi50eXBlID09PSBcInN1Ym1pdFwiIHx8IGVsZW1lbnQyLm5vZGVOYW1lID09PSBcIklOUFVUXCIgJiYgZWxlbWVudDIudHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICBlbGVtZW50Mi5jbGljaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvaW50ZXJuYWwvaGlkZGVuLnRzeFxudmFyIERFRkFVTFRfVklTVUFMTFlfSElEREVOX1RBRyA9IFwiZGl2XCI7XG52YXIgSGlkZGVuID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBWaXN1YWxseUhpZGRlbihwcm9wcywgcmVmKSB7XG4gIGxldCB7IGZlYXR1cmVzID0gMSAvKiBOb25lICovLCAuLi50aGVpclByb3BzIH0gPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0ge1xuICAgIHJlZixcbiAgICBcImFyaWEtaGlkZGVuXCI6IChmZWF0dXJlcyAmIDIgLyogRm9jdXNhYmxlICovKSA9PT0gMiAvKiBGb2N1c2FibGUgKi8gPyB0cnVlIDogdm9pZCAwLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgdG9wOiAxLFxuICAgICAgbGVmdDogMSxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIG1hcmdpbjogLTEsXG4gICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgIGNsaXA6IFwicmVjdCgwLCAwLCAwLCAwKVwiLFxuICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgIGJvcmRlcldpZHRoOiBcIjBcIixcbiAgICAgIC4uLihmZWF0dXJlcyAmIDQgLyogSGlkZGVuICovKSA9PT0gNCAvKiBIaWRkZW4gKi8gJiYgISgoZmVhdHVyZXMgJiAyIC8qIEZvY3VzYWJsZSAqLykgPT09IDIgLyogRm9jdXNhYmxlICovKSAmJiB7IGRpc3BsYXk6IFwibm9uZVwiIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdDoge30sXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9WSVNVQUxMWV9ISURERU5fVEFHLFxuICAgIG5hbWU6IFwiSGlkZGVuXCJcbiAgfSk7XG59KTtcblxuLy8gc3JjL2ludGVybmFsL29wZW4tY2xvc2VkLnRzeFxudmFyIGltcG9ydF9yZWFjdDE0ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xudmFyIENvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MTQuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJPcGVuQ2xvc2VkQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlT3BlbkNsb3NlZCgpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3QxNC51c2VDb250ZXh0KShDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIE9wZW5DbG9zZWRQcm92aWRlcih7IHZhbHVlLCBjaGlsZHJlbiB9KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5cbi8vIHNyYy9ob29rcy91c2UtY29udHJvbGxhYmxlLnRzXG52YXIgaW1wb3J0X3JlYWN0MTUgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VDb250cm9sbGFibGUoY29udHJvbGxlZFZhbHVlLCBvbkNoYW5nZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGxldCBbaW50ZXJuYWxWYWx1ZSwgc2V0SW50ZXJuYWxWYWx1ZV0gPSAoMCwgaW1wb3J0X3JlYWN0MTUudXNlU3RhdGUpKGRlZmF1bHRWYWx1ZSk7XG4gIGxldCBpc0NvbnRyb2xsZWQgPSBjb250cm9sbGVkVmFsdWUgIT09IHZvaWQgMDtcbiAgcmV0dXJuIFtcbiAgICBpc0NvbnRyb2xsZWQgPyBjb250cm9sbGVkVmFsdWUgOiBpbnRlcm5hbFZhbHVlLFxuICAgIHVzZUV2ZW50KCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGlzQ29udHJvbGxlZCkge1xuICAgICAgICByZXR1cm4gb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEludGVybmFsVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KVxuICBdO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXdhdGNoLnRzXG52YXIgaW1wb3J0X3JlYWN0MTYgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VXYXRjaChjYiwgZGVwZW5kZW5jaWVzKSB7XG4gIGxldCB0cmFjayA9ICgwLCBpbXBvcnRfcmVhY3QxNi51c2VSZWYpKFtdKTtcbiAgbGV0IGFjdGlvbiA9IHVzZUV2ZW50KGNiKTtcbiAgKDAsIGltcG9ydF9yZWFjdDE2LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGxldCBvbGRWYWx1ZXMgPSBbLi4udHJhY2suY3VycmVudF07XG4gICAgZm9yIChsZXQgW2lkeCwgdmFsdWVdIG9mIGRlcGVuZGVuY2llcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmICh0cmFjay5jdXJyZW50W2lkeF0gIT09IHZhbHVlKSB7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZSA9IGFjdGlvbihkZXBlbmRlbmNpZXMsIG9sZFZhbHVlcyk7XG4gICAgICAgIHRyYWNrLmN1cnJlbnQgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFthY3Rpb24sIC4uLmRlcGVuZGVuY2llc10pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9jb21ib2JveC9jb21ib2JveC50c3hcbmZ1bmN0aW9uIGFkanVzdE9yZGVyZWRTdGF0ZShzdGF0ZTIsIGFkanVzdG1lbnQgPSAoaSkgPT4gaSkge1xuICBsZXQgY3VycmVudEFjdGl2ZU9wdGlvbiA9IHN0YXRlMi5hY3RpdmVPcHRpb25JbmRleCAhPT0gbnVsbCA/IHN0YXRlMi5vcHRpb25zW3N0YXRlMi5hY3RpdmVPcHRpb25JbmRleF0gOiBudWxsO1xuICBsZXQgc29ydGVkT3B0aW9ucyA9IHNvcnRCeURvbU5vZGUoYWRqdXN0bWVudChzdGF0ZTIub3B0aW9ucy5zbGljZSgpKSwgKG9wdGlvbikgPT4gb3B0aW9uLmRhdGFSZWYuY3VycmVudC5kb21SZWYuY3VycmVudCk7XG4gIGxldCBhZGp1c3RlZEFjdGl2ZU9wdGlvbkluZGV4ID0gY3VycmVudEFjdGl2ZU9wdGlvbiA/IHNvcnRlZE9wdGlvbnMuaW5kZXhPZihjdXJyZW50QWN0aXZlT3B0aW9uKSA6IG51bGw7XG4gIGlmIChhZGp1c3RlZEFjdGl2ZU9wdGlvbkluZGV4ID09PSAtMSkge1xuICAgIGFkanVzdGVkQWN0aXZlT3B0aW9uSW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9uczogc29ydGVkT3B0aW9ucyxcbiAgICBhY3RpdmVPcHRpb25JbmRleDogYWRqdXN0ZWRBY3RpdmVPcHRpb25JbmRleFxuICB9O1xufVxudmFyIHJlZHVjZXJzID0ge1xuICBbMSAvKiBDbG9zZUNvbWJvYm94ICovXShzdGF0ZTIpIHtcbiAgICBpZiAoc3RhdGUyLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZClcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgaWYgKHN0YXRlMi5jb21ib2JveFN0YXRlID09PSAxIC8qIENsb3NlZCAqLylcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBhY3RpdmVPcHRpb25JbmRleDogbnVsbCwgY29tYm9ib3hTdGF0ZTogMSAvKiBDbG9zZWQgKi8gfTtcbiAgfSxcbiAgWzAgLyogT3BlbkNvbWJvYm94ICovXShzdGF0ZTIpIHtcbiAgICBpZiAoc3RhdGUyLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZClcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgaWYgKHN0YXRlMi5jb21ib2JveFN0YXRlID09PSAwIC8qIE9wZW4gKi8pXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIGxldCBhY3RpdmVPcHRpb25JbmRleCA9IHN0YXRlMi5hY3RpdmVPcHRpb25JbmRleDtcbiAgICBsZXQgeyBpc1NlbGVjdGVkIH0gPSBzdGF0ZTIuZGF0YVJlZi5jdXJyZW50O1xuICAgIGxldCBvcHRpb25JZHggPSBzdGF0ZTIub3B0aW9ucy5maW5kSW5kZXgoKG9wdGlvbikgPT4gaXNTZWxlY3RlZChvcHRpb24uZGF0YVJlZi5jdXJyZW50LnZhbHVlKSk7XG4gICAgaWYgKG9wdGlvbklkeCAhPT0gLTEpIHtcbiAgICAgIGFjdGl2ZU9wdGlvbkluZGV4ID0gb3B0aW9uSWR4O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIGNvbWJvYm94U3RhdGU6IDAgLyogT3BlbiAqLywgYWN0aXZlT3B0aW9uSW5kZXggfTtcbiAgfSxcbiAgWzIgLyogR29Ub09wdGlvbiAqL10oc3RhdGUyLCBhY3Rpb24pIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmIChzdGF0ZTIuZGF0YVJlZi5jdXJyZW50LmRpc2FibGVkKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICBpZiAoc3RhdGUyLmRhdGFSZWYuY3VycmVudC5vcHRpb25zUmVmLmN1cnJlbnQgJiYgIXN0YXRlMi5kYXRhUmVmLmN1cnJlbnQub3B0aW9uc1Byb3BzUmVmLmN1cnJlbnQuc3RhdGljICYmIHN0YXRlMi5jb21ib2JveFN0YXRlID09PSAxIC8qIENsb3NlZCAqLykge1xuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICB9XG4gICAgbGV0IGFkanVzdGVkU3RhdGUgPSBhZGp1c3RPcmRlcmVkU3RhdGUoc3RhdGUyKTtcbiAgICBpZiAoYWRqdXN0ZWRTdGF0ZS5hY3RpdmVPcHRpb25JbmRleCA9PT0gbnVsbCkge1xuICAgICAgbGV0IGxvY2FsQWN0aXZlT3B0aW9uSW5kZXggPSBhZGp1c3RlZFN0YXRlLm9wdGlvbnMuZmluZEluZGV4KChvcHRpb24pID0+ICFvcHRpb24uZGF0YVJlZi5jdXJyZW50LmRpc2FibGVkKTtcbiAgICAgIGlmIChsb2NhbEFjdGl2ZU9wdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICBhZGp1c3RlZFN0YXRlLmFjdGl2ZU9wdGlvbkluZGV4ID0gbG9jYWxBY3RpdmVPcHRpb25JbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFjdGl2ZU9wdGlvbkluZGV4ID0gY2FsY3VsYXRlQWN0aXZlSW5kZXgoYWN0aW9uLCB7XG4gICAgICByZXNvbHZlSXRlbXM6ICgpID0+IGFkanVzdGVkU3RhdGUub3B0aW9ucyxcbiAgICAgIHJlc29sdmVBY3RpdmVJbmRleDogKCkgPT4gYWRqdXN0ZWRTdGF0ZS5hY3RpdmVPcHRpb25JbmRleCxcbiAgICAgIHJlc29sdmVJZDogKGl0ZW0pID0+IGl0ZW0uaWQsXG4gICAgICByZXNvbHZlRGlzYWJsZWQ6IChpdGVtKSA9PiBpdGVtLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZTIsXG4gICAgICAuLi5hZGp1c3RlZFN0YXRlLFxuICAgICAgYWN0aXZlT3B0aW9uSW5kZXgsXG4gICAgICBhY3RpdmF0aW9uVHJpZ2dlcjogKF9hMiA9IGFjdGlvbi50cmlnZ2VyKSAhPSBudWxsID8gX2EyIDogMSAvKiBPdGhlciAqL1xuICAgIH07XG4gIH0sXG4gIFszIC8qIFJlZ2lzdGVyT3B0aW9uICovXTogKHN0YXRlMiwgYWN0aW9uKSA9PiB7XG4gICAgbGV0IG9wdGlvbiA9IHsgaWQ6IGFjdGlvbi5pZCwgZGF0YVJlZjogYWN0aW9uLmRhdGFSZWYgfTtcbiAgICBsZXQgYWRqdXN0ZWRTdGF0ZSA9IGFkanVzdE9yZGVyZWRTdGF0ZShzdGF0ZTIsIChvcHRpb25zKSA9PiBbLi4ub3B0aW9ucywgb3B0aW9uXSk7XG4gICAgaWYgKHN0YXRlMi5hY3RpdmVPcHRpb25JbmRleCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlMi5kYXRhUmVmLmN1cnJlbnQuaXNTZWxlY3RlZChhY3Rpb24uZGF0YVJlZi5jdXJyZW50LnZhbHVlKSkge1xuICAgICAgICBhZGp1c3RlZFN0YXRlLmFjdGl2ZU9wdGlvbkluZGV4ID0gYWRqdXN0ZWRTdGF0ZS5vcHRpb25zLmluZGV4T2Yob3B0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHRTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlMixcbiAgICAgIC4uLmFkanVzdGVkU3RhdGUsXG4gICAgICBhY3RpdmF0aW9uVHJpZ2dlcjogMSAvKiBPdGhlciAqL1xuICAgIH07XG4gICAgaWYgKHN0YXRlMi5kYXRhUmVmLmN1cnJlbnQuX19kZW1vTW9kZSAmJiBzdGF0ZTIuZGF0YVJlZi5jdXJyZW50LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIG5leHRTdGF0ZS5hY3RpdmVPcHRpb25JbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG4gIFs0IC8qIFVucmVnaXN0ZXJPcHRpb24gKi9dOiAoc3RhdGUyLCBhY3Rpb24pID0+IHtcbiAgICBsZXQgYWRqdXN0ZWRTdGF0ZSA9IGFkanVzdE9yZGVyZWRTdGF0ZShzdGF0ZTIsIChvcHRpb25zKSA9PiB7XG4gICAgICBsZXQgaWR4ID0gb3B0aW9ucy5maW5kSW5kZXgoKGEpID0+IGEuaWQgPT09IGFjdGlvbi5pZCk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSlcbiAgICAgICAgb3B0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZTIsXG4gICAgICAuLi5hZGp1c3RlZFN0YXRlLFxuICAgICAgYWN0aXZhdGlvblRyaWdnZXI6IDEgLyogT3RoZXIgKi9cbiAgICB9O1xuICB9LFxuICBbNSAvKiBSZWdpc3RlckxhYmVsICovXTogKHN0YXRlMiwgYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlMixcbiAgICAgIGxhYmVsSWQ6IGFjdGlvbi5pZFxuICAgIH07XG4gIH1cbn07XG52YXIgQ29tYm9ib3hBY3Rpb25zQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QxNy5jcmVhdGVDb250ZXh0KShudWxsKTtcbkNvbWJvYm94QWN0aW9uc0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkNvbWJvYm94QWN0aW9uc0NvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZUFjdGlvbnMoY29tcG9uZW50KSB7XG4gIGxldCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZUNvbnRleHQpKENvbWJvYm94QWN0aW9uc0NvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoYDwke2NvbXBvbmVudH0gLz4gaXMgbWlzc2luZyBhIHBhcmVudCA8Q29tYm9ib3ggLz4gY29tcG9uZW50LmApO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdXNlQWN0aW9ucyk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIENvbWJvYm94RGF0YUNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MTcuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5Db21ib2JveERhdGFDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJDb21ib2JveERhdGFDb250ZXh0XCI7XG5mdW5jdGlvbiB1c2VEYXRhKGNvbXBvbmVudCkge1xuICBsZXQgY29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QxNy51c2VDb250ZXh0KShDb21ib2JveERhdGFDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICBsZXQgZXJyID0gbmV3IEVycm9yKGA8JHtjb21wb25lbnR9IC8+IGlzIG1pc3NpbmcgYSBwYXJlbnQgPENvbWJvYm94IC8+IGNvbXBvbmVudC5gKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHVzZURhdGEpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHN0YXRlUmVkdWNlcihzdGF0ZTIsIGFjdGlvbikge1xuICByZXR1cm4gbWF0Y2goYWN0aW9uLnR5cGUsIHJlZHVjZXJzLCBzdGF0ZTIsIGFjdGlvbik7XG59XG52YXIgREVGQVVMVF9DT01CT0JPWF9UQUcgPSBpbXBvcnRfcmVhY3QxNy5GcmFnbWVudDtcbmZ1bmN0aW9uIENvbWJvYm94Rm4ocHJvcHMsIHJlZikge1xuICBsZXQge1xuICAgIHZhbHVlOiBjb250cm9sbGVkVmFsdWUsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIG9uQ2hhbmdlOiBjb250cm9sbGVkT25DaGFuZ2UsXG4gICAgbmFtZSxcbiAgICBieSA9IChhLCB6KSA9PiBhID09PSB6LFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgX19kZW1vTW9kZSA9IGZhbHNlLFxuICAgIG51bGxhYmxlID0gZmFsc2UsXG4gICAgbXVsdGlwbGUgPSBmYWxzZSxcbiAgICAuLi50aGVpclByb3BzXG4gIH0gPSBwcm9wcztcbiAgbGV0IFt2YWx1ZSwgdGhlaXJPbkNoYW5nZV0gPSB1c2VDb250cm9sbGFibGUoY29udHJvbGxlZFZhbHVlLCBjb250cm9sbGVkT25DaGFuZ2UsIGRlZmF1bHRWYWx1ZSk7XG4gIGxldCBbc3RhdGUyLCBkaXNwYXRjaF0gPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlUmVkdWNlcikoc3RhdGVSZWR1Y2VyLCB7XG4gICAgZGF0YVJlZjogKDAsIGltcG9ydF9yZWFjdDE3LmNyZWF0ZVJlZikoKSxcbiAgICBjb21ib2JveFN0YXRlOiBfX2RlbW9Nb2RlID8gMCAvKiBPcGVuICovIDogMSAvKiBDbG9zZWQgKi8sXG4gICAgb3B0aW9uczogW10sXG4gICAgYWN0aXZlT3B0aW9uSW5kZXg6IG51bGwsXG4gICAgYWN0aXZhdGlvblRyaWdnZXI6IDEgLyogT3RoZXIgKi8sXG4gICAgbGFiZWxJZDogbnVsbFxuICB9KTtcbiAgbGV0IGRlZmF1bHRUb0ZpcnN0T3B0aW9uID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZVJlZikoZmFsc2UpO1xuICBsZXQgb3B0aW9uc1Byb3BzUmVmID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZVJlZikoeyBzdGF0aWM6IGZhbHNlLCBob2xkOiBmYWxzZSB9KTtcbiAgbGV0IGxhYmVsUmVmID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZVJlZikobnVsbCk7XG4gIGxldCBpbnB1dFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QxNy51c2VSZWYpKG51bGwpO1xuICBsZXQgYnV0dG9uUmVmID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZVJlZikobnVsbCk7XG4gIGxldCBvcHRpb25zUmVmID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZVJlZikobnVsbCk7XG4gIGxldCBjb21wYXJlID0gdXNlRXZlbnQodHlwZW9mIGJ5ID09PSBcInN0cmluZ1wiID8gKGEsIHopID0+IHtcbiAgICBsZXQgcHJvcGVydHkgPSBieTtcbiAgICByZXR1cm4gKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGFbcHJvcGVydHldKSA9PT0gKHogPT0gbnVsbCA/IHZvaWQgMCA6IHpbcHJvcGVydHldKTtcbiAgfSA6IGJ5KTtcbiAgbGV0IGlzU2VsZWN0ZWQgPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlQ2FsbGJhY2spKChjb21wYXJlVmFsdWUpID0+IG1hdGNoKGRhdGEubW9kZSwge1xuICAgIFsxIC8qIE11bHRpICovXTogKCkgPT4gdmFsdWUuc29tZSgob3B0aW9uKSA9PiBjb21wYXJlKG9wdGlvbiwgY29tcGFyZVZhbHVlKSksXG4gICAgWzAgLyogU2luZ2xlICovXTogKCkgPT4gY29tcGFyZSh2YWx1ZSwgY29tcGFyZVZhbHVlKVxuICB9KSwgW3ZhbHVlXSk7XG4gIGxldCBkYXRhID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZU1lbW8pKCgpID0+ICh7XG4gICAgLi4uc3RhdGUyLFxuICAgIG9wdGlvbnNQcm9wc1JlZixcbiAgICBsYWJlbFJlZixcbiAgICBpbnB1dFJlZixcbiAgICBidXR0b25SZWYsXG4gICAgb3B0aW9uc1JlZixcbiAgICB2YWx1ZSxcbiAgICBkaXNhYmxlZCxcbiAgICBtb2RlOiBtdWx0aXBsZSA/IDEgLyogTXVsdGkgKi8gOiAwIC8qIFNpbmdsZSAqLyxcbiAgICBnZXQgYWN0aXZlT3B0aW9uSW5kZXgoKSB7XG4gICAgICBpZiAoZGVmYXVsdFRvRmlyc3RPcHRpb24uY3VycmVudCAmJiBzdGF0ZTIuYWN0aXZlT3B0aW9uSW5kZXggPT09IG51bGwgJiYgc3RhdGUyLm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgbG9jYWxBY3RpdmVPcHRpb25JbmRleCA9IHN0YXRlMi5vcHRpb25zLmZpbmRJbmRleCgob3B0aW9uKSA9PiAhb3B0aW9uLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZCk7XG4gICAgICAgIGlmIChsb2NhbEFjdGl2ZU9wdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbEFjdGl2ZU9wdGlvbkluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUyLmFjdGl2ZU9wdGlvbkluZGV4O1xuICAgIH0sXG4gICAgY29tcGFyZSxcbiAgICBpc1NlbGVjdGVkLFxuICAgIG51bGxhYmxlLFxuICAgIF9fZGVtb01vZGVcbiAgfSksIFt2YWx1ZSwgZGlzYWJsZWQsIG11bHRpcGxlLCBudWxsYWJsZSwgX19kZW1vTW9kZSwgc3RhdGUyXSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIHN0YXRlMi5kYXRhUmVmLmN1cnJlbnQgPSBkYXRhO1xuICB9LCBbZGF0YV0pO1xuICB1c2VPdXRzaWRlQ2xpY2soW2RhdGEuYnV0dG9uUmVmLCBkYXRhLmlucHV0UmVmLCBkYXRhLm9wdGlvbnNSZWZdLCAoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDEgLyogQ2xvc2VDb21ib2JveCAqLyB9KSwgZGF0YS5jb21ib2JveFN0YXRlID09PSAwIC8qIE9wZW4gKi8pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QxNy51c2VNZW1vKSgoKSA9PiAoe1xuICAgIG9wZW46IGRhdGEuY29tYm9ib3hTdGF0ZSA9PT0gMCAvKiBPcGVuICovLFxuICAgIGRpc2FibGVkLFxuICAgIGFjdGl2ZUluZGV4OiBkYXRhLmFjdGl2ZU9wdGlvbkluZGV4LFxuICAgIGFjdGl2ZU9wdGlvbjogZGF0YS5hY3RpdmVPcHRpb25JbmRleCA9PT0gbnVsbCA/IG51bGwgOiBkYXRhLm9wdGlvbnNbZGF0YS5hY3RpdmVPcHRpb25JbmRleF0uZGF0YVJlZi5jdXJyZW50LnZhbHVlLFxuICAgIHZhbHVlXG4gIH0pLCBbZGF0YSwgZGlzYWJsZWQsIHZhbHVlXSk7XG4gIGxldCBzZWxlY3RPcHRpb24gPSB1c2VFdmVudCgoaWQyKSA9PiB7XG4gICAgbGV0IG9wdGlvbiA9IGRhdGEub3B0aW9ucy5maW5kKChpdGVtKSA9PiBpdGVtLmlkID09PSBpZDIpO1xuICAgIGlmICghb3B0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIG9uQ2hhbmdlKG9wdGlvbi5kYXRhUmVmLmN1cnJlbnQudmFsdWUpO1xuICB9KTtcbiAgbGV0IHNlbGVjdEFjdGl2ZU9wdGlvbiA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICBpZiAoZGF0YS5hY3RpdmVPcHRpb25JbmRleCAhPT0gbnVsbCkge1xuICAgICAgbGV0IHsgZGF0YVJlZiwgaWQ6IGlkMiB9ID0gZGF0YS5vcHRpb25zW2RhdGEuYWN0aXZlT3B0aW9uSW5kZXhdO1xuICAgICAgb25DaGFuZ2UoZGF0YVJlZi5jdXJyZW50LnZhbHVlKTtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogMiAvKiBHb1RvT3B0aW9uICovLCBmb2N1czogNCAvKiBTcGVjaWZpYyAqLywgaWQ6IGlkMiB9KTtcbiAgICB9XG4gIH0pO1xuICBsZXQgb3BlbkNvbWJvYm94ID0gdXNlRXZlbnQoKCkgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogMCAvKiBPcGVuQ29tYm9ib3ggKi8gfSk7XG4gICAgZGVmYXVsdFRvRmlyc3RPcHRpb24uY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgY2xvc2VDb21ib2JveCA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IDEgLyogQ2xvc2VDb21ib2JveCAqLyB9KTtcbiAgICBkZWZhdWx0VG9GaXJzdE9wdGlvbi5jdXJyZW50ID0gZmFsc2U7XG4gIH0pO1xuICBsZXQgZ29Ub09wdGlvbiA9IHVzZUV2ZW50KChmb2N1cywgaWQyLCB0cmlnZ2VyKSA9PiB7XG4gICAgZGVmYXVsdFRvRmlyc3RPcHRpb24uY3VycmVudCA9IGZhbHNlO1xuICAgIGlmIChmb2N1cyA9PT0gNCAvKiBTcGVjaWZpYyAqLykge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHsgdHlwZTogMiAvKiBHb1RvT3B0aW9uICovLCBmb2N1czogNCAvKiBTcGVjaWZpYyAqLywgaWQ6IGlkMiwgdHJpZ2dlciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BhdGNoKHsgdHlwZTogMiAvKiBHb1RvT3B0aW9uICovLCBmb2N1cywgdHJpZ2dlciB9KTtcbiAgfSk7XG4gIGxldCByZWdpc3Rlck9wdGlvbiA9IHVzZUV2ZW50KChpZDIsIGRhdGFSZWYpID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IDMgLyogUmVnaXN0ZXJPcHRpb24gKi8sIGlkOiBpZDIsIGRhdGFSZWYgfSk7XG4gICAgcmV0dXJuICgpID0+IGRpc3BhdGNoKHsgdHlwZTogNCAvKiBVbnJlZ2lzdGVyT3B0aW9uICovLCBpZDogaWQyIH0pO1xuICB9KTtcbiAgbGV0IHJlZ2lzdGVyTGFiZWwgPSB1c2VFdmVudCgoaWQyKSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiA1IC8qIFJlZ2lzdGVyTGFiZWwgKi8sIGlkOiBpZDIgfSk7XG4gICAgcmV0dXJuICgpID0+IGRpc3BhdGNoKHsgdHlwZTogNSAvKiBSZWdpc3RlckxhYmVsICovLCBpZDogbnVsbCB9KTtcbiAgfSk7XG4gIGxldCBvbkNoYW5nZSA9IHVzZUV2ZW50KCh2YWx1ZTIpID0+IHtcbiAgICByZXR1cm4gbWF0Y2goZGF0YS5tb2RlLCB7XG4gICAgICBbMCAvKiBTaW5nbGUgKi9dKCkge1xuICAgICAgICByZXR1cm4gdGhlaXJPbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGhlaXJPbkNoYW5nZSh2YWx1ZTIpO1xuICAgICAgfSxcbiAgICAgIFsxIC8qIE11bHRpICovXSgpIHtcbiAgICAgICAgbGV0IGNvcHkgPSBkYXRhLnZhbHVlLnNsaWNlKCk7XG4gICAgICAgIGxldCBpZHggPSBjb3B5LmZpbmRJbmRleCgoaXRlbSkgPT4gY29tcGFyZShpdGVtLCB2YWx1ZTIpKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICBjb3B5LnB1c2godmFsdWUyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5LnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVpck9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0aGVpck9uQ2hhbmdlKGNvcHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgbGV0IGFjdGlvbnMgPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlTWVtbykoKCkgPT4gKHtcbiAgICBvbkNoYW5nZSxcbiAgICByZWdpc3Rlck9wdGlvbixcbiAgICByZWdpc3RlckxhYmVsLFxuICAgIGdvVG9PcHRpb24sXG4gICAgY2xvc2VDb21ib2JveCxcbiAgICBvcGVuQ29tYm9ib3gsXG4gICAgc2VsZWN0QWN0aXZlT3B0aW9uLFxuICAgIHNlbGVjdE9wdGlvblxuICB9KSwgW10pO1xuICBsZXQgb3VyUHJvcHMgPSByZWYgPT09IG51bGwgPyB7fSA6IHsgcmVmIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTcuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbWJvYm94QWN0aW9uc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYWN0aW9uc1xuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTcuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbWJvYm94RGF0YUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGF0YVxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTcuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE9wZW5DbG9zZWRQcm92aWRlciwge1xuICAgIHZhbHVlOiBtYXRjaChkYXRhLmNvbWJvYm94U3RhdGUsIHtcbiAgICAgIFswIC8qIE9wZW4gKi9dOiAwIC8qIE9wZW4gKi8sXG4gICAgICBbMSAvKiBDbG9zZWQgKi9dOiAxIC8qIENsb3NlZCAqL1xuICAgIH0pXG4gIH0sIG5hbWUgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsICYmIG9iamVjdFRvRm9ybUVudHJpZXMoeyBbbmFtZV06IHZhbHVlIH0pLm1hcCgoW25hbWUyLCB2YWx1ZTJdKSA9PiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTcuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhpZGRlbiwge1xuICAgIGZlYXR1cmVzOiA0IC8qIEhpZGRlbiAqLyxcbiAgICAuLi5jb21wYWN0KHtcbiAgICAgIGtleTogbmFtZTIsXG4gICAgICBhczogXCJpbnB1dFwiLFxuICAgICAgdHlwZTogXCJoaWRkZW5cIixcbiAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgbmFtZTogbmFtZTIsXG4gICAgICB2YWx1ZTogdmFsdWUyXG4gICAgfSlcbiAgfSkpLCByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX0NPTUJPQk9YX1RBRyxcbiAgICBuYW1lOiBcIkNvbWJvYm94XCJcbiAgfSkpKSk7XG59XG52YXIgQ29tYm9ib3hSb290ID0gZm9yd2FyZFJlZldpdGhBcyhDb21ib2JveEZuKTtcbnZhciBERUZBVUxUX0lOUFVUX1RBRyA9IFwiaW5wdXRcIjtcbnZhciBJbnB1dCA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gSW5wdXQyKHByb3BzLCByZWYpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIGxldCB7IHZhbHVlLCBvbkNoYW5nZSwgZGlzcGxheVZhbHVlLCB0eXBlID0gXCJ0ZXh0XCIsIC4uLnRoZWlyUHJvcHMgfSA9IHByb3BzO1xuICBsZXQgZGF0YSA9IHVzZURhdGEoXCJDb21ib2JveC5JbnB1dFwiKTtcbiAgbGV0IGFjdGlvbnMgPSB1c2VBY3Rpb25zKFwiQ29tYm9ib3guSW5wdXRcIik7XG4gIGxldCBpbnB1dFJlZiA9IHVzZVN5bmNSZWZzKGRhdGEuaW5wdXRSZWYsIHJlZik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1jb21ib2JveC1pbnB1dC0ke3VzZUlkKCl9YDtcbiAgbGV0IGQgPSB1c2VEaXNwb3NhYmxlcygpO1xuICBsZXQgY3VycmVudFZhbHVlID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZU1lbW8pKCgpID0+IHtcbiAgICB2YXIgX2EzO1xuICAgIGlmICh0eXBlb2YgZGlzcGxheVZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiAoX2EzID0gZGlzcGxheVZhbHVlKGRhdGEudmFsdWUpKSAhPSBudWxsID8gX2EzIDogXCJcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLnZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9LCBbZGF0YS52YWx1ZV0pO1xuICB1c2VXYXRjaCgoW2N1cnJlbnRWYWx1ZTIsIHN0YXRlMl0sIFtvbGRDdXJyZW50VmFsdWUsIG9sZFN0YXRlXSkgPT4ge1xuICAgIGlmICghZGF0YS5pbnB1dFJlZi5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChvbGRTdGF0ZSA9PT0gMCAvKiBPcGVuICovICYmIHN0YXRlMiA9PT0gMSAvKiBDbG9zZWQgKi8pIHtcbiAgICAgIGRhdGEuaW5wdXRSZWYuY3VycmVudC52YWx1ZSA9IGN1cnJlbnRWYWx1ZTI7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUyICE9PSBvbGRDdXJyZW50VmFsdWUpIHtcbiAgICAgIGRhdGEuaW5wdXRSZWYuY3VycmVudC52YWx1ZSA9IGN1cnJlbnRWYWx1ZTI7XG4gICAgfVxuICB9LCBbY3VycmVudFZhbHVlLCBkYXRhLmNvbWJvYm94U3RhdGVdKTtcbiAgbGV0IGhhbmRsZUtleURvd24gPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiIC8qIEJhY2tzcGFjZSAqLzpcbiAgICAgIGNhc2UgXCJEZWxldGVcIiAvKiBEZWxldGUgKi86XG4gICAgICAgIGlmIChkYXRhLm1vZGUgIT09IDAgLyogU2luZ2xlICovKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFkYXRhLm51bGxhYmxlKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGlucHV0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgZC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgYWN0aW9ucy5vbkNoYW5nZShudWxsKTtcbiAgICAgICAgICAgIGlmIChkYXRhLm9wdGlvbnNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBkYXRhLm9wdGlvbnNSZWYuY3VycmVudC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9ucy5nb1RvT3B0aW9uKDUgLyogTm90aGluZyAqLyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRW50ZXJcIiAvKiBFbnRlciAqLzpcbiAgICAgICAgaWYgKGRhdGEuY29tYm9ib3hTdGF0ZSAhPT0gMCAvKiBPcGVuICovKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50Lm5hdGl2ZUV2ZW50LmlzQ29tcG9zaW5nKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChkYXRhLmFjdGl2ZU9wdGlvbkluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgYWN0aW9ucy5jbG9zZUNvbWJvYm94KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnMuc2VsZWN0QWN0aXZlT3B0aW9uKCk7XG4gICAgICAgIGlmIChkYXRhLm1vZGUgPT09IDAgLyogU2luZ2xlICovKSB7XG4gICAgICAgICAgYWN0aW9ucy5jbG9zZUNvbWJvYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCIgLyogQXJyb3dEb3duICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoKGRhdGEuY29tYm9ib3hTdGF0ZSwge1xuICAgICAgICAgIFswIC8qIE9wZW4gKi9dOiAoKSA9PiB7XG4gICAgICAgICAgICBhY3Rpb25zLmdvVG9PcHRpb24oMiAvKiBOZXh0ICovKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFsxIC8qIENsb3NlZCAqL106ICgpID0+IHtcbiAgICAgICAgICAgIGFjdGlvbnMub3BlbkNvbWJvYm94KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCIgLyogQXJyb3dVcCAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBtYXRjaChkYXRhLmNvbWJvYm94U3RhdGUsIHtcbiAgICAgICAgICBbMCAvKiBPcGVuICovXTogKCkgPT4ge1xuICAgICAgICAgICAgYWN0aW9ucy5nb1RvT3B0aW9uKDEgLyogUHJldmlvdXMgKi8pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgWzEgLyogQ2xvc2VkICovXTogKCkgPT4ge1xuICAgICAgICAgICAgYWN0aW9ucy5vcGVuQ29tYm9ib3goKTtcbiAgICAgICAgICAgIGQubmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucy5nb1RvT3B0aW9uKDMgLyogTGFzdCAqLyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiSG9tZVwiIC8qIEhvbWUgKi86XG4gICAgICBjYXNlIFwiUGFnZVVwXCIgLyogUGFnZVVwICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnMuZ29Ub09wdGlvbigwIC8qIEZpcnN0ICovKTtcbiAgICAgIGNhc2UgXCJFbmRcIiAvKiBFbmQgKi86XG4gICAgICBjYXNlIFwiUGFnZURvd25cIiAvKiBQYWdlRG93biAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBhY3Rpb25zLmdvVG9PcHRpb24oMyAvKiBMYXN0ICovKTtcbiAgICAgIGNhc2UgXCJFc2NhcGVcIiAvKiBFc2NhcGUgKi86XG4gICAgICAgIGlmIChkYXRhLmNvbWJvYm94U3RhdGUgIT09IDAgLyogT3BlbiAqLylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnNSZWYuY3VycmVudCAmJiAhZGF0YS5vcHRpb25zUHJvcHNSZWYuY3VycmVudC5zdGF0aWMpIHtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucy5jbG9zZUNvbWJvYm94KCk7XG4gICAgICBjYXNlIFwiVGFiXCIgLyogVGFiICovOlxuICAgICAgICBpZiAoZGF0YS5jb21ib2JveFN0YXRlICE9PSAwIC8qIE9wZW4gKi8pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZGF0YS5tb2RlID09PSAwIC8qIFNpbmdsZSAqLylcbiAgICAgICAgICBhY3Rpb25zLnNlbGVjdEFjdGl2ZU9wdGlvbigpO1xuICAgICAgICBhY3Rpb25zLmNsb3NlQ29tYm9ib3goKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUNoYW5nZSA9IHVzZUV2ZW50KChldmVudCkgPT4ge1xuICAgIGFjdGlvbnMub3BlbkNvbWJvYm94KCk7XG4gICAgb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2hhbmdlKGV2ZW50KTtcbiAgfSk7XG4gIGxldCBsYWJlbGxlZGJ5ID0gdXNlQ29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmICghZGF0YS5sYWJlbElkKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gW2RhdGEubGFiZWxJZF0uam9pbihcIiBcIik7XG4gIH0sIFtkYXRhLmxhYmVsSWRdKTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlTWVtbykoKCkgPT4gKHsgb3BlbjogZGF0YS5jb21ib2JveFN0YXRlID09PSAwIC8qIE9wZW4gKi8sIGRpc2FibGVkOiBkYXRhLmRpc2FibGVkIH0pLCBbZGF0YV0pO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgcmVmOiBpbnB1dFJlZixcbiAgICBpZDogaWQyLFxuICAgIHJvbGU6IFwiY29tYm9ib3hcIixcbiAgICB0eXBlLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiAoX2EyID0gZGF0YS5vcHRpb25zUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaWQsXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6IGRhdGEuZGlzYWJsZWQgPyB2b2lkIDAgOiBkYXRhLmNvbWJvYm94U3RhdGUgPT09IDAgLyogT3BlbiAqLyxcbiAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiBkYXRhLmFjdGl2ZU9wdGlvbkluZGV4ID09PSBudWxsID8gdm9pZCAwIDogKF9iID0gZGF0YS5vcHRpb25zW2RhdGEuYWN0aXZlT3B0aW9uSW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaWQsXG4gICAgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiBkYXRhLm1vZGUgPT09IDEgLyogTXVsdGkgKi8gPyB0cnVlIDogdm9pZCAwLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkYnksXG4gICAgZGlzYWJsZWQ6IGRhdGEuZGlzYWJsZWQsXG4gICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2VcbiAgfTtcbiAgcmV0dXJuIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfSU5QVVRfVEFHLFxuICAgIG5hbWU6IFwiQ29tYm9ib3guSW5wdXRcIlxuICB9KTtcbn0pO1xudmFyIERFRkFVTFRfQlVUVE9OX1RBRyA9IFwiYnV0dG9uXCI7XG52YXIgQnV0dG9uID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBCdXR0b24yKHByb3BzLCByZWYpIHtcbiAgdmFyIF9hMjtcbiAgbGV0IGRhdGEgPSB1c2VEYXRhKFwiQ29tYm9ib3guQnV0dG9uXCIpO1xuICBsZXQgYWN0aW9ucyA9IHVzZUFjdGlvbnMoXCJDb21ib2JveC5CdXR0b25cIik7XG4gIGxldCBidXR0b25SZWYgPSB1c2VTeW5jUmVmcyhkYXRhLmJ1dHRvblJlZiwgcmVmKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLWNvbWJvYm94LWJ1dHRvbi0ke3VzZUlkKCl9YDtcbiAgbGV0IGQgPSB1c2VEaXNwb3NhYmxlcygpO1xuICBsZXQgaGFuZGxlS2V5RG93biA9IHVzZUV2ZW50KChldmVudCkgPT4ge1xuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCIgLyogQXJyb3dEb3duICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKGRhdGEuY29tYm9ib3hTdGF0ZSA9PT0gMSAvKiBDbG9zZWQgKi8pIHtcbiAgICAgICAgICBhY3Rpb25zLm9wZW5Db21ib2JveCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkLm5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICByZXR1cm4gKF9hMyA9IGRhdGEuaW5wdXRSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcIkFycm93VXBcIiAvKiBBcnJvd1VwICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKGRhdGEuY29tYm9ib3hTdGF0ZSA9PT0gMSAvKiBDbG9zZWQgKi8pIHtcbiAgICAgICAgICBhY3Rpb25zLm9wZW5Db21ib2JveCgpO1xuICAgICAgICAgIGQubmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgICBhY3Rpb25zLmdvVG9PcHRpb24oMyAvKiBMYXN0ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZC5uZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgcmV0dXJuIChfYTMgPSBkYXRhLmlucHV0UmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJFc2NhcGVcIiAvKiBFc2NhcGUgKi86XG4gICAgICAgIGlmIChkYXRhLmNvbWJvYm94U3RhdGUgIT09IDAgLyogT3BlbiAqLylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnNSZWYuY3VycmVudCAmJiAhZGF0YS5vcHRpb25zUHJvcHNSZWYuY3VycmVudC5zdGF0aWMpIHtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25zLmNsb3NlQ29tYm9ib3goKTtcbiAgICAgICAgcmV0dXJuIGQubmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgIHJldHVybiAoX2EzID0gZGF0YS5pbnB1dFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUNsaWNrID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGlzRGlzYWJsZWRSZWFjdElzc3VlNzcxMShldmVudC5jdXJyZW50VGFyZ2V0KSlcbiAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChkYXRhLmNvbWJvYm94U3RhdGUgPT09IDAgLyogT3BlbiAqLykge1xuICAgICAgYWN0aW9ucy5jbG9zZUNvbWJvYm94KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBhY3Rpb25zLm9wZW5Db21ib2JveCgpO1xuICAgIH1cbiAgICBkLm5leHRGcmFtZSgoKSA9PiB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgcmV0dXJuIChfYTMgPSBkYXRhLmlucHV0UmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgbGV0IGxhYmVsbGVkYnkgPSB1c2VDb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKCFkYXRhLmxhYmVsSWQpXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBbZGF0YS5sYWJlbElkLCBpZDJdLmpvaW4oXCIgXCIpO1xuICB9LCBbZGF0YS5sYWJlbElkLCBpZDJdKTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlTWVtbykoKCkgPT4gKHtcbiAgICBvcGVuOiBkYXRhLmNvbWJvYm94U3RhdGUgPT09IDAgLyogT3BlbiAqLyxcbiAgICBkaXNhYmxlZDogZGF0YS5kaXNhYmxlZCxcbiAgICB2YWx1ZTogZGF0YS52YWx1ZVxuICB9KSwgW2RhdGFdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0ge1xuICAgIHJlZjogYnV0dG9uUmVmLFxuICAgIGlkOiBpZDIsXG4gICAgdHlwZTogdXNlUmVzb2x2ZUJ1dHRvblR5cGUocHJvcHMsIGRhdGEuYnV0dG9uUmVmKSxcbiAgICB0YWJJbmRleDogLTEsXG4gICAgXCJhcmlhLWhhc3BvcHVwXCI6IHRydWUsXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IChfYTIgPSBkYXRhLm9wdGlvbnNSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pZCxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogZGF0YS5kaXNhYmxlZCA/IHZvaWQgMCA6IGRhdGEuY29tYm9ib3hTdGF0ZSA9PT0gMCAvKiBPcGVuICovLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkYnksXG4gICAgZGlzYWJsZWQ6IGRhdGEuZGlzYWJsZWQsXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duXG4gIH07XG4gIHJldHVybiByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX0JVVFRPTl9UQUcsXG4gICAgbmFtZTogXCJDb21ib2JveC5CdXR0b25cIlxuICB9KTtcbn0pO1xudmFyIERFRkFVTFRfTEFCRUxfVEFHID0gXCJsYWJlbFwiO1xudmFyIExhYmVsID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBMYWJlbDIocHJvcHMsIHJlZikge1xuICBsZXQgZGF0YSA9IHVzZURhdGEoXCJDb21ib2JveC5MYWJlbFwiKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLWNvbWJvYm94LWxhYmVsLSR7dXNlSWQoKX1gO1xuICBsZXQgYWN0aW9ucyA9IHVzZUFjdGlvbnMoXCJDb21ib2JveC5MYWJlbFwiKTtcbiAgbGV0IGxhYmVsUmVmID0gdXNlU3luY1JlZnMoZGF0YS5sYWJlbFJlZiwgcmVmKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiBhY3Rpb25zLnJlZ2lzdGVyTGFiZWwoaWQyKSwgW2lkMl0pO1xuICBsZXQgaGFuZGxlQ2xpY2sgPSB1c2VFdmVudCgoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IGRhdGEuaW5wdXRSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gIH0pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QxNy51c2VNZW1vKSgoKSA9PiAoeyBvcGVuOiBkYXRhLmNvbWJvYm94U3RhdGUgPT09IDAgLyogT3BlbiAqLywgZGlzYWJsZWQ6IGRhdGEuZGlzYWJsZWQgfSksIFtkYXRhXSk7XG4gIGxldCB0aGVpclByb3BzID0gcHJvcHM7XG4gIGxldCBvdXJQcm9wcyA9IHsgcmVmOiBsYWJlbFJlZiwgaWQ6IGlkMiwgb25DbGljazogaGFuZGxlQ2xpY2sgfTtcbiAgcmV0dXJuIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfTEFCRUxfVEFHLFxuICAgIG5hbWU6IFwiQ29tYm9ib3guTGFiZWxcIlxuICB9KTtcbn0pO1xudmFyIERFRkFVTFRfT1BUSU9OU19UQUcgPSBcInVsXCI7XG52YXIgT3B0aW9uc1JlbmRlckZlYXR1cmVzID0gMSAvKiBSZW5kZXJTdHJhdGVneSAqLyB8IDIgLyogU3RhdGljICovO1xudmFyIE9wdGlvbnMgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIE9wdGlvbnMyKHByb3BzLCByZWYpIHtcbiAgdmFyIF9hMjtcbiAgbGV0IHsgaG9sZCA9IGZhbHNlLCAuLi50aGVpclByb3BzIH0gPSBwcm9wcztcbiAgbGV0IGRhdGEgPSB1c2VEYXRhKFwiQ29tYm9ib3guT3B0aW9uc1wiKTtcbiAgbGV0IG9wdGlvbnNSZWYgPSB1c2VTeW5jUmVmcyhkYXRhLm9wdGlvbnNSZWYsIHJlZik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1jb21ib2JveC1vcHRpb25zLSR7dXNlSWQoKX1gO1xuICBsZXQgdXNlc09wZW5DbG9zZWRTdGF0ZSA9IHVzZU9wZW5DbG9zZWQoKTtcbiAgbGV0IHZpc2libGUgPSAoKCkgPT4ge1xuICAgIGlmICh1c2VzT3BlbkNsb3NlZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdXNlc09wZW5DbG9zZWRTdGF0ZSA9PT0gMCAvKiBPcGVuICovO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5jb21ib2JveFN0YXRlID09PSAwIC8qIE9wZW4gKi87XG4gIH0pKCk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfYTM7XG4gICAgZGF0YS5vcHRpb25zUHJvcHNSZWYuY3VycmVudC5zdGF0aWMgPSAoX2EzID0gcHJvcHMuc3RhdGljKSAhPSBudWxsID8gX2EzIDogZmFsc2U7XG4gIH0sIFtkYXRhLm9wdGlvbnNQcm9wc1JlZiwgcHJvcHMuc3RhdGljXSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIGRhdGEub3B0aW9uc1Byb3BzUmVmLmN1cnJlbnQuaG9sZCA9IGhvbGQ7XG4gIH0sIFtkYXRhLm9wdGlvbnNQcm9wc1JlZiwgaG9sZF0pO1xuICB1c2VUcmVlV2Fsa2VyKHtcbiAgICBjb250YWluZXI6IGRhdGEub3B0aW9uc1JlZi5jdXJyZW50LFxuICAgIGVuYWJsZWQ6IGRhdGEuY29tYm9ib3hTdGF0ZSA9PT0gMCAvKiBPcGVuICovLFxuICAgIGFjY2VwdChub2RlKSB7XG4gICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcIm9wdGlvblwiKVxuICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKFwicm9sZVwiKSlcbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH0sXG4gICAgd2Fsayhub2RlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJub25lXCIpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBsYWJlbGxlZGJ5ID0gdXNlQ29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYTMsIF9iO1xuICAgIHJldHVybiAoX2IgPSBkYXRhLmxhYmVsSWQpICE9IG51bGwgPyBfYiA6IChfYTMgPSBkYXRhLmJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmlkO1xuICB9LCBbZGF0YS5sYWJlbElkLCBkYXRhLmJ1dHRvblJlZi5jdXJyZW50XSk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IGRhdGEuY29tYm9ib3hTdGF0ZSA9PT0gMCAvKiBPcGVuICovIH0pLCBbZGF0YV0pO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogZGF0YS5hY3RpdmVPcHRpb25JbmRleCA9PT0gbnVsbCA/IHZvaWQgMCA6IChfYTIgPSBkYXRhLm9wdGlvbnNbZGF0YS5hY3RpdmVPcHRpb25JbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaWQsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRieSxcbiAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICBpZDogaWQyLFxuICAgIHJlZjogb3B0aW9uc1JlZlxuICB9O1xuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9PUFRJT05TX1RBRyxcbiAgICBmZWF0dXJlczogT3B0aW9uc1JlbmRlckZlYXR1cmVzLFxuICAgIHZpc2libGUsXG4gICAgbmFtZTogXCJDb21ib2JveC5PcHRpb25zXCJcbiAgfSk7XG59KTtcbnZhciBERUZBVUxUX09QVElPTl9UQUcgPSBcImxpXCI7XG52YXIgT3B0aW9uID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBPcHRpb24yKHByb3BzLCByZWYpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIGxldCB7IGRpc2FibGVkID0gZmFsc2UsIHZhbHVlLCAuLi50aGVpclByb3BzIH0gPSBwcm9wcztcbiAgbGV0IGRhdGEgPSB1c2VEYXRhKFwiQ29tYm9ib3guT3B0aW9uXCIpO1xuICBsZXQgYWN0aW9ucyA9IHVzZUFjdGlvbnMoXCJDb21ib2JveC5PcHRpb25cIik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1jb21ib2JveC1vcHRpb24tJHt1c2VJZCgpfWA7XG4gIGxldCBhY3RpdmUgPSBkYXRhLmFjdGl2ZU9wdGlvbkluZGV4ICE9PSBudWxsID8gZGF0YS5vcHRpb25zW2RhdGEuYWN0aXZlT3B0aW9uSW5kZXhdLmlkID09PSBpZDIgOiBmYWxzZTtcbiAgbGV0IHNlbGVjdGVkID0gZGF0YS5pc1NlbGVjdGVkKHZhbHVlKTtcbiAgbGV0IGludGVybmFsT3B0aW9uUmVmID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZVJlZikobnVsbCk7XG4gIGxldCBiYWcgPSB1c2VMYXRlc3RWYWx1ZSh7XG4gICAgZGlzYWJsZWQsXG4gICAgdmFsdWUsXG4gICAgZG9tUmVmOiBpbnRlcm5hbE9wdGlvblJlZixcbiAgICB0ZXh0VmFsdWU6IChfYiA9IChfYTIgPSBpbnRlcm5hbE9wdGlvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRleHRDb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKVxuICB9KTtcbiAgbGV0IG9wdGlvblJlZiA9IHVzZVN5bmNSZWZzKHJlZiwgaW50ZXJuYWxPcHRpb25SZWYpO1xuICBsZXQgc2VsZWN0ID0gdXNlRXZlbnQoKCkgPT4gYWN0aW9ucy5zZWxlY3RPcHRpb24oaWQyKSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4gYWN0aW9ucy5yZWdpc3Rlck9wdGlvbihpZDIsIGJhZyksIFtiYWcsIGlkMl0pO1xuICBsZXQgZW5hYmxlU2Nyb2xsSW50b1ZpZXcgPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlUmVmKShkYXRhLl9fZGVtb01vZGUgPyBmYWxzZSA6IHRydWUpO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRhdGEuX19kZW1vTW9kZSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZCA9IGRpc3Bvc2FibGVzKCk7XG4gICAgZC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZW5hYmxlU2Nyb2xsSW50b1ZpZXcuY3VycmVudCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGQuZGlzcG9zZTtcbiAgfSwgW10pO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGF0YS5jb21ib2JveFN0YXRlICE9PSAwIC8qIE9wZW4gKi8pXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFhY3RpdmUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFlbmFibGVTY3JvbGxJbnRvVmlldy5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChkYXRhLmFjdGl2YXRpb25UcmlnZ2VyID09PSAwIC8qIFBvaW50ZXIgKi8pXG4gICAgICByZXR1cm47XG4gICAgbGV0IGQgPSBkaXNwb3NhYmxlcygpO1xuICAgIGQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHZhciBfYTMsIF9iMjtcbiAgICAgIChfYjIgPSAoX2EzID0gaW50ZXJuYWxPcHRpb25SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5zY3JvbGxJbnRvVmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5jYWxsKF9hMywgeyBibG9jazogXCJuZWFyZXN0XCIgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGQuZGlzcG9zZTtcbiAgfSwgW2ludGVybmFsT3B0aW9uUmVmLCBhY3RpdmUsIGRhdGEuY29tYm9ib3hTdGF0ZSwgZGF0YS5hY3RpdmF0aW9uVHJpZ2dlciwgZGF0YS5hY3RpdmVPcHRpb25JbmRleF0pO1xuICBsZXQgaGFuZGxlQ2xpY2sgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpXG4gICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBzZWxlY3QoKTtcbiAgICBpZiAoZGF0YS5tb2RlID09PSAwIC8qIFNpbmdsZSAqLykge1xuICAgICAgYWN0aW9ucy5jbG9zZUNvbWJvYm94KCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUZvY3VzID0gdXNlRXZlbnQoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZClcbiAgICAgIHJldHVybiBhY3Rpb25zLmdvVG9PcHRpb24oNSAvKiBOb3RoaW5nICovKTtcbiAgICBhY3Rpb25zLmdvVG9PcHRpb24oNCAvKiBTcGVjaWZpYyAqLywgaWQyKTtcbiAgfSk7XG4gIGxldCBoYW5kbGVNb3ZlID0gdXNlRXZlbnQoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoYWN0aXZlKVxuICAgICAgcmV0dXJuO1xuICAgIGFjdGlvbnMuZ29Ub09wdGlvbig0IC8qIFNwZWNpZmljICovLCBpZDIsIDAgLyogUG9pbnRlciAqLyk7XG4gIH0pO1xuICBsZXQgaGFuZGxlTGVhdmUgPSB1c2VFdmVudCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChkYXRhLm9wdGlvbnNQcm9wc1JlZi5jdXJyZW50LmhvbGQpXG4gICAgICByZXR1cm47XG4gICAgYWN0aW9ucy5nb1RvT3B0aW9uKDUgLyogTm90aGluZyAqLyk7XG4gIH0pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QxNy51c2VNZW1vKSgoKSA9PiAoeyBhY3RpdmUsIHNlbGVjdGVkLCBkaXNhYmxlZCB9KSwgW2FjdGl2ZSwgc2VsZWN0ZWQsIGRpc2FibGVkXSk7XG4gIGxldCBvdXJQcm9wcyA9IHtcbiAgICBpZDogaWQyLFxuICAgIHJlZjogb3B0aW9uUmVmLFxuICAgIHJvbGU6IFwib3B0aW9uXCIsXG4gICAgdGFiSW5kZXg6IGRpc2FibGVkID09PSB0cnVlID8gdm9pZCAwIDogLTEsXG4gICAgXCJhcmlhLWRpc2FibGVkXCI6IGRpc2FibGVkID09PSB0cnVlID8gdHJ1ZSA6IHZvaWQgMCxcbiAgICBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0ZWQsXG4gICAgZGlzYWJsZWQ6IHZvaWQgMCxcbiAgICBvbkNsaWNrOiBoYW5kbGVDbGljayxcbiAgICBvbkZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICBvblBvaW50ZXJNb3ZlOiBoYW5kbGVNb3ZlLFxuICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVNb3ZlLFxuICAgIG9uUG9pbnRlckxlYXZlOiBoYW5kbGVMZWF2ZSxcbiAgICBvbk1vdXNlTGVhdmU6IGhhbmRsZUxlYXZlXG4gIH07XG4gIHJldHVybiByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX09QVElPTl9UQUcsXG4gICAgbmFtZTogXCJDb21ib2JveC5PcHRpb25cIlxuICB9KTtcbn0pO1xudmFyIENvbWJvYm94ID0gT2JqZWN0LmFzc2lnbihDb21ib2JveFJvb3QsIHsgSW5wdXQsIEJ1dHRvbiwgTGFiZWwsIE9wdGlvbnMsIE9wdGlvbiB9KTtcblxuLy8gc3JjL2NvbXBvbmVudHMvZGlhbG9nL2RpYWxvZy50c3hcbnZhciBpbXBvcnRfcmVhY3QyOCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvZm9jdXMtdHJhcC9mb2N1cy10cmFwLnRzeFxudmFyIGltcG9ydF9yZWFjdDIzID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xuXG4vLyBzcmMvaG9va3MvdXNlLXRhYi1kaXJlY3Rpb24udHNcbnZhciBpbXBvcnRfcmVhY3QxOSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gc3JjL2hvb2tzL3VzZS13aW5kb3ctZXZlbnQudHNcbnZhciBpbXBvcnRfcmVhY3QxOCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIHVzZVdpbmRvd0V2ZW50KHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gIGxldCBsaXN0ZW5lclJlZiA9IHVzZUxhdGVzdFZhbHVlKGxpc3RlbmVyKTtcbiAgKDAsIGltcG9ydF9yZWFjdDE4LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGxpc3RlbmVyUmVmLmN1cnJlbnQoZXZlbnQpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0sIFt0eXBlLCBvcHRpb25zXSk7XG59XG5cbi8vIHNyYy9ob29rcy91c2UtdGFiLWRpcmVjdGlvbi50c1xuZnVuY3Rpb24gdXNlVGFiRGlyZWN0aW9uKCkge1xuICBsZXQgZGlyZWN0aW9uID0gKDAsIGltcG9ydF9yZWFjdDE5LnVzZVJlZikoMCAvKiBGb3J3YXJkcyAqLyk7XG4gIHVzZVdpbmRvd0V2ZW50KFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICBkaXJlY3Rpb24uY3VycmVudCA9IGV2ZW50LnNoaWZ0S2V5ID8gMSAvKiBCYWNrd2FyZHMgKi8gOiAwIC8qIEZvcndhcmRzICovO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG4gIHJldHVybiBkaXJlY3Rpb247XG59XG5cbi8vIHNyYy9ob29rcy91c2UtaXMtbW91bnRlZC50c1xudmFyIGltcG9ydF9yZWFjdDIwID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlSXNNb3VudGVkKCkge1xuICBsZXQgbW91bnRlZCA9ICgwLCBpbXBvcnRfcmVhY3QyMC51c2VSZWYpKGZhbHNlKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgbW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gbW91bnRlZDtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1vd25lci50c1xudmFyIGltcG9ydF9yZWFjdDIxID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlT3duZXJEb2N1bWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X3JlYWN0MjEudXNlTWVtbykoKCkgPT4gZ2V0T3duZXJEb2N1bWVudCguLi5hcmdzKSwgWy4uLmFyZ3NdKTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1ldmVudC1saXN0ZW5lci50c1xudmFyIGltcG9ydF9yZWFjdDIyID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICBsZXQgbGlzdGVuZXJSZWYgPSB1c2VMYXRlc3RWYWx1ZShsaXN0ZW5lcik7XG4gICgwLCBpbXBvcnRfcmVhY3QyMi51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBlbGVtZW50ID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudCA6IHdpbmRvdztcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBsaXN0ZW5lclJlZi5jdXJyZW50KGV2ZW50KTtcbiAgICB9XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0sIFtlbGVtZW50LCB0eXBlLCBvcHRpb25zXSk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC50c3hcbnZhciBERUZBVUxUX0ZPQ1VTX1RSQVBfVEFHID0gXCJkaXZcIjtcbnZhciBGZWF0dXJlczMgPSAvKiBAX19QVVJFX18gKi8gKChGZWF0dXJlczQpID0+IHtcbiAgRmVhdHVyZXM0W0ZlYXR1cmVzNFtcIk5vbmVcIl0gPSAxXSA9IFwiTm9uZVwiO1xuICBGZWF0dXJlczRbRmVhdHVyZXM0W1wiSW5pdGlhbEZvY3VzXCJdID0gMl0gPSBcIkluaXRpYWxGb2N1c1wiO1xuICBGZWF0dXJlczRbRmVhdHVyZXM0W1wiVGFiTG9ja1wiXSA9IDRdID0gXCJUYWJMb2NrXCI7XG4gIEZlYXR1cmVzNFtGZWF0dXJlczRbXCJGb2N1c0xvY2tcIl0gPSA4XSA9IFwiRm9jdXNMb2NrXCI7XG4gIEZlYXR1cmVzNFtGZWF0dXJlczRbXCJSZXN0b3JlRm9jdXNcIl0gPSAxNl0gPSBcIlJlc3RvcmVGb2N1c1wiO1xuICBGZWF0dXJlczRbRmVhdHVyZXM0W1wiQWxsXCJdID0gMzBdID0gXCJBbGxcIjtcbiAgcmV0dXJuIEZlYXR1cmVzNDtcbn0pKEZlYXR1cmVzMyB8fCB7fSk7XG52YXIgRm9jdXNUcmFwID0gT2JqZWN0LmFzc2lnbihmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIEZvY3VzVHJhcDIocHJvcHMsIHJlZikge1xuICBsZXQgY29udGFpbmVyID0gKDAsIGltcG9ydF9yZWFjdDIzLnVzZVJlZikobnVsbCk7XG4gIGxldCBmb2N1c1RyYXBSZWYgPSB1c2VTeW5jUmVmcyhjb250YWluZXIsIHJlZik7XG4gIGxldCB7IGluaXRpYWxGb2N1cywgY29udGFpbmVycywgZmVhdHVyZXMgPSAzMCAvKiBBbGwgKi8sIC4uLnRoZWlyUHJvcHMgfSA9IHByb3BzO1xuICBpZiAoIXVzZVNlcnZlckhhbmRvZmZDb21wbGV0ZSgpKSB7XG4gICAgZmVhdHVyZXMgPSAxIC8qIE5vbmUgKi87XG4gIH1cbiAgbGV0IG93bmVyRG9jdW1lbnQgPSB1c2VPd25lckRvY3VtZW50KGNvbnRhaW5lcik7XG4gIHVzZVJlc3RvcmVGb2N1cyh7IG93bmVyRG9jdW1lbnQgfSwgQm9vbGVhbihmZWF0dXJlcyAmIDE2IC8qIFJlc3RvcmVGb2N1cyAqLykpO1xuICBsZXQgcHJldmlvdXNBY3RpdmVFbGVtZW50ID0gdXNlSW5pdGlhbEZvY3VzKHsgb3duZXJEb2N1bWVudCwgY29udGFpbmVyLCBpbml0aWFsRm9jdXMgfSwgQm9vbGVhbihmZWF0dXJlcyAmIDIgLyogSW5pdGlhbEZvY3VzICovKSk7XG4gIHVzZUZvY3VzTG9jayh7IG93bmVyRG9jdW1lbnQsIGNvbnRhaW5lciwgY29udGFpbmVycywgcHJldmlvdXNBY3RpdmVFbGVtZW50IH0sIEJvb2xlYW4oZmVhdHVyZXMgJiA4IC8qIEZvY3VzTG9jayAqLykpO1xuICBsZXQgZGlyZWN0aW9uID0gdXNlVGFiRGlyZWN0aW9uKCk7XG4gIGxldCBoYW5kbGVGb2N1cyA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICBsZXQgZWwgPSBjb250YWluZXIuY3VycmVudDtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgbWljcm9UYXNrKCgpID0+IHtcbiAgICAgICAgbWF0Y2goZGlyZWN0aW9uLmN1cnJlbnQsIHtcbiAgICAgICAgICBbMCAvKiBGb3J3YXJkcyAqL106ICgpID0+IGZvY3VzSW4oZWwsIDEgLyogRmlyc3QgKi8pLFxuICAgICAgICAgIFsxIC8qIEJhY2t3YXJkcyAqL106ICgpID0+IGZvY3VzSW4oZWwsIDggLyogTGFzdCAqLylcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2goZGlyZWN0aW9uLmN1cnJlbnQsIHtcbiAgICAgICAgWzAgLyogRm9yd2FyZHMgKi9dOiAoKSA9PiBmb2N1c0luKGVsLCAxIC8qIEZpcnN0ICovKSxcbiAgICAgICAgWzEgLyogQmFja3dhcmRzICovXTogKCkgPT4gZm9jdXNJbihlbCwgOCAvKiBMYXN0ICovKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbGV0IG91clByb3BzID0geyByZWY6IGZvY3VzVHJhcFJlZiB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDIzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChpbXBvcnRfcmVhY3QyMy5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBCb29sZWFuKGZlYXR1cmVzICYgNCAvKiBUYWJMb2NrICovKSAmJiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhpZGRlbiwge1xuICAgIGFzOiBcImJ1dHRvblwiLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgb25Gb2N1czogaGFuZGxlRm9jdXMsXG4gICAgZmVhdHVyZXM6IDIgLyogRm9jdXNhYmxlICovXG4gIH0pLCByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9GT0NVU19UUkFQX1RBRyxcbiAgICBuYW1lOiBcIkZvY3VzVHJhcFwiXG4gIH0pLCBCb29sZWFuKGZlYXR1cmVzICYgNCAvKiBUYWJMb2NrICovKSAmJiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhpZGRlbiwge1xuICAgIGFzOiBcImJ1dHRvblwiLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgb25Gb2N1czogaGFuZGxlRm9jdXMsXG4gICAgZmVhdHVyZXM6IDIgLyogRm9jdXNhYmxlICovXG4gIH0pKTtcbn0pLCB7IGZlYXR1cmVzOiBGZWF0dXJlczMgfSk7XG5mdW5jdGlvbiB1c2VSZXN0b3JlRm9jdXMoeyBvd25lckRvY3VtZW50IH0sIGVuYWJsZWQpIHtcbiAgbGV0IHJlc3RvcmVFbGVtZW50ID0gKDAsIGltcG9ydF9yZWFjdDIzLnVzZVJlZikobnVsbCk7XG4gIHVzZUV2ZW50TGlzdGVuZXIob3duZXJEb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldywgXCJmb2N1c291dFwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlc3RvcmVFbGVtZW50LmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgcmVzdG9yZUVsZW1lbnQuY3VycmVudCA9IGV2ZW50LnRhcmdldDtcbiAgfSwgdHJ1ZSk7XG4gIHVzZVdhdGNoKCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoKG93bmVyRG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT09IChvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmJvZHkpKSB7XG4gICAgICBmb2N1c0VsZW1lbnQocmVzdG9yZUVsZW1lbnQuY3VycmVudCk7XG4gICAgfVxuICAgIHJlc3RvcmVFbGVtZW50LmN1cnJlbnQgPSBudWxsO1xuICB9LCBbZW5hYmxlZF0pO1xuICBsZXQgdHJ1bHlVbm1vdW50ZWQgPSAoMCwgaW1wb3J0X3JlYWN0MjMudXNlUmVmKShmYWxzZSk7XG4gICgwLCBpbXBvcnRfcmVhY3QyMy51c2VFZmZlY3QpKCgpID0+IHtcbiAgICB0cnVseVVubW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRydWx5VW5tb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgbWljcm9UYXNrKCgpID0+IHtcbiAgICAgICAgaWYgKCF0cnVseVVubW91bnRlZC5jdXJyZW50KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9jdXNFbGVtZW50KHJlc3RvcmVFbGVtZW50LmN1cnJlbnQpO1xuICAgICAgICByZXN0b3JlRWxlbWVudC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIHVzZUluaXRpYWxGb2N1cyh7XG4gIG93bmVyRG9jdW1lbnQsXG4gIGNvbnRhaW5lcixcbiAgaW5pdGlhbEZvY3VzXG59LCBlbmFibGVkKSB7XG4gIGxldCBwcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSAoMCwgaW1wb3J0X3JlYWN0MjMudXNlUmVmKShudWxsKTtcbiAgbGV0IG1vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgdXNlV2F0Y2goKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgIGlmICghY29udGFpbmVyRWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBtaWNyb1Rhc2soKCkgPT4ge1xuICAgICAgaWYgKCFtb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGFjdGl2ZUVsZW1lbnQgPSBvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBpZiAoaW5pdGlhbEZvY3VzID09IG51bGwgPyB2b2lkIDAgOiBpbml0aWFsRm9jdXMuY3VycmVudCkge1xuICAgICAgICBpZiAoKGluaXRpYWxGb2N1cyA9PSBudWxsID8gdm9pZCAwIDogaW5pdGlhbEZvY3VzLmN1cnJlbnQpID09PSBhY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgcHJldmlvdXNBY3RpdmVFbGVtZW50LmN1cnJlbnQgPSBhY3RpdmVFbGVtZW50O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250YWluZXJFbGVtZW50LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHByZXZpb3VzQWN0aXZlRWxlbWVudC5jdXJyZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGluaXRpYWxGb2N1cyA9PSBudWxsID8gdm9pZCAwIDogaW5pdGlhbEZvY3VzLmN1cnJlbnQpIHtcbiAgICAgICAgZm9jdXNFbGVtZW50KGluaXRpYWxGb2N1cy5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb2N1c0luKGNvbnRhaW5lckVsZW1lbnQsIDEgLyogRmlyc3QgKi8pID09PSAwIC8qIEVycm9yICovKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlcmUgYXJlIG5vIGZvY3VzYWJsZSBlbGVtZW50cyBpbnNpZGUgdGhlIDxGb2N1c1RyYXAgLz5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXZpb3VzQWN0aXZlRWxlbWVudC5jdXJyZW50ID0gb3duZXJEb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogb3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH0pO1xuICB9LCBbZW5hYmxlZF0pO1xuICByZXR1cm4gcHJldmlvdXNBY3RpdmVFbGVtZW50O1xufVxuZnVuY3Rpb24gdXNlRm9jdXNMb2NrKHtcbiAgb3duZXJEb2N1bWVudCxcbiAgY29udGFpbmVyLFxuICBjb250YWluZXJzLFxuICBwcmV2aW91c0FjdGl2ZUVsZW1lbnRcbn0sIGVuYWJsZWQpIHtcbiAgbGV0IG1vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LCBcImZvY3VzXCIsIChldmVudCkgPT4ge1xuICAgIGlmICghZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIW1vdW50ZWQuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgYWxsQ29udGFpbmVycyA9IG5ldyBTZXQoY29udGFpbmVycyA9PSBudWxsID8gdm9pZCAwIDogY29udGFpbmVycy5jdXJyZW50KTtcbiAgICBhbGxDb250YWluZXJzLmFkZChjb250YWluZXIpO1xuICAgIGxldCBwcmV2aW91cyA9IHByZXZpb3VzQWN0aXZlRWxlbWVudC5jdXJyZW50O1xuICAgIGlmICghcHJldmlvdXMpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHRvRWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgICBpZiAodG9FbGVtZW50ICYmIHRvRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBpZiAoIWNvbnRhaW5zKGFsbENvbnRhaW5lcnMsIHRvRWxlbWVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvY3VzRWxlbWVudChwcmV2aW91cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2aW91c0FjdGl2ZUVsZW1lbnQuY3VycmVudCA9IHRvRWxlbWVudDtcbiAgICAgICAgZm9jdXNFbGVtZW50KHRvRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvY3VzRWxlbWVudChwcmV2aW91c0FjdGl2ZUVsZW1lbnQuY3VycmVudCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKGNvbnRhaW5lcnMsIGVsZW1lbnQpIHtcbiAgdmFyIF9hMjtcbiAgZm9yIChsZXQgY29udGFpbmVyIG9mIGNvbnRhaW5lcnMpIHtcbiAgICBpZiAoKF9hMiA9IGNvbnRhaW5lci5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLWluZXJ0LW90aGVycy50c1xudmFyIGludGVyYWN0YWJsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIG9yaWdpbmFscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBpbmVydChlbGVtZW50KSB7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICBlbGVtZW50LmluZXJ0ID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmUoZWxlbWVudCkge1xuICBsZXQgb3JpZ2luYWwgPSBvcmlnaW5hbHMuZ2V0KGVsZW1lbnQpO1xuICBpZiAoIW9yaWdpbmFsKVxuICAgIHJldHVybjtcbiAgaWYgKG9yaWdpbmFsW1wiYXJpYS1oaWRkZW5cIl0gPT09IG51bGwpXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgZWxzZVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgb3JpZ2luYWxbXCJhcmlhLWhpZGRlblwiXSk7XG4gIGVsZW1lbnQuaW5lcnQgPSBvcmlnaW5hbC5pbmVydDtcbn1cbmZ1bmN0aW9uIHVzZUluZXJ0T3RoZXJzKGNvbnRhaW5lciwgZW5hYmxlZCA9IHRydWUpIHtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghY29udGFpbmVyLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGVsZW1lbnQgPSBjb250YWluZXIuY3VycmVudDtcbiAgICBsZXQgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnQoZWxlbWVudCk7XG4gICAgaWYgKCFvd25lckRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGludGVyYWN0YWJsZXMuYWRkKGVsZW1lbnQpO1xuICAgIGZvciAobGV0IG9yaWdpbmFsIG9mIG9yaWdpbmFscy5rZXlzKCkpIHtcbiAgICAgIGlmIChvcmlnaW5hbC5jb250YWlucyhlbGVtZW50KSkge1xuICAgICAgICByZXN0b3JlKG9yaWdpbmFsKTtcbiAgICAgICAgb3JpZ2luYWxzLmRlbGV0ZShvcmlnaW5hbCk7XG4gICAgICB9XG4gICAgfVxuICAgIG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJvZHkgPiAqXCIpLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZm9yIChsZXQgaW50ZXJhY3RhYmxlIG9mIGludGVyYWN0YWJsZXMpIHtcbiAgICAgICAgaWYgKGNoaWxkLmNvbnRhaW5zKGludGVyYWN0YWJsZSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGludGVyYWN0YWJsZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICBvcmlnaW5hbHMuc2V0KGNoaWxkLCB7XG4gICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBjaGlsZC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSxcbiAgICAgICAgICBpbmVydDogY2hpbGQuaW5lcnRcbiAgICAgICAgfSk7XG4gICAgICAgIGluZXJ0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaW50ZXJhY3RhYmxlcy5kZWxldGUoZWxlbWVudCk7XG4gICAgICBpZiAoaW50ZXJhY3RhYmxlcy5zaXplID4gMCkge1xuICAgICAgICBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJib2R5ID4gKlwiKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcmlnaW5hbHMuaGFzKGNoaWxkKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBmb3IgKGxldCBpbnRlcmFjdGFibGUgb2YgaW50ZXJhY3RhYmxlcykge1xuICAgICAgICAgICAgaWYgKGNoaWxkLmNvbnRhaW5zKGludGVyYWN0YWJsZSkpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxzLnNldChjaGlsZCwge1xuICAgICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBjaGlsZC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSxcbiAgICAgICAgICAgIGluZXJ0OiBjaGlsZC5pbmVydFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluZXJ0KGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBlbGVtZW50MiBvZiBvcmlnaW5hbHMua2V5cygpKSB7XG4gICAgICAgICAgcmVzdG9yZShlbGVtZW50Mik7XG4gICAgICAgICAgb3JpZ2luYWxzLmRlbGV0ZShlbGVtZW50Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZF0pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9wb3J0YWwvcG9ydGFsLnRzeFxudmFyIGltcG9ydF9yZWFjdDI1ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xudmFyIGltcG9ydF9yZWFjdF9kb20gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuXG4vLyBzcmMvaW50ZXJuYWwvcG9ydGFsLWZvcmNlLXJvb3QudHN4XG52YXIgaW1wb3J0X3JlYWN0MjQgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSwgMSk7XG52YXIgRm9yY2VQb3J0YWxSb290Q29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QyNC5jcmVhdGVDb250ZXh0KShmYWxzZSk7XG5mdW5jdGlvbiB1c2VQb3J0YWxSb290KCkge1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWFjdDI0LnVzZUNvbnRleHQpKEZvcmNlUG9ydGFsUm9vdENvbnRleHQpO1xufVxuZnVuY3Rpb24gRm9yY2VQb3J0YWxSb290KHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZvcmNlUG9ydGFsUm9vdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcHJvcHMuZm9yY2VcbiAgfSwgcHJvcHMuY2hpbGRyZW4pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9wb3J0YWwvcG9ydGFsLnRzeFxuZnVuY3Rpb24gdXNlUG9ydGFsVGFyZ2V0KHJlZikge1xuICBsZXQgZm9yY2VJblJvb3QgPSB1c2VQb3J0YWxSb290KCk7XG4gIGxldCBncm91cFRhcmdldCA9ICgwLCBpbXBvcnRfcmVhY3QyNS51c2VDb250ZXh0KShQb3J0YWxHcm91cENvbnRleHQpO1xuICBsZXQgb3duZXJEb2N1bWVudCA9IHVzZU93bmVyRG9jdW1lbnQocmVmKTtcbiAgbGV0IFt0YXJnZXQsIHNldFRhcmdldF0gPSAoMCwgaW1wb3J0X3JlYWN0MjUudXNlU3RhdGUpKCgpID0+IHtcbiAgICBpZiAoIWZvcmNlSW5Sb290ICYmIGdyb3VwVGFyZ2V0ICE9PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlzU2VydmVyKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGV4aXN0aW5nUm9vdCA9IG93bmVyRG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWFkbGVzc3VpLXBvcnRhbC1yb290XCIpO1xuICAgIGlmIChleGlzdGluZ1Jvb3QpXG4gICAgICByZXR1cm4gZXhpc3RpbmdSb290O1xuICAgIGlmIChvd25lckRvY3VtZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJvb3QgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImhlYWRsZXNzdWktcG9ydGFsLXJvb3RcIik7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyb290KTtcbiAgfSk7XG4gICgwLCBpbXBvcnRfcmVhY3QyNS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBpZiAodGFyZ2V0ID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghKG93bmVyRG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG93bmVyRG9jdW1lbnQuYm9keS5jb250YWlucyh0YXJnZXQpKSkge1xuICAgICAgb3duZXJEb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogb3duZXJEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9LCBbdGFyZ2V0LCBvd25lckRvY3VtZW50XSk7XG4gICgwLCBpbXBvcnRfcmVhY3QyNS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBpZiAoZm9yY2VJblJvb3QpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGdyb3VwVGFyZ2V0ID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHNldFRhcmdldChncm91cFRhcmdldC5jdXJyZW50KTtcbiAgfSwgW2dyb3VwVGFyZ2V0LCBzZXRUYXJnZXQsIGZvcmNlSW5Sb290XSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG52YXIgREVGQVVMVF9QT1JUQUxfVEFHID0gaW1wb3J0X3JlYWN0MjUuRnJhZ21lbnQ7XG52YXIgUG9ydGFsUm9vdCA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gUG9ydGFsKHByb3BzLCByZWYpIHtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IGludGVybmFsUG9ydGFsUm9vdFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QyNS51c2VSZWYpKG51bGwpO1xuICBsZXQgcG9ydGFsUmVmID0gdXNlU3luY1JlZnMob3B0aW9uYWxSZWYoKHJlZjIpID0+IHtcbiAgICBpbnRlcm5hbFBvcnRhbFJvb3RSZWYuY3VycmVudCA9IHJlZjI7XG4gIH0pLCByZWYpO1xuICBsZXQgb3duZXJEb2N1bWVudCA9IHVzZU93bmVyRG9jdW1lbnQoaW50ZXJuYWxQb3J0YWxSb290UmVmKTtcbiAgbGV0IHRhcmdldCA9IHVzZVBvcnRhbFRhcmdldChpbnRlcm5hbFBvcnRhbFJvb3RSZWYpO1xuICBsZXQgW2VsZW1lbnRdID0gKDAsIGltcG9ydF9yZWFjdDI1LnVzZVN0YXRlKSgoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gaXNTZXJ2ZXIgPyBudWxsIDogKF9hMiA9IG93bmVyRG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gIH0pO1xuICBsZXQgcmVhZHkgPSB1c2VTZXJ2ZXJIYW5kb2ZmQ29tcGxldGUoKTtcbiAgbGV0IHRydWx5VW5tb3VudGVkID0gKDAsIGltcG9ydF9yZWFjdDI1LnVzZVJlZikoZmFsc2UpO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICB0cnVseVVubW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKCF0YXJnZXQgfHwgIWVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0YXJnZXQuY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1oZWFkbGVzc3VpLXBvcnRhbFwiLCBcIlwiKTtcbiAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRydWx5VW5tb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgbWljcm9UYXNrKCgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgaWYgKCF0cnVseVVubW91bnRlZC5jdXJyZW50KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIWVsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIGlmICh0YXJnZXQuY2hpbGROb2Rlcy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgIChfYTIgPSB0YXJnZXQucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbdGFyZ2V0LCBlbGVtZW50XSk7XG4gIGlmICghcmVhZHkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBvdXJQcm9wcyA9IHsgcmVmOiBwb3J0YWxSZWYgfTtcbiAgcmV0dXJuICF0YXJnZXQgfHwgIWVsZW1lbnQgPyBudWxsIDogKDAsIGltcG9ydF9yZWFjdF9kb20uY3JlYXRlUG9ydGFsKShyZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9QT1JUQUxfVEFHLFxuICAgIG5hbWU6IFwiUG9ydGFsXCJcbiAgfSksIGVsZW1lbnQpO1xufSk7XG52YXIgREVGQVVMVF9HUk9VUF9UQUcgPSBpbXBvcnRfcmVhY3QyNS5GcmFnbWVudDtcbnZhciBQb3J0YWxHcm91cENvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MjUuY3JlYXRlQ29udGV4dCkobnVsbCk7XG52YXIgR3JvdXAgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIEdyb3VwMihwcm9wcywgcmVmKSB7XG4gIGxldCB7IHRhcmdldCwgLi4udGhlaXJQcm9wcyB9ID0gcHJvcHM7XG4gIGxldCBncm91cFJlZiA9IHVzZVN5bmNSZWZzKHJlZik7XG4gIGxldCBvdXJQcm9wcyA9IHsgcmVmOiBncm91cFJlZiB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDI1LmRlZmF1bHQuY3JlYXRlRWxlbWVudChQb3J0YWxHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdGFyZ2V0XG4gIH0sIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX0dST1VQX1RBRyxcbiAgICBuYW1lOiBcIlBvcG92ZXIuR3JvdXBcIlxuICB9KSk7XG59KTtcbnZhciBQb3J0YWwyID0gT2JqZWN0LmFzc2lnbihQb3J0YWxSb290LCB7IEdyb3VwIH0pO1xuXG4vLyBzcmMvY29tcG9uZW50cy9kZXNjcmlwdGlvbi9kZXNjcmlwdGlvbi50c3hcbnZhciBpbXBvcnRfcmVhY3QyNiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcbnZhciBEZXNjcmlwdGlvbkNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MjYuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5mdW5jdGlvbiB1c2VEZXNjcmlwdGlvbkNvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDI2LnVzZUNvbnRleHQpKERlc2NyaXB0aW9uQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgbGV0IGVyciA9IG5ldyBFcnJvcihcIllvdSB1c2VkIGEgPERlc2NyaXB0aW9uIC8+IGNvbXBvbmVudCwgYnV0IGl0IGlzIG5vdCBpbnNpZGUgYSByZWxldmFudCBwYXJlbnQuXCIpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdXNlRGVzY3JpcHRpb25Db250ZXh0KTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB1c2VEZXNjcmlwdGlvbnMoKSB7XG4gIGxldCBbZGVzY3JpcHRpb25JZHMsIHNldERlc2NyaXB0aW9uSWRzXSA9ICgwLCBpbXBvcnRfcmVhY3QyNi51c2VTdGF0ZSkoW10pO1xuICByZXR1cm4gW1xuICAgIGRlc2NyaXB0aW9uSWRzLmxlbmd0aCA+IDAgPyBkZXNjcmlwdGlvbklkcy5qb2luKFwiIFwiKSA6IHZvaWQgMCxcbiAgICAoMCwgaW1wb3J0X3JlYWN0MjYudXNlTWVtbykoKCkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIERlc2NyaXB0aW9uUHJvdmlkZXIocHJvcHMpIHtcbiAgICAgICAgbGV0IHJlZ2lzdGVyID0gdXNlRXZlbnQoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2V0RGVzY3JpcHRpb25JZHMoKGV4aXN0aW5nKSA9PiBbLi4uZXhpc3RpbmcsIHZhbHVlXSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHNldERlc2NyaXB0aW9uSWRzKChleGlzdGluZykgPT4ge1xuICAgICAgICAgICAgbGV0IGNsb25lID0gZXhpc3Rpbmcuc2xpY2UoKTtcbiAgICAgICAgICAgIGxldCBpZHggPSBjbG9uZS5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKVxuICAgICAgICAgICAgICBjbG9uZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb250ZXh0QmFnID0gKDAsIGltcG9ydF9yZWFjdDI2LnVzZU1lbW8pKCgpID0+ICh7IHJlZ2lzdGVyLCBzbG90OiBwcm9wcy5zbG90LCBuYW1lOiBwcm9wcy5uYW1lLCBwcm9wczogcHJvcHMucHJvcHMgfSksIFtyZWdpc3RlciwgcHJvcHMuc2xvdCwgcHJvcHMubmFtZSwgcHJvcHMucHJvcHNdKTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QyNi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGVzY3JpcHRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgdmFsdWU6IGNvbnRleHRCYWdcbiAgICAgICAgfSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgICAgfTtcbiAgICB9LCBbc2V0RGVzY3JpcHRpb25JZHNdKVxuICBdO1xufVxudmFyIERFRkFVTFRfREVTQ1JJUFRJT05fVEFHID0gXCJwXCI7XG52YXIgRGVzY3JpcHRpb24gPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIERlc2NyaXB0aW9uMihwcm9wcywgcmVmKSB7XG4gIGxldCBjb250ZXh0ID0gdXNlRGVzY3JpcHRpb25Db250ZXh0KCk7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1kZXNjcmlwdGlvbi0ke3VzZUlkKCl9YDtcbiAgbGV0IGRlc2NyaXB0aW9uUmVmID0gdXNlU3luY1JlZnMocmVmKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiBjb250ZXh0LnJlZ2lzdGVyKGlkMiksIFtpZDIsIGNvbnRleHQucmVnaXN0ZXJdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0geyByZWY6IGRlc2NyaXB0aW9uUmVmLCAuLi5jb250ZXh0LnByb3BzLCBpZDogaWQyIH07XG4gIHJldHVybiByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdDogY29udGV4dC5zbG90IHx8IHt9LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfREVTQ1JJUFRJT05fVEFHLFxuICAgIG5hbWU6IGNvbnRleHQubmFtZSB8fCBcIkRlc2NyaXB0aW9uXCJcbiAgfSk7XG59KTtcblxuLy8gc3JjL2ludGVybmFsL3N0YWNrLWNvbnRleHQudHN4XG52YXIgaW1wb3J0X3JlYWN0MjcgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSwgMSk7XG52YXIgU3RhY2tDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDI3LmNyZWF0ZUNvbnRleHQpKCgpID0+IHtcbn0pO1xuU3RhY2tDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJTdGFja0NvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZVN0YWNrQ29udGV4dCgpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3QyNy51c2VDb250ZXh0KShTdGFja0NvbnRleHQpO1xufVxuZnVuY3Rpb24gU3RhY2tQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBvblVwZGF0ZSxcbiAgdHlwZSxcbiAgZWxlbWVudCxcbiAgZW5hYmxlZFxufSkge1xuICBsZXQgcGFyZW50VXBkYXRlID0gdXNlU3RhY2tDb250ZXh0KCk7XG4gIGxldCBub3RpZnkgPSB1c2VFdmVudCgoLi4uYXJncykgPT4ge1xuICAgIG9uVXBkYXRlID09IG51bGwgPyB2b2lkIDAgOiBvblVwZGF0ZSguLi5hcmdzKTtcbiAgICBwYXJlbnRVcGRhdGUoLi4uYXJncyk7XG4gIH0pO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgc2hvdWxkTm90aWZ5ID0gZW5hYmxlZCA9PT0gdm9pZCAwIHx8IGVuYWJsZWQgPT09IHRydWU7XG4gICAgc2hvdWxkTm90aWZ5ICYmIG5vdGlmeSgwIC8qIEFkZCAqLywgdHlwZSwgZWxlbWVudCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNob3VsZE5vdGlmeSAmJiBub3RpZnkoMSAvKiBSZW1vdmUgKi8sIHR5cGUsIGVsZW1lbnQpO1xuICAgIH07XG4gIH0sIFtub3RpZnksIHR5cGUsIGVsZW1lbnQsIGVuYWJsZWRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QyNy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3RhY2tDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG5vdGlmeVxuICB9LCBjaGlsZHJlbik7XG59XG5cbi8vIHNyYy91dGlscy9wbGF0Zm9ybS50c1xuZnVuY3Rpb24gaXNJT1MoKSB7XG4gIHJldHVybiAvaVBob25lL2dpLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgL01hYy9naS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9kaWFsb2cvZGlhbG9nLnRzeFxudmFyIHJlZHVjZXJzMiA9IHtcbiAgWzAgLyogU2V0VGl0bGVJZCAqL10oc3RhdGUyLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RhdGUyLnRpdGxlSWQgPT09IGFjdGlvbi5pZClcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCB0aXRsZUlkOiBhY3Rpb24uaWQgfTtcbiAgfVxufTtcbnZhciBEaWFsb2dDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDI4LmNyZWF0ZUNvbnRleHQpKG51bGwpO1xuRGlhbG9nQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGlhbG9nQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlRGlhbG9nQ29udGV4dChjb21wb25lbnQpIHtcbiAgbGV0IGNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MjgudXNlQ29udGV4dCkoRGlhbG9nQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgbGV0IGVyciA9IG5ldyBFcnJvcihgPCR7Y29tcG9uZW50fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxEaWFsb2cgLz4gY29tcG9uZW50LmApO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdXNlRGlhbG9nQ29udGV4dCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsTG9jayhvd25lckRvY3VtZW50LCBlbmFibGVkKSB7XG4gICgwLCBpbXBvcnRfcmVhY3QyOC51c2VFZmZlY3QpKCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIW93bmVyRG9jdW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGQgPSBkaXNwb3NhYmxlcygpO1xuICAgIGZ1bmN0aW9uIHN0eWxlKG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgbGV0IHByZXZpb3VzID0gbm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgICAgIE9iamVjdC5hc3NpZ24obm9kZS5zdHlsZSwgeyBbcHJvcGVydHldOiB2YWx1ZSB9KTtcbiAgICAgIHJldHVybiBkLmFkZCgoKSA9PiB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obm9kZS5zdHlsZSwgeyBbcHJvcGVydHldOiBwcmV2aW91cyB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgZG9jdW1lbnRFbGVtZW50ID0gb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgbGV0IG93bmVyV2luZG93ID0gKF9hMiA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpICE9IG51bGwgPyBfYTIgOiB3aW5kb3c7XG4gICAgbGV0IHNjcm9sbGJhcldpZHRoQmVmb3JlID0gb3duZXJXaW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBzdHlsZShkb2N1bWVudEVsZW1lbnQsIFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIik7XG4gICAgaWYgKHNjcm9sbGJhcldpZHRoQmVmb3JlID4gMCkge1xuICAgICAgbGV0IHNjcm9sbGJhcldpZHRoQWZ0ZXIgPSBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSBkb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxiYXJXaWR0aEJlZm9yZSAtIHNjcm9sbGJhcldpZHRoQWZ0ZXI7XG4gICAgICBzdHlsZShkb2N1bWVudEVsZW1lbnQsIFwicGFkZGluZ1JpZ2h0XCIsIGAke3Njcm9sbGJhcldpZHRofXB4YCk7XG4gICAgfVxuICAgIGlmIChpc0lPUygpKSB7XG4gICAgICBsZXQgc2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICBzdHlsZShkb2N1bWVudEVsZW1lbnQsIFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKTtcbiAgICAgIHN0eWxlKGRvY3VtZW50RWxlbWVudCwgXCJtYXJnaW5Ub3BcIiwgYC0ke3Njcm9sbFBvc2l0aW9ufXB4YCk7XG4gICAgICBzdHlsZShkb2N1bWVudEVsZW1lbnQsIFwid2lkdGhcIiwgYDEwMCVgKTtcbiAgICAgIGQuYWRkKCgpID0+IHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGxQb3NpdGlvbikpO1xuICAgIH1cbiAgICByZXR1cm4gZC5kaXNwb3NlO1xuICB9LCBbb3duZXJEb2N1bWVudCwgZW5hYmxlZF0pO1xufVxuZnVuY3Rpb24gc3RhdGVSZWR1Y2VyMihzdGF0ZTIsIGFjdGlvbikge1xuICByZXR1cm4gbWF0Y2goYWN0aW9uLnR5cGUsIHJlZHVjZXJzMiwgc3RhdGUyLCBhY3Rpb24pO1xufVxudmFyIERFRkFVTFRfRElBTE9HX1RBRyA9IFwiZGl2XCI7XG52YXIgRGlhbG9nUmVuZGVyRmVhdHVyZXMgPSAxIC8qIFJlbmRlclN0cmF0ZWd5ICovIHwgMiAvKiBTdGF0aWMgKi87XG52YXIgRGlhbG9nUm9vdCA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gRGlhbG9nKHByb3BzLCByZWYpIHtcbiAgbGV0IHsgb3Blbiwgb25DbG9zZSwgaW5pdGlhbEZvY3VzLCBfX2RlbW9Nb2RlID0gZmFsc2UsIC4uLnRoZWlyUHJvcHMgfSA9IHByb3BzO1xuICBsZXQgW25lc3RlZERpYWxvZ0NvdW50LCBzZXROZXN0ZWREaWFsb2dDb3VudF0gPSAoMCwgaW1wb3J0X3JlYWN0MjgudXNlU3RhdGUpKDApO1xuICBsZXQgdXNlc09wZW5DbG9zZWRTdGF0ZSA9IHVzZU9wZW5DbG9zZWQoKTtcbiAgaWYgKG9wZW4gPT09IHZvaWQgMCAmJiB1c2VzT3BlbkNsb3NlZFN0YXRlICE9PSBudWxsKSB7XG4gICAgb3BlbiA9IG1hdGNoKHVzZXNPcGVuQ2xvc2VkU3RhdGUsIHtcbiAgICAgIFswIC8qIE9wZW4gKi9dOiB0cnVlLFxuICAgICAgWzEgLyogQ2xvc2VkICovXTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBsZXQgY29udGFpbmVycyA9ICgwLCBpbXBvcnRfcmVhY3QyOC51c2VSZWYpKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICBsZXQgaW50ZXJuYWxEaWFsb2dSZWYgPSAoMCwgaW1wb3J0X3JlYWN0MjgudXNlUmVmKShudWxsKTtcbiAgbGV0IGRpYWxvZ1JlZiA9IHVzZVN5bmNSZWZzKGludGVybmFsRGlhbG9nUmVmLCByZWYpO1xuICBsZXQgbWFpblRyZWVOb2RlID0gKDAsIGltcG9ydF9yZWFjdDI4LnVzZVJlZikobnVsbCk7XG4gIGxldCBvd25lckRvY3VtZW50ID0gdXNlT3duZXJEb2N1bWVudChpbnRlcm5hbERpYWxvZ1JlZik7XG4gIGxldCBoYXNPcGVuID0gcHJvcHMuaGFzT3duUHJvcGVydHkoXCJvcGVuXCIpIHx8IHVzZXNPcGVuQ2xvc2VkU3RhdGUgIT09IG51bGw7XG4gIGxldCBoYXNPbkNsb3NlID0gcHJvcHMuaGFzT3duUHJvcGVydHkoXCJvbkNsb3NlXCIpO1xuICBpZiAoIWhhc09wZW4gJiYgIWhhc09uQ2xvc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBoYXZlIHRvIHByb3ZpZGUgYW4gXFxgb3BlblxcYCBhbmQgYW4gXFxgb25DbG9zZVxcYCBwcm9wIHRvIHRoZSBcXGBEaWFsb2dcXGAgY29tcG9uZW50LmApO1xuICB9XG4gIGlmICghaGFzT3Blbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IHByb3ZpZGVkIGFuIFxcYG9uQ2xvc2VcXGAgcHJvcCB0byB0aGUgXFxgRGlhbG9nXFxgLCBidXQgZm9yZ290IGFuIFxcYG9wZW5cXGAgcHJvcC5gKTtcbiAgfVxuICBpZiAoIWhhc09uQ2xvc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBwcm92aWRlZCBhbiBcXGBvcGVuXFxgIHByb3AgdG8gdGhlIFxcYERpYWxvZ1xcYCwgYnV0IGZvcmdvdCBhbiBcXGBvbkNsb3NlXFxgIHByb3AuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcGVuICE9PSBcImJvb2xlYW5cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IHByb3ZpZGVkIGFuIFxcYG9wZW5cXGAgcHJvcCB0byB0aGUgXFxgRGlhbG9nXFxgLCBidXQgdGhlIHZhbHVlIGlzIG5vdCBhIGJvb2xlYW4uIFJlY2VpdmVkOiAke29wZW59YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvbkNsb3NlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBwcm92aWRlZCBhbiBcXGBvbkNsb3NlXFxgIHByb3AgdG8gdGhlIFxcYERpYWxvZ1xcYCwgYnV0IHRoZSB2YWx1ZSBpcyBub3QgYSBmdW5jdGlvbi4gUmVjZWl2ZWQ6ICR7b25DbG9zZX1gKTtcbiAgfVxuICBsZXQgZGlhbG9nU3RhdGUgPSBvcGVuID8gMCAvKiBPcGVuICovIDogMSAvKiBDbG9zZWQgKi87XG4gIGxldCBbc3RhdGUyLCBkaXNwYXRjaF0gPSAoMCwgaW1wb3J0X3JlYWN0MjgudXNlUmVkdWNlcikoc3RhdGVSZWR1Y2VyMiwge1xuICAgIHRpdGxlSWQ6IG51bGwsXG4gICAgZGVzY3JpcHRpb25JZDogbnVsbCxcbiAgICBwYW5lbFJlZjogKDAsIGltcG9ydF9yZWFjdDI4LmNyZWF0ZVJlZikoKVxuICB9KTtcbiAgbGV0IGNsb3NlID0gdXNlRXZlbnQoKCkgPT4gb25DbG9zZShmYWxzZSkpO1xuICBsZXQgc2V0VGl0bGVJZCA9IHVzZUV2ZW50KChpZDMpID0+IGRpc3BhdGNoKHsgdHlwZTogMCAvKiBTZXRUaXRsZUlkICovLCBpZDogaWQzIH0pKTtcbiAgbGV0IHJlYWR5ID0gdXNlU2VydmVySGFuZG9mZkNvbXBsZXRlKCk7XG4gIGxldCBlbmFibGVkID0gcmVhZHkgPyBfX2RlbW9Nb2RlID8gZmFsc2UgOiBkaWFsb2dTdGF0ZSA9PT0gMCAvKiBPcGVuICovIDogZmFsc2U7XG4gIGxldCBoYXNOZXN0ZWREaWFsb2dzID0gbmVzdGVkRGlhbG9nQ291bnQgPiAxO1xuICBsZXQgaGFzUGFyZW50RGlhbG9nID0gKDAsIGltcG9ydF9yZWFjdDI4LnVzZUNvbnRleHQpKERpYWxvZ0NvbnRleHQpICE9PSBudWxsO1xuICBsZXQgcG9zaXRpb24gPSAhaGFzTmVzdGVkRGlhbG9ncyA/IFwibGVhZlwiIDogXCJwYXJlbnRcIjtcbiAgdXNlSW5lcnRPdGhlcnMoaW50ZXJuYWxEaWFsb2dSZWYsIGhhc05lc3RlZERpYWxvZ3MgPyBlbmFibGVkIDogZmFsc2UpO1xuICB1c2VPdXRzaWRlQ2xpY2soKCkgPT4ge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGxldCByb290Q29udGFpbmVycyA9IEFycmF5LmZyb20oKF9hMiA9IG93bmVyRG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJvZHkgPiAqLCBbZGF0YS1oZWFkbGVzc3VpLXBvcnRhbF1cIikpICE9IG51bGwgPyBfYTIgOiBbXSkuZmlsdGVyKChjb250YWluZXIpID0+IHtcbiAgICAgIGlmICghKGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhtYWluVHJlZU5vZGUuY3VycmVudCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChzdGF0ZTIucGFuZWxSZWYuY3VycmVudCAmJiBjb250YWluZXIuY29udGFpbnMoc3RhdGUyLnBhbmVsUmVmLmN1cnJlbnQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgLi4ucm9vdENvbnRhaW5lcnMsXG4gICAgICAoX2IgPSBzdGF0ZTIucGFuZWxSZWYuY3VycmVudCkgIT0gbnVsbCA/IF9iIDogaW50ZXJuYWxEaWFsb2dSZWYuY3VycmVudFxuICAgIF07XG4gIH0sIGNsb3NlLCBlbmFibGVkICYmICFoYXNOZXN0ZWREaWFsb2dzKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LCBcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmtleSAhPT0gXCJFc2NhcGVcIiAvKiBFc2NhcGUgKi8pXG4gICAgICByZXR1cm47XG4gICAgaWYgKGRpYWxvZ1N0YXRlICE9PSAwIC8qIE9wZW4gKi8pXG4gICAgICByZXR1cm47XG4gICAgaWYgKGhhc05lc3RlZERpYWxvZ3MpXG4gICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjbG9zZSgpO1xuICB9KTtcbiAgdXNlU2Nyb2xsTG9jayhvd25lckRvY3VtZW50LCBkaWFsb2dTdGF0ZSA9PT0gMCAvKiBPcGVuICovICYmICFoYXNQYXJlbnREaWFsb2cpO1xuICAoMCwgaW1wb3J0X3JlYWN0MjgudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKGRpYWxvZ1N0YXRlICE9PSAwIC8qIE9wZW4gKi8pXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFpbnRlcm5hbERpYWxvZ1JlZi5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnggPT09IDAgJiYgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnkgPT09IDAgJiYgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LndpZHRoID09PSAwICYmIGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShpbnRlcm5hbERpYWxvZ1JlZi5jdXJyZW50KTtcbiAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbZGlhbG9nU3RhdGUsIGludGVybmFsRGlhbG9nUmVmLCBjbG9zZV0pO1xuICBsZXQgW2Rlc2NyaWJlZGJ5LCBEZXNjcmlwdGlvblByb3ZpZGVyXSA9IHVzZURlc2NyaXB0aW9ucygpO1xuICBsZXQgaWQyID0gYGhlYWRsZXNzdWktZGlhbG9nLSR7dXNlSWQoKX1gO1xuICBsZXQgY29udGV4dEJhZyA9ICgwLCBpbXBvcnRfcmVhY3QyOC51c2VNZW1vKSgoKSA9PiBbeyBkaWFsb2dTdGF0ZSwgY2xvc2UsIHNldFRpdGxlSWQgfSwgc3RhdGUyXSwgW2RpYWxvZ1N0YXRlLCBzdGF0ZTIsIGNsb3NlLCBzZXRUaXRsZUlkXSk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDI4LnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IGRpYWxvZ1N0YXRlID09PSAwIC8qIE9wZW4gKi8gfSksIFtkaWFsb2dTdGF0ZV0pO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgcmVmOiBkaWFsb2dSZWYsXG4gICAgaWQ6IGlkMixcbiAgICByb2xlOiBcImRpYWxvZ1wiLFxuICAgIFwiYXJpYS1tb2RhbFwiOiBkaWFsb2dTdGF0ZSA9PT0gMCAvKiBPcGVuICovID8gdHJ1ZSA6IHZvaWQgMCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBzdGF0ZTIudGl0bGVJZCxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogZGVzY3JpYmVkYnlcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QyOC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3RhY2tQcm92aWRlciwge1xuICAgIHR5cGU6IFwiRGlhbG9nXCIsXG4gICAgZW5hYmxlZDogZGlhbG9nU3RhdGUgPT09IDAgLyogT3BlbiAqLyxcbiAgICBlbGVtZW50OiBpbnRlcm5hbERpYWxvZ1JlZixcbiAgICBvblVwZGF0ZTogdXNlRXZlbnQoKG1lc3NhZ2UsIHR5cGUsIGVsZW1lbnQpID0+IHtcbiAgICAgIGlmICh0eXBlICE9PSBcIkRpYWxvZ1wiKVxuICAgICAgICByZXR1cm47XG4gICAgICBtYXRjaChtZXNzYWdlLCB7XG4gICAgICAgIFswIC8qIEFkZCAqL10oKSB7XG4gICAgICAgICAgY29udGFpbmVycy5jdXJyZW50LmFkZChlbGVtZW50KTtcbiAgICAgICAgICBzZXROZXN0ZWREaWFsb2dDb3VudCgoY291bnQpID0+IGNvdW50ICsgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIFsxIC8qIFJlbW92ZSAqL10oKSB7XG4gICAgICAgICAgY29udGFpbmVycy5jdXJyZW50LmFkZChlbGVtZW50KTtcbiAgICAgICAgICBzZXROZXN0ZWREaWFsb2dDb3VudCgoY291bnQpID0+IGNvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QyOC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRm9yY2VQb3J0YWxSb290LCB7XG4gICAgZm9yY2U6IHRydWVcbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDI4LmRlZmF1bHQuY3JlYXRlRWxlbWVudChQb3J0YWwyLCBudWxsLCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjguZGVmYXVsdC5jcmVhdGVFbGVtZW50KERpYWxvZ0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dEJhZ1xuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjguZGVmYXVsdC5jcmVhdGVFbGVtZW50KFBvcnRhbDIuR3JvdXAsIHtcbiAgICB0YXJnZXQ6IGludGVybmFsRGlhbG9nUmVmXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QyOC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRm9yY2VQb3J0YWxSb290LCB7XG4gICAgZm9yY2U6IGZhbHNlXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QyOC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGVzY3JpcHRpb25Qcm92aWRlciwge1xuICAgIHNsb3QsXG4gICAgbmFtZTogXCJEaWFsb2cuRGVzY3JpcHRpb25cIlxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjguZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZvY3VzVHJhcCwge1xuICAgIGluaXRpYWxGb2N1cyxcbiAgICBjb250YWluZXJzLFxuICAgIGZlYXR1cmVzOiBlbmFibGVkID8gbWF0Y2gocG9zaXRpb24sIHtcbiAgICAgIHBhcmVudDogRm9jdXNUcmFwLmZlYXR1cmVzLlJlc3RvcmVGb2N1cyxcbiAgICAgIGxlYWY6IEZvY3VzVHJhcC5mZWF0dXJlcy5BbGwgJiB+Rm9jdXNUcmFwLmZlYXR1cmVzLkZvY3VzTG9ja1xuICAgIH0pIDogRm9jdXNUcmFwLmZlYXR1cmVzLk5vbmVcbiAgfSwgcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9ESUFMT0dfVEFHLFxuICAgIGZlYXR1cmVzOiBEaWFsb2dSZW5kZXJGZWF0dXJlcyxcbiAgICB2aXNpYmxlOiBkaWFsb2dTdGF0ZSA9PT0gMCAvKiBPcGVuICovLFxuICAgIG5hbWU6IFwiRGlhbG9nXCJcbiAgfSkpKSkpKSkpLCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjguZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhpZGRlbiwge1xuICAgIGZlYXR1cmVzOiA0IC8qIEhpZGRlbiAqLyxcbiAgICByZWY6IG1haW5UcmVlTm9kZVxuICB9KSk7XG59KTtcbnZhciBERUZBVUxUX09WRVJMQVlfVEFHID0gXCJkaXZcIjtcbnZhciBPdmVybGF5ID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBPdmVybGF5Mihwcm9wcywgcmVmKSB7XG4gIGxldCBbeyBkaWFsb2dTdGF0ZSwgY2xvc2UgfV0gPSB1c2VEaWFsb2dDb250ZXh0KFwiRGlhbG9nLk92ZXJsYXlcIik7XG4gIGxldCBvdmVybGF5UmVmID0gdXNlU3luY1JlZnMocmVmKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLWRpYWxvZy1vdmVybGF5LSR7dXNlSWQoKX1gO1xuICBsZXQgaGFuZGxlQ2xpY2sgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBldmVudC5jdXJyZW50VGFyZ2V0KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpc0Rpc2FibGVkUmVhY3RJc3N1ZTc3MTEoZXZlbnQuY3VycmVudFRhcmdldCkpXG4gICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNsb3NlKCk7XG4gIH0pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QyOC51c2VNZW1vKSgoKSA9PiAoeyBvcGVuOiBkaWFsb2dTdGF0ZSA9PT0gMCAvKiBPcGVuICovIH0pLCBbZGlhbG9nU3RhdGVdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0ge1xuICAgIHJlZjogb3ZlcmxheVJlZixcbiAgICBpZDogaWQyLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICBvbkNsaWNrOiBoYW5kbGVDbGlja1xuICB9O1xuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9PVkVSTEFZX1RBRyxcbiAgICBuYW1lOiBcIkRpYWxvZy5PdmVybGF5XCJcbiAgfSk7XG59KTtcbnZhciBERUZBVUxUX0JBQ0tEUk9QX1RBRyA9IFwiZGl2XCI7XG52YXIgQmFja2Ryb3AgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIEJhY2tkcm9wMihwcm9wcywgcmVmKSB7XG4gIGxldCBbeyBkaWFsb2dTdGF0ZSB9LCBzdGF0ZTJdID0gdXNlRGlhbG9nQ29udGV4dChcIkRpYWxvZy5CYWNrZHJvcFwiKTtcbiAgbGV0IGJhY2tkcm9wUmVmID0gdXNlU3luY1JlZnMocmVmKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLWRpYWxvZy1iYWNrZHJvcC0ke3VzZUlkKCl9YDtcbiAgKDAsIGltcG9ydF9yZWFjdDI4LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmIChzdGF0ZTIucGFuZWxSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIDxEaWFsb2cuQmFja2Ryb3AgLz4gY29tcG9uZW50IGlzIGJlaW5nIHVzZWQsIGJ1dCBhIDxEaWFsb2cuUGFuZWwgLz4gY29tcG9uZW50IGlzIG1pc3NpbmcuYCk7XG4gICAgfVxuICB9LCBbc3RhdGUyLnBhbmVsUmVmXSk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDI4LnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IGRpYWxvZ1N0YXRlID09PSAwIC8qIE9wZW4gKi8gfSksIFtkaWFsb2dTdGF0ZV0pO1xuICBsZXQgdGhlaXJQcm9wcyA9IHByb3BzO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgcmVmOiBiYWNrZHJvcFJlZixcbiAgICBpZDogaWQyLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZVxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDI4LmRlZmF1bHQuY3JlYXRlRWxlbWVudChGb3JjZVBvcnRhbFJvb3QsIHtcbiAgICBmb3JjZTogdHJ1ZVxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjguZGVmYXVsdC5jcmVhdGVFbGVtZW50KFBvcnRhbDIsIG51bGwsIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfQkFDS0RST1BfVEFHLFxuICAgIG5hbWU6IFwiRGlhbG9nLkJhY2tkcm9wXCJcbiAgfSkpKTtcbn0pO1xudmFyIERFRkFVTFRfUEFORUxfVEFHID0gXCJkaXZcIjtcbnZhciBQYW5lbCA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gUGFuZWwyKHByb3BzLCByZWYpIHtcbiAgbGV0IFt7IGRpYWxvZ1N0YXRlIH0sIHN0YXRlMl0gPSB1c2VEaWFsb2dDb250ZXh0KFwiRGlhbG9nLlBhbmVsXCIpO1xuICBsZXQgcGFuZWxSZWYgPSB1c2VTeW5jUmVmcyhyZWYsIHN0YXRlMi5wYW5lbFJlZik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1kaWFsb2ctcGFuZWwtJHt1c2VJZCgpfWA7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDI4LnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IGRpYWxvZ1N0YXRlID09PSAwIC8qIE9wZW4gKi8gfSksIFtkaWFsb2dTdGF0ZV0pO1xuICBsZXQgaGFuZGxlQ2xpY2sgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG4gIGxldCB0aGVpclByb3BzID0gcHJvcHM7XG4gIGxldCBvdXJQcm9wcyA9IHtcbiAgICByZWY6IHBhbmVsUmVmLFxuICAgIGlkOiBpZDIsXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2tcbiAgfTtcbiAgcmV0dXJuIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfUEFORUxfVEFHLFxuICAgIG5hbWU6IFwiRGlhbG9nLlBhbmVsXCJcbiAgfSk7XG59KTtcbnZhciBERUZBVUxUX1RJVExFX1RBRyA9IFwiaDJcIjtcbnZhciBUaXRsZSA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gVGl0bGUyKHByb3BzLCByZWYpIHtcbiAgbGV0IFt7IGRpYWxvZ1N0YXRlLCBzZXRUaXRsZUlkIH1dID0gdXNlRGlhbG9nQ29udGV4dChcIkRpYWxvZy5UaXRsZVwiKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLWRpYWxvZy10aXRsZS0ke3VzZUlkKCl9YDtcbiAgbGV0IHRpdGxlUmVmID0gdXNlU3luY1JlZnMocmVmKTtcbiAgKDAsIGltcG9ydF9yZWFjdDI4LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIHNldFRpdGxlSWQoaWQyKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0VGl0bGVJZChudWxsKTtcbiAgfSwgW2lkMiwgc2V0VGl0bGVJZF0pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QyOC51c2VNZW1vKSgoKSA9PiAoeyBvcGVuOiBkaWFsb2dTdGF0ZSA9PT0gMCAvKiBPcGVuICovIH0pLCBbZGlhbG9nU3RhdGVdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0geyByZWY6IHRpdGxlUmVmLCBpZDogaWQyIH07XG4gIHJldHVybiByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX1RJVExFX1RBRyxcbiAgICBuYW1lOiBcIkRpYWxvZy5UaXRsZVwiXG4gIH0pO1xufSk7XG52YXIgRGlhbG9nMiA9IE9iamVjdC5hc3NpZ24oRGlhbG9nUm9vdCwgeyBCYWNrZHJvcCwgUGFuZWwsIE92ZXJsYXksIFRpdGxlLCBEZXNjcmlwdGlvbiB9KTtcblxuLy8gc3JjL2NvbXBvbmVudHMvZGlzY2xvc3VyZS9kaXNjbG9zdXJlLnRzeFxudmFyIGltcG9ydF9yZWFjdDI5ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xudmFyIHJlZHVjZXJzMyA9IHtcbiAgWzAgLyogVG9nZ2xlRGlzY2xvc3VyZSAqL106IChzdGF0ZTIpID0+ICh7XG4gICAgLi4uc3RhdGUyLFxuICAgIGRpc2Nsb3N1cmVTdGF0ZTogbWF0Y2goc3RhdGUyLmRpc2Nsb3N1cmVTdGF0ZSwge1xuICAgICAgWzAgLyogT3BlbiAqL106IDEgLyogQ2xvc2VkICovLFxuICAgICAgWzEgLyogQ2xvc2VkICovXTogMCAvKiBPcGVuICovXG4gICAgfSlcbiAgfSksXG4gIFsxIC8qIENsb3NlRGlzY2xvc3VyZSAqL106IChzdGF0ZTIpID0+IHtcbiAgICBpZiAoc3RhdGUyLmRpc2Nsb3N1cmVTdGF0ZSA9PT0gMSAvKiBDbG9zZWQgKi8pXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIHJldHVybiB7IC4uLnN0YXRlMiwgZGlzY2xvc3VyZVN0YXRlOiAxIC8qIENsb3NlZCAqLyB9O1xuICB9LFxuICBbNCAvKiBMaW5rUGFuZWwgKi9dKHN0YXRlMikge1xuICAgIGlmIChzdGF0ZTIubGlua2VkUGFuZWwgPT09IHRydWUpXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIHJldHVybiB7IC4uLnN0YXRlMiwgbGlua2VkUGFuZWw6IHRydWUgfTtcbiAgfSxcbiAgWzUgLyogVW5saW5rUGFuZWwgKi9dKHN0YXRlMikge1xuICAgIGlmIChzdGF0ZTIubGlua2VkUGFuZWwgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIGxpbmtlZFBhbmVsOiBmYWxzZSB9O1xuICB9LFxuICBbMiAvKiBTZXRCdXR0b25JZCAqL10oc3RhdGUyLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RhdGUyLmJ1dHRvbklkID09PSBhY3Rpb24uYnV0dG9uSWQpXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIHJldHVybiB7IC4uLnN0YXRlMiwgYnV0dG9uSWQ6IGFjdGlvbi5idXR0b25JZCB9O1xuICB9LFxuICBbMyAvKiBTZXRQYW5lbElkICovXShzdGF0ZTIsIGFjdGlvbikge1xuICAgIGlmIChzdGF0ZTIucGFuZWxJZCA9PT0gYWN0aW9uLnBhbmVsSWQpXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIHJldHVybiB7IC4uLnN0YXRlMiwgcGFuZWxJZDogYWN0aW9uLnBhbmVsSWQgfTtcbiAgfVxufTtcbnZhciBEaXNjbG9zdXJlQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QyOS5jcmVhdGVDb250ZXh0KShudWxsKTtcbkRpc2Nsb3N1cmVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEaXNjbG9zdXJlQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlRGlzY2xvc3VyZUNvbnRleHQoY29tcG9uZW50KSB7XG4gIGxldCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDI5LnVzZUNvbnRleHQpKERpc2Nsb3N1cmVDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICBsZXQgZXJyID0gbmV3IEVycm9yKGA8JHtjb21wb25lbnR9IC8+IGlzIG1pc3NpbmcgYSBwYXJlbnQgPERpc2Nsb3N1cmUgLz4gY29tcG9uZW50LmApO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdXNlRGlzY2xvc3VyZUNvbnRleHQpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbnZhciBEaXNjbG9zdXJlQVBJQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QyOS5jcmVhdGVDb250ZXh0KShudWxsKTtcbkRpc2Nsb3N1cmVBUElDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEaXNjbG9zdXJlQVBJQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlRGlzY2xvc3VyZUFQSUNvbnRleHQoY29tcG9uZW50KSB7XG4gIGxldCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDI5LnVzZUNvbnRleHQpKERpc2Nsb3N1cmVBUElDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICBsZXQgZXJyID0gbmV3IEVycm9yKGA8JHtjb21wb25lbnR9IC8+IGlzIG1pc3NpbmcgYSBwYXJlbnQgPERpc2Nsb3N1cmUgLz4gY29tcG9uZW50LmApO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdXNlRGlzY2xvc3VyZUFQSUNvbnRleHQpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbnZhciBEaXNjbG9zdXJlUGFuZWxDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDI5LmNyZWF0ZUNvbnRleHQpKG51bGwpO1xuRGlzY2xvc3VyZVBhbmVsQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGlzY2xvc3VyZVBhbmVsQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlRGlzY2xvc3VyZVBhbmVsQ29udGV4dCgpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3QyOS51c2VDb250ZXh0KShEaXNjbG9zdXJlUGFuZWxDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHN0YXRlUmVkdWNlcjMoc3RhdGUyLCBhY3Rpb24pIHtcbiAgcmV0dXJuIG1hdGNoKGFjdGlvbi50eXBlLCByZWR1Y2VyczMsIHN0YXRlMiwgYWN0aW9uKTtcbn1cbnZhciBERUZBVUxUX0RJU0NMT1NVUkVfVEFHID0gaW1wb3J0X3JlYWN0MjkuRnJhZ21lbnQ7XG52YXIgRGlzY2xvc3VyZVJvb3QgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIERpc2Nsb3N1cmUocHJvcHMsIHJlZikge1xuICBsZXQgeyBkZWZhdWx0T3BlbiA9IGZhbHNlLCAuLi50aGVpclByb3BzIH0gPSBwcm9wcztcbiAgbGV0IGJ1dHRvbklkID0gYGhlYWRsZXNzdWktZGlzY2xvc3VyZS1idXR0b24tJHt1c2VJZCgpfWA7XG4gIGxldCBwYW5lbElkID0gYGhlYWRsZXNzdWktZGlzY2xvc3VyZS1wYW5lbC0ke3VzZUlkKCl9YDtcbiAgbGV0IGludGVybmFsRGlzY2xvc3VyZVJlZiA9ICgwLCBpbXBvcnRfcmVhY3QyOS51c2VSZWYpKG51bGwpO1xuICBsZXQgZGlzY2xvc3VyZVJlZiA9IHVzZVN5bmNSZWZzKHJlZiwgb3B0aW9uYWxSZWYoKHJlZjIpID0+IHtcbiAgICBpbnRlcm5hbERpc2Nsb3N1cmVSZWYuY3VycmVudCA9IHJlZjI7XG4gIH0sIHByb3BzLmFzID09PSB2b2lkIDAgfHwgcHJvcHMuYXMgPT09IGltcG9ydF9yZWFjdDI5LkZyYWdtZW50KSk7XG4gIGxldCBwYW5lbFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QyOS51c2VSZWYpKG51bGwpO1xuICBsZXQgYnV0dG9uUmVmID0gKDAsIGltcG9ydF9yZWFjdDI5LnVzZVJlZikobnVsbCk7XG4gIGxldCByZWR1Y2VyQmFnID0gKDAsIGltcG9ydF9yZWFjdDI5LnVzZVJlZHVjZXIpKHN0YXRlUmVkdWNlcjMsIHtcbiAgICBkaXNjbG9zdXJlU3RhdGU6IGRlZmF1bHRPcGVuID8gMCAvKiBPcGVuICovIDogMSAvKiBDbG9zZWQgKi8sXG4gICAgbGlua2VkUGFuZWw6IGZhbHNlLFxuICAgIGJ1dHRvblJlZixcbiAgICBwYW5lbFJlZixcbiAgICBidXR0b25JZCxcbiAgICBwYW5lbElkXG4gIH0pO1xuICBsZXQgW3sgZGlzY2xvc3VyZVN0YXRlIH0sIGRpc3BhdGNoXSA9IHJlZHVjZXJCYWc7XG4gICgwLCBpbXBvcnRfcmVhY3QyOS51c2VFZmZlY3QpKCgpID0+IGRpc3BhdGNoKHsgdHlwZTogMiAvKiBTZXRCdXR0b25JZCAqLywgYnV0dG9uSWQgfSksIFtidXR0b25JZCwgZGlzcGF0Y2hdKTtcbiAgKDAsIGltcG9ydF9yZWFjdDI5LnVzZUVmZmVjdCkoKCkgPT4gZGlzcGF0Y2goeyB0eXBlOiAzIC8qIFNldFBhbmVsSWQgKi8sIHBhbmVsSWQgfSksIFtwYW5lbElkLCBkaXNwYXRjaF0pO1xuICBsZXQgY2xvc2UgPSB1c2VFdmVudCgoZm9jdXNhYmxlRWxlbWVudCkgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogMSAvKiBDbG9zZURpc2Nsb3N1cmUgKi8gfSk7XG4gICAgbGV0IG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50KGludGVybmFsRGlzY2xvc3VyZVJlZik7XG4gICAgaWYgKCFvd25lckRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCByZXN0b3JlRWxlbWVudCA9ICgoKSA9PiB7XG4gICAgICBpZiAoIWZvY3VzYWJsZUVsZW1lbnQpXG4gICAgICAgIHJldHVybiBvd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGJ1dHRvbklkKTtcbiAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpXG4gICAgICAgIHJldHVybiBmb2N1c2FibGVFbGVtZW50O1xuICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnQuY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgICByZXR1cm4gZm9jdXNhYmxlRWxlbWVudC5jdXJyZW50O1xuICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYnV0dG9uSWQpO1xuICAgIH0pKCk7XG4gICAgcmVzdG9yZUVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3RvcmVFbGVtZW50LmZvY3VzKCk7XG4gIH0pO1xuICBsZXQgYXBpID0gKDAsIGltcG9ydF9yZWFjdDI5LnVzZU1lbW8pKCgpID0+ICh7IGNsb3NlIH0pLCBbY2xvc2VdKTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MjkudXNlTWVtbykoKCkgPT4gKHsgb3BlbjogZGlzY2xvc3VyZVN0YXRlID09PSAwIC8qIE9wZW4gKi8sIGNsb3NlIH0pLCBbZGlzY2xvc3VyZVN0YXRlLCBjbG9zZV0pO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgcmVmOiBkaXNjbG9zdXJlUmVmXG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MjkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KERpc2Nsb3N1cmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlZHVjZXJCYWdcbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDI5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChEaXNjbG9zdXJlQVBJQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcGlcbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDI5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChPcGVuQ2xvc2VkUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbWF0Y2goZGlzY2xvc3VyZVN0YXRlLCB7XG4gICAgICBbMCAvKiBPcGVuICovXTogMCAvKiBPcGVuICovLFxuICAgICAgWzEgLyogQ2xvc2VkICovXTogMSAvKiBDbG9zZWQgKi9cbiAgICB9KVxuICB9LCByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX0RJU0NMT1NVUkVfVEFHLFxuICAgIG5hbWU6IFwiRGlzY2xvc3VyZVwiXG4gIH0pKSkpO1xufSk7XG52YXIgREVGQVVMVF9CVVRUT05fVEFHMiA9IFwiYnV0dG9uXCI7XG52YXIgQnV0dG9uMyA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gQnV0dG9uNChwcm9wcywgcmVmKSB7XG4gIGxldCBbc3RhdGUyLCBkaXNwYXRjaF0gPSB1c2VEaXNjbG9zdXJlQ29udGV4dChcIkRpc2Nsb3N1cmUuQnV0dG9uXCIpO1xuICBsZXQgcGFuZWxDb250ZXh0ID0gdXNlRGlzY2xvc3VyZVBhbmVsQ29udGV4dCgpO1xuICBsZXQgaXNXaXRoaW5QYW5lbCA9IHBhbmVsQ29udGV4dCA9PT0gbnVsbCA/IGZhbHNlIDogcGFuZWxDb250ZXh0ID09PSBzdGF0ZTIucGFuZWxJZDtcbiAgbGV0IGludGVybmFsQnV0dG9uUmVmID0gKDAsIGltcG9ydF9yZWFjdDI5LnVzZVJlZikobnVsbCk7XG4gIGxldCBidXR0b25SZWYgPSB1c2VTeW5jUmVmcyhpbnRlcm5hbEJ1dHRvblJlZiwgcmVmLCAhaXNXaXRoaW5QYW5lbCA/IHN0YXRlMi5idXR0b25SZWYgOiBudWxsKTtcbiAgbGV0IGhhbmRsZUtleURvd24gPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmIChpc1dpdGhpblBhbmVsKSB7XG4gICAgICBpZiAoc3RhdGUyLmRpc2Nsb3N1cmVTdGF0ZSA9PT0gMSAvKiBDbG9zZWQgKi8pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgIGNhc2UgXCIgXCIgLyogU3BhY2UgKi86XG4gICAgICAgIGNhc2UgXCJFbnRlclwiIC8qIEVudGVyICovOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAwIC8qIFRvZ2dsZURpc2Nsb3N1cmUgKi8gfSk7XG4gICAgICAgICAgKF9hMiA9IHN0YXRlMi5idXR0b25SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mb2N1cygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlIFwiIFwiIC8qIFNwYWNlICovOlxuICAgICAgICBjYXNlIFwiRW50ZXJcIiAvKiBFbnRlciAqLzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGRpc3BhdGNoKHsgdHlwZTogMCAvKiBUb2dnbGVEaXNjbG9zdXJlICovIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGxldCBoYW5kbGVLZXlVcCA9IHVzZUV2ZW50KChldmVudCkgPT4ge1xuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiIFwiIC8qIFNwYWNlICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICBsZXQgaGFuZGxlQ2xpY2sgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmIChpc0Rpc2FibGVkUmVhY3RJc3N1ZTc3MTEoZXZlbnQuY3VycmVudFRhcmdldCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpc1dpdGhpblBhbmVsKSB7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IDAgLyogVG9nZ2xlRGlzY2xvc3VyZSAqLyB9KTtcbiAgICAgIChfYTIgPSBzdGF0ZTIuYnV0dG9uUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAwIC8qIFRvZ2dsZURpc2Nsb3N1cmUgKi8gfSk7XG4gICAgfVxuICB9KTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MjkudXNlTWVtbykoKCkgPT4gKHsgb3Blbjogc3RhdGUyLmRpc2Nsb3N1cmVTdGF0ZSA9PT0gMCAvKiBPcGVuICovIH0pLCBbc3RhdGUyXSk7XG4gIGxldCB0eXBlID0gdXNlUmVzb2x2ZUJ1dHRvblR5cGUocHJvcHMsIGludGVybmFsQnV0dG9uUmVmKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0gaXNXaXRoaW5QYW5lbCA/IHsgcmVmOiBidXR0b25SZWYsIHR5cGUsIG9uS2V5RG93bjogaGFuZGxlS2V5RG93biwgb25DbGljazogaGFuZGxlQ2xpY2sgfSA6IHtcbiAgICByZWY6IGJ1dHRvblJlZixcbiAgICBpZDogc3RhdGUyLmJ1dHRvbklkLFxuICAgIHR5cGUsXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6IHByb3BzLmRpc2FibGVkID8gdm9pZCAwIDogc3RhdGUyLmRpc2Nsb3N1cmVTdGF0ZSA9PT0gMCAvKiBPcGVuICovLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiBzdGF0ZTIubGlua2VkUGFuZWwgPyBzdGF0ZTIucGFuZWxJZCA6IHZvaWQgMCxcbiAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgb25LZXlVcDogaGFuZGxlS2V5VXAsXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2tcbiAgfTtcbiAgcmV0dXJuIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfQlVUVE9OX1RBRzIsXG4gICAgbmFtZTogXCJEaXNjbG9zdXJlLkJ1dHRvblwiXG4gIH0pO1xufSk7XG52YXIgREVGQVVMVF9QQU5FTF9UQUcyID0gXCJkaXZcIjtcbnZhciBQYW5lbFJlbmRlckZlYXR1cmVzID0gMSAvKiBSZW5kZXJTdHJhdGVneSAqLyB8IDIgLyogU3RhdGljICovO1xudmFyIFBhbmVsMyA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gUGFuZWw0KHByb3BzLCByZWYpIHtcbiAgbGV0IFtzdGF0ZTIsIGRpc3BhdGNoXSA9IHVzZURpc2Nsb3N1cmVDb250ZXh0KFwiRGlzY2xvc3VyZS5QYW5lbFwiKTtcbiAgbGV0IHsgY2xvc2UgfSA9IHVzZURpc2Nsb3N1cmVBUElDb250ZXh0KFwiRGlzY2xvc3VyZS5QYW5lbFwiKTtcbiAgbGV0IHBhbmVsUmVmID0gdXNlU3luY1JlZnMocmVmLCBzdGF0ZTIucGFuZWxSZWYsIChlbCkgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogZWwgPyA0IC8qIExpbmtQYW5lbCAqLyA6IDUgLyogVW5saW5rUGFuZWwgKi8gfSk7XG4gIH0pO1xuICBsZXQgdXNlc09wZW5DbG9zZWRTdGF0ZSA9IHVzZU9wZW5DbG9zZWQoKTtcbiAgbGV0IHZpc2libGUgPSAoKCkgPT4ge1xuICAgIGlmICh1c2VzT3BlbkNsb3NlZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdXNlc09wZW5DbG9zZWRTdGF0ZSA9PT0gMCAvKiBPcGVuICovO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUyLmRpc2Nsb3N1cmVTdGF0ZSA9PT0gMCAvKiBPcGVuICovO1xuICB9KSgpO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QyOS51c2VNZW1vKSgoKSA9PiAoeyBvcGVuOiBzdGF0ZTIuZGlzY2xvc3VyZVN0YXRlID09PSAwIC8qIE9wZW4gKi8sIGNsb3NlIH0pLCBbc3RhdGUyLCBjbG9zZV0pO1xuICBsZXQgdGhlaXJQcm9wcyA9IHByb3BzO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgcmVmOiBwYW5lbFJlZixcbiAgICBpZDogc3RhdGUyLnBhbmVsSWRcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QyOS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGlzY2xvc3VyZVBhbmVsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdGF0ZTIucGFuZWxJZFxuICB9LCByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX1BBTkVMX1RBRzIsXG4gICAgZmVhdHVyZXM6IFBhbmVsUmVuZGVyRmVhdHVyZXMsXG4gICAgdmlzaWJsZSxcbiAgICBuYW1lOiBcIkRpc2Nsb3N1cmUuUGFuZWxcIlxuICB9KSk7XG59KTtcbnZhciBEaXNjbG9zdXJlMiA9IE9iamVjdC5hc3NpZ24oRGlzY2xvc3VyZVJvb3QsIHsgQnV0dG9uOiBCdXR0b24zLCBQYW5lbDogUGFuZWwzIH0pO1xuXG4vLyBzcmMvY29tcG9uZW50cy9saXN0Ym94L2xpc3Rib3gudHN4XG52YXIgaW1wb3J0X3JlYWN0MzAgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSwgMSk7XG5mdW5jdGlvbiBhZGp1c3RPcmRlcmVkU3RhdGUyKHN0YXRlMiwgYWRqdXN0bWVudCA9IChpKSA9PiBpKSB7XG4gIGxldCBjdXJyZW50QWN0aXZlT3B0aW9uID0gc3RhdGUyLmFjdGl2ZU9wdGlvbkluZGV4ICE9PSBudWxsID8gc3RhdGUyLm9wdGlvbnNbc3RhdGUyLmFjdGl2ZU9wdGlvbkluZGV4XSA6IG51bGw7XG4gIGxldCBzb3J0ZWRPcHRpb25zID0gc29ydEJ5RG9tTm9kZShhZGp1c3RtZW50KHN0YXRlMi5vcHRpb25zLnNsaWNlKCkpLCAob3B0aW9uKSA9PiBvcHRpb24uZGF0YVJlZi5jdXJyZW50LmRvbVJlZi5jdXJyZW50KTtcbiAgbGV0IGFkanVzdGVkQWN0aXZlT3B0aW9uSW5kZXggPSBjdXJyZW50QWN0aXZlT3B0aW9uID8gc29ydGVkT3B0aW9ucy5pbmRleE9mKGN1cnJlbnRBY3RpdmVPcHRpb24pIDogbnVsbDtcbiAgaWYgKGFkanVzdGVkQWN0aXZlT3B0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgYWRqdXN0ZWRBY3RpdmVPcHRpb25JbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zOiBzb3J0ZWRPcHRpb25zLFxuICAgIGFjdGl2ZU9wdGlvbkluZGV4OiBhZGp1c3RlZEFjdGl2ZU9wdGlvbkluZGV4XG4gIH07XG59XG52YXIgcmVkdWNlcnM0ID0ge1xuICBbMSAvKiBDbG9zZUxpc3Rib3ggKi9dKHN0YXRlMikge1xuICAgIGlmIChzdGF0ZTIuZGlzYWJsZWQpXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIGlmIChzdGF0ZTIubGlzdGJveFN0YXRlID09PSAxIC8qIENsb3NlZCAqLylcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBhY3RpdmVPcHRpb25JbmRleDogbnVsbCwgbGlzdGJveFN0YXRlOiAxIC8qIENsb3NlZCAqLyB9O1xuICB9LFxuICBbMCAvKiBPcGVuTGlzdGJveCAqL10oc3RhdGUyKSB7XG4gICAgaWYgKHN0YXRlMi5kaXNhYmxlZClcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgaWYgKHN0YXRlMi5saXN0Ym94U3RhdGUgPT09IDAgLyogT3BlbiAqLylcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgbGV0IGFjdGl2ZU9wdGlvbkluZGV4ID0gc3RhdGUyLmFjdGl2ZU9wdGlvbkluZGV4O1xuICAgIGxldCB7IHZhbHVlLCBtb2RlLCBjb21wYXJlIH0gPSBzdGF0ZTIucHJvcHNSZWYuY3VycmVudDtcbiAgICBsZXQgb3B0aW9uSWR4ID0gc3RhdGUyLm9wdGlvbnMuZmluZEluZGV4KChvcHRpb24pID0+IHtcbiAgICAgIGxldCBvcHRpb25WYWx1ZSA9IG9wdGlvbi5kYXRhUmVmLmN1cnJlbnQudmFsdWU7XG4gICAgICBsZXQgc2VsZWN0ZWQgPSBtYXRjaChtb2RlLCB7XG4gICAgICAgIFsxIC8qIE11bHRpICovXTogKCkgPT4gdmFsdWUuc29tZSgob3B0aW9uMikgPT4gY29tcGFyZShvcHRpb24yLCBvcHRpb25WYWx1ZSkpLFxuICAgICAgICBbMCAvKiBTaW5nbGUgKi9dOiAoKSA9PiBjb21wYXJlKHZhbHVlLCBvcHRpb25WYWx1ZSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25JZHggIT09IC0xKSB7XG4gICAgICBhY3RpdmVPcHRpb25JbmRleCA9IG9wdGlvbklkeDtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBsaXN0Ym94U3RhdGU6IDAgLyogT3BlbiAqLywgYWN0aXZlT3B0aW9uSW5kZXggfTtcbiAgfSxcbiAgWzIgLyogU2V0RGlzYWJsZWQgKi9dKHN0YXRlMiwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlMi5kaXNhYmxlZCA9PT0gYWN0aW9uLmRpc2FibGVkKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIGRpc2FibGVkOiBhY3Rpb24uZGlzYWJsZWQgfTtcbiAgfSxcbiAgWzMgLyogU2V0T3JpZW50YXRpb24gKi9dKHN0YXRlMiwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlMi5vcmllbnRhdGlvbiA9PT0gYWN0aW9uLm9yaWVudGF0aW9uKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIG9yaWVudGF0aW9uOiBhY3Rpb24ub3JpZW50YXRpb24gfTtcbiAgfSxcbiAgWzQgLyogR29Ub09wdGlvbiAqL10oc3RhdGUyLCBhY3Rpb24pIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmIChzdGF0ZTIuZGlzYWJsZWQpXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIGlmIChzdGF0ZTIubGlzdGJveFN0YXRlID09PSAxIC8qIENsb3NlZCAqLylcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgbGV0IGFkanVzdGVkU3RhdGUgPSBhZGp1c3RPcmRlcmVkU3RhdGUyKHN0YXRlMik7XG4gICAgbGV0IGFjdGl2ZU9wdGlvbkluZGV4ID0gY2FsY3VsYXRlQWN0aXZlSW5kZXgoYWN0aW9uLCB7XG4gICAgICByZXNvbHZlSXRlbXM6ICgpID0+IGFkanVzdGVkU3RhdGUub3B0aW9ucyxcbiAgICAgIHJlc29sdmVBY3RpdmVJbmRleDogKCkgPT4gYWRqdXN0ZWRTdGF0ZS5hY3RpdmVPcHRpb25JbmRleCxcbiAgICAgIHJlc29sdmVJZDogKG9wdGlvbikgPT4gb3B0aW9uLmlkLFxuICAgICAgcmVzb2x2ZURpc2FibGVkOiAob3B0aW9uKSA9PiBvcHRpb24uZGF0YVJlZi5jdXJyZW50LmRpc2FibGVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlMixcbiAgICAgIC4uLmFkanVzdGVkU3RhdGUsXG4gICAgICBzZWFyY2hRdWVyeTogXCJcIixcbiAgICAgIGFjdGl2ZU9wdGlvbkluZGV4LFxuICAgICAgYWN0aXZhdGlvblRyaWdnZXI6IChfYTIgPSBhY3Rpb24udHJpZ2dlcikgIT0gbnVsbCA/IF9hMiA6IDEgLyogT3RoZXIgKi9cbiAgICB9O1xuICB9LFxuICBbNSAvKiBTZWFyY2ggKi9dOiAoc3RhdGUyLCBhY3Rpb24pID0+IHtcbiAgICBpZiAoc3RhdGUyLmRpc2FibGVkKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICBpZiAoc3RhdGUyLmxpc3Rib3hTdGF0ZSA9PT0gMSAvKiBDbG9zZWQgKi8pXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIGxldCB3YXNBbHJlYWR5U2VhcmNoaW5nID0gc3RhdGUyLnNlYXJjaFF1ZXJ5ICE9PSBcIlwiO1xuICAgIGxldCBvZmZzZXQgPSB3YXNBbHJlYWR5U2VhcmNoaW5nID8gMCA6IDE7XG4gICAgbGV0IHNlYXJjaFF1ZXJ5ID0gc3RhdGUyLnNlYXJjaFF1ZXJ5ICsgYWN0aW9uLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHJlT3JkZXJlZE9wdGlvbnMgPSBzdGF0ZTIuYWN0aXZlT3B0aW9uSW5kZXggIT09IG51bGwgPyBzdGF0ZTIub3B0aW9ucy5zbGljZShzdGF0ZTIuYWN0aXZlT3B0aW9uSW5kZXggKyBvZmZzZXQpLmNvbmNhdChzdGF0ZTIub3B0aW9ucy5zbGljZSgwLCBzdGF0ZTIuYWN0aXZlT3B0aW9uSW5kZXggKyBvZmZzZXQpKSA6IHN0YXRlMi5vcHRpb25zO1xuICAgIGxldCBtYXRjaGluZ09wdGlvbiA9IHJlT3JkZXJlZE9wdGlvbnMuZmluZCgob3B0aW9uKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuICFvcHRpb24uZGF0YVJlZi5jdXJyZW50LmRpc2FibGVkICYmICgoX2EyID0gb3B0aW9uLmRhdGFSZWYuY3VycmVudC50ZXh0VmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc3RhcnRzV2l0aChzZWFyY2hRdWVyeSkpO1xuICAgIH0pO1xuICAgIGxldCBtYXRjaElkeCA9IG1hdGNoaW5nT3B0aW9uID8gc3RhdGUyLm9wdGlvbnMuaW5kZXhPZihtYXRjaGluZ09wdGlvbikgOiAtMTtcbiAgICBpZiAobWF0Y2hJZHggPT09IC0xIHx8IG1hdGNoSWR4ID09PSBzdGF0ZTIuYWN0aXZlT3B0aW9uSW5kZXgpXG4gICAgICByZXR1cm4geyAuLi5zdGF0ZTIsIHNlYXJjaFF1ZXJ5IH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlMixcbiAgICAgIHNlYXJjaFF1ZXJ5LFxuICAgICAgYWN0aXZlT3B0aW9uSW5kZXg6IG1hdGNoSWR4LFxuICAgICAgYWN0aXZhdGlvblRyaWdnZXI6IDEgLyogT3RoZXIgKi9cbiAgICB9O1xuICB9LFxuICBbNiAvKiBDbGVhclNlYXJjaCAqL10oc3RhdGUyKSB7XG4gICAgaWYgKHN0YXRlMi5kaXNhYmxlZClcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgaWYgKHN0YXRlMi5saXN0Ym94U3RhdGUgPT09IDEgLyogQ2xvc2VkICovKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICBpZiAoc3RhdGUyLnNlYXJjaFF1ZXJ5ID09PSBcIlwiKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIHNlYXJjaFF1ZXJ5OiBcIlwiIH07XG4gIH0sXG4gIFs3IC8qIFJlZ2lzdGVyT3B0aW9uICovXTogKHN0YXRlMiwgYWN0aW9uKSA9PiB7XG4gICAgbGV0IG9wdGlvbiA9IHsgaWQ6IGFjdGlvbi5pZCwgZGF0YVJlZjogYWN0aW9uLmRhdGFSZWYgfTtcbiAgICBsZXQgYWRqdXN0ZWRTdGF0ZSA9IGFkanVzdE9yZGVyZWRTdGF0ZTIoc3RhdGUyLCAob3B0aW9ucykgPT4gWy4uLm9wdGlvbnMsIG9wdGlvbl0pO1xuICAgIGlmIChzdGF0ZTIuYWN0aXZlT3B0aW9uSW5kZXggPT09IG51bGwpIHtcbiAgICAgIGxldCB7IHZhbHVlLCBtb2RlLCBjb21wYXJlIH0gPSBzdGF0ZTIucHJvcHNSZWYuY3VycmVudDtcbiAgICAgIGxldCBvcHRpb25WYWx1ZSA9IGFjdGlvbi5kYXRhUmVmLmN1cnJlbnQudmFsdWU7XG4gICAgICBsZXQgc2VsZWN0ZWQgPSBtYXRjaChtb2RlLCB7XG4gICAgICAgIFsxIC8qIE11bHRpICovXTogKCkgPT4gdmFsdWUuc29tZSgob3B0aW9uMikgPT4gY29tcGFyZShvcHRpb24yLCBvcHRpb25WYWx1ZSkpLFxuICAgICAgICBbMCAvKiBTaW5nbGUgKi9dOiAoKSA9PiBjb21wYXJlKHZhbHVlLCBvcHRpb25WYWx1ZSlcbiAgICAgIH0pO1xuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIGFkanVzdGVkU3RhdGUuYWN0aXZlT3B0aW9uSW5kZXggPSBhZGp1c3RlZFN0YXRlLm9wdGlvbnMuaW5kZXhPZihvcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIC4uLmFkanVzdGVkU3RhdGUgfTtcbiAgfSxcbiAgWzggLyogVW5yZWdpc3Rlck9wdGlvbiAqL106IChzdGF0ZTIsIGFjdGlvbikgPT4ge1xuICAgIGxldCBhZGp1c3RlZFN0YXRlID0gYWRqdXN0T3JkZXJlZFN0YXRlMihzdGF0ZTIsIChvcHRpb25zKSA9PiB7XG4gICAgICBsZXQgaWR4ID0gb3B0aW9ucy5maW5kSW5kZXgoKGEpID0+IGEuaWQgPT09IGFjdGlvbi5pZCk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSlcbiAgICAgICAgb3B0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZTIsXG4gICAgICAuLi5hZGp1c3RlZFN0YXRlLFxuICAgICAgYWN0aXZhdGlvblRyaWdnZXI6IDEgLyogT3RoZXIgKi9cbiAgICB9O1xuICB9XG59O1xudmFyIExpc3Rib3hDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDMwLmNyZWF0ZUNvbnRleHQpKG51bGwpO1xuTGlzdGJveENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxpc3Rib3hDb250ZXh0XCI7XG5mdW5jdGlvbiB1c2VMaXN0Ym94Q29udGV4dChjb21wb25lbnQpIHtcbiAgbGV0IGNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzAudXNlQ29udGV4dCkoTGlzdGJveENvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoYDwke2NvbXBvbmVudH0gLz4gaXMgbWlzc2luZyBhIHBhcmVudCA8TGlzdGJveCAvPiBjb21wb25lbnQuYCk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB1c2VMaXN0Ym94Q29udGV4dCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gc3RhdGVSZWR1Y2VyNChzdGF0ZTIsIGFjdGlvbikge1xuICByZXR1cm4gbWF0Y2goYWN0aW9uLnR5cGUsIHJlZHVjZXJzNCwgc3RhdGUyLCBhY3Rpb24pO1xufVxudmFyIERFRkFVTFRfTElTVEJPWF9UQUcgPSBpbXBvcnRfcmVhY3QzMC5GcmFnbWVudDtcbnZhciBMaXN0Ym94Um9vdCA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gTGlzdGJveChwcm9wcywgcmVmKSB7XG4gIGxldCB7XG4gICAgdmFsdWU6IGNvbnRyb2xsZWRWYWx1ZSxcbiAgICBkZWZhdWx0VmFsdWUsXG4gICAgbmFtZSxcbiAgICBvbkNoYW5nZTogY29udHJvbGxlZE9uQ2hhbmdlLFxuICAgIGJ5ID0gKGEsIHopID0+IGEgPT09IHosXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBob3Jpem9udGFsID0gZmFsc2UsXG4gICAgbXVsdGlwbGUgPSBmYWxzZSxcbiAgICAuLi50aGVpclByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgb3JpZW50YXRpb24gPSBob3Jpem9udGFsID8gXCJob3Jpem9udGFsXCIgOiBcInZlcnRpY2FsXCI7XG4gIGxldCBsaXN0Ym94UmVmID0gdXNlU3luY1JlZnMocmVmKTtcbiAgbGV0IFt2YWx1ZSwgb25DaGFuZ2VdID0gdXNlQ29udHJvbGxhYmxlKGNvbnRyb2xsZWRWYWx1ZSwgY29udHJvbGxlZE9uQ2hhbmdlLCBkZWZhdWx0VmFsdWUpO1xuICBsZXQgcmVkdWNlckJhZyA9ICgwLCBpbXBvcnRfcmVhY3QzMC51c2VSZWR1Y2VyKShzdGF0ZVJlZHVjZXI0LCB7XG4gICAgbGlzdGJveFN0YXRlOiAxIC8qIENsb3NlZCAqLyxcbiAgICBwcm9wc1JlZjoge1xuICAgICAgY3VycmVudDoge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIG1vZGU6IG11bHRpcGxlID8gMSAvKiBNdWx0aSAqLyA6IDAgLyogU2luZ2xlICovLFxuICAgICAgICBjb21wYXJlOiB1c2VFdmVudCh0eXBlb2YgYnkgPT09IFwic3RyaW5nXCIgPyAoYSwgeikgPT4ge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGJ5O1xuICAgICAgICAgIHJldHVybiAoYSA9PSBudWxsID8gdm9pZCAwIDogYVtwcm9wZXJ0eV0pID09PSAoeiA9PSBudWxsID8gdm9pZCAwIDogeltwcm9wZXJ0eV0pO1xuICAgICAgICB9IDogYnkpXG4gICAgICB9XG4gICAgfSxcbiAgICBsYWJlbFJlZjogKDAsIGltcG9ydF9yZWFjdDMwLmNyZWF0ZVJlZikoKSxcbiAgICBidXR0b25SZWY6ICgwLCBpbXBvcnRfcmVhY3QzMC5jcmVhdGVSZWYpKCksXG4gICAgb3B0aW9uc1JlZjogKDAsIGltcG9ydF9yZWFjdDMwLmNyZWF0ZVJlZikoKSxcbiAgICBkaXNhYmxlZCxcbiAgICBvcmllbnRhdGlvbixcbiAgICBvcHRpb25zOiBbXSxcbiAgICBzZWFyY2hRdWVyeTogXCJcIixcbiAgICBhY3RpdmVPcHRpb25JbmRleDogbnVsbCxcbiAgICBhY3RpdmF0aW9uVHJpZ2dlcjogMSAvKiBPdGhlciAqL1xuICB9KTtcbiAgbGV0IFt7IGxpc3Rib3hTdGF0ZSwgcHJvcHNSZWYsIG9wdGlvbnNSZWYsIGJ1dHRvblJlZiB9LCBkaXNwYXRjaF0gPSByZWR1Y2VyQmFnO1xuICBwcm9wc1JlZi5jdXJyZW50LnZhbHVlID0gdmFsdWU7XG4gIHByb3BzUmVmLmN1cnJlbnQubW9kZSA9IG11bHRpcGxlID8gMSAvKiBNdWx0aSAqLyA6IDAgLyogU2luZ2xlICovO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBwcm9wc1JlZi5jdXJyZW50Lm9uQ2hhbmdlID0gKHZhbHVlMikgPT4ge1xuICAgICAgcmV0dXJuIG1hdGNoKHByb3BzUmVmLmN1cnJlbnQubW9kZSwge1xuICAgICAgICBbMCAvKiBTaW5nbGUgKi9dKCkge1xuICAgICAgICAgIHJldHVybiBvbkNoYW5nZSh2YWx1ZTIpO1xuICAgICAgICB9LFxuICAgICAgICBbMSAvKiBNdWx0aSAqL10oKSB7XG4gICAgICAgICAgbGV0IGNvcHkgPSBwcm9wc1JlZi5jdXJyZW50LnZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgbGV0IHsgY29tcGFyZSB9ID0gcHJvcHNSZWYuY3VycmVudDtcbiAgICAgICAgICBsZXQgaWR4ID0gY29weS5maW5kSW5kZXgoKGl0ZW0pID0+IGNvbXBhcmUoaXRlbSwgdmFsdWUyKSk7XG4gICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvcHkucHVzaCh2YWx1ZTIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3B5LnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb25DaGFuZ2UoY29weSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtvbkNoYW5nZSwgcHJvcHNSZWZdKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDIgLyogU2V0RGlzYWJsZWQgKi8sIGRpc2FibGVkIH0pLCBbZGlzYWJsZWRdKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDMgLyogU2V0T3JpZW50YXRpb24gKi8sIG9yaWVudGF0aW9uIH0pLCBbb3JpZW50YXRpb25dKTtcbiAgdXNlT3V0c2lkZUNsaWNrKFtidXR0b25SZWYsIG9wdGlvbnNSZWZdLCAoZXZlbnQsIHRhcmdldCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlTGlzdGJveCAqLyB9KTtcbiAgICBpZiAoIWlzRm9jdXNhYmxlRWxlbWVudCh0YXJnZXQsIDEgLyogTG9vc2UgKi8pKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgKF9hMiA9IGJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZvY3VzKCk7XG4gICAgfVxuICB9LCBsaXN0Ym94U3RhdGUgPT09IDAgLyogT3BlbiAqLyk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDMwLnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IGxpc3Rib3hTdGF0ZSA9PT0gMCAvKiBPcGVuICovLCBkaXNhYmxlZCwgdmFsdWUgfSksIFtsaXN0Ym94U3RhdGUsIGRpc2FibGVkLCB2YWx1ZV0pO1xuICBsZXQgb3VyUHJvcHMgPSB7IHJlZjogbGlzdGJveFJlZiB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDMwLmRlZmF1bHQuY3JlYXRlRWxlbWVudChMaXN0Ym94Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZWR1Y2VyQmFnXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzMC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoT3BlbkNsb3NlZFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG1hdGNoKGxpc3Rib3hTdGF0ZSwge1xuICAgICAgWzAgLyogT3BlbiAqL106IDAgLyogT3BlbiAqLyxcbiAgICAgIFsxIC8qIENsb3NlZCAqL106IDEgLyogQ2xvc2VkICovXG4gICAgfSlcbiAgfSwgbmFtZSAhPSBudWxsICYmIHZhbHVlICE9IG51bGwgJiYgb2JqZWN0VG9Gb3JtRW50cmllcyh7IFtuYW1lXTogdmFsdWUgfSkubWFwKChbbmFtZTIsIHZhbHVlMl0pID0+IC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzMC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSGlkZGVuLCB7XG4gICAgZmVhdHVyZXM6IDQgLyogSGlkZGVuICovLFxuICAgIC4uLmNvbXBhY3Qoe1xuICAgICAga2V5OiBuYW1lMixcbiAgICAgIGFzOiBcImlucHV0XCIsXG4gICAgICB0eXBlOiBcImhpZGRlblwiLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICBuYW1lOiBuYW1lMixcbiAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICB9KVxuICB9KSksIHJlbmRlcih7IG91clByb3BzLCB0aGVpclByb3BzLCBzbG90LCBkZWZhdWx0VGFnOiBERUZBVUxUX0xJU1RCT1hfVEFHLCBuYW1lOiBcIkxpc3Rib3hcIiB9KSkpO1xufSk7XG52YXIgREVGQVVMVF9CVVRUT05fVEFHMyA9IFwiYnV0dG9uXCI7XG52YXIgQnV0dG9uNSA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gQnV0dG9uNihwcm9wcywgcmVmKSB7XG4gIHZhciBfYTI7XG4gIGxldCBbc3RhdGUyLCBkaXNwYXRjaF0gPSB1c2VMaXN0Ym94Q29udGV4dChcIkxpc3Rib3guQnV0dG9uXCIpO1xuICBsZXQgYnV0dG9uUmVmID0gdXNlU3luY1JlZnMoc3RhdGUyLmJ1dHRvblJlZiwgcmVmKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLWxpc3Rib3gtYnV0dG9uLSR7dXNlSWQoKX1gO1xuICBsZXQgZCA9IHVzZURpc3Bvc2FibGVzKCk7XG4gIGxldCBoYW5kbGVLZXlEb3duID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCIgXCIgLyogU3BhY2UgKi86XG4gICAgICBjYXNlIFwiRW50ZXJcIiAvKiBFbnRlciAqLzpcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIiAvKiBBcnJvd0Rvd24gKi86XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogMCAvKiBPcGVuTGlzdGJveCAqLyB9KTtcbiAgICAgICAgZC5uZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmICghc3RhdGUyLnByb3BzUmVmLmN1cnJlbnQudmFsdWUpXG4gICAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IDQgLyogR29Ub09wdGlvbiAqLywgZm9jdXM6IDAgLyogRmlyc3QgKi8gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCIgLyogQXJyb3dVcCAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAwIC8qIE9wZW5MaXN0Ym94ICovIH0pO1xuICAgICAgICBkLm5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdGF0ZTIucHJvcHNSZWYuY3VycmVudC52YWx1ZSlcbiAgICAgICAgICAgIGRpc3BhdGNoKHsgdHlwZTogNCAvKiBHb1RvT3B0aW9uICovLCBmb2N1czogMyAvKiBMYXN0ICovIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUtleVVwID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCIgXCIgLyogU3BhY2UgKi86XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG4gIGxldCBoYW5kbGVDbGljayA9IHVzZUV2ZW50KChldmVudCkgPT4ge1xuICAgIGlmIChpc0Rpc2FibGVkUmVhY3RJc3N1ZTc3MTEoZXZlbnQuY3VycmVudFRhcmdldCkpXG4gICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3RhdGUyLmxpc3Rib3hTdGF0ZSA9PT0gMCAvKiBPcGVuICovKSB7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IDEgLyogQ2xvc2VMaXN0Ym94ICovIH0pO1xuICAgICAgZC5uZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICByZXR1cm4gKF9hMyA9IHN0YXRlMi5idXR0b25SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogMCAvKiBPcGVuTGlzdGJveCAqLyB9KTtcbiAgICB9XG4gIH0pO1xuICBsZXQgbGFiZWxsZWRieSA9IHVzZUNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoIXN0YXRlMi5sYWJlbFJlZi5jdXJyZW50KVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gW3N0YXRlMi5sYWJlbFJlZi5jdXJyZW50LmlkLCBpZDJdLmpvaW4oXCIgXCIpO1xuICB9LCBbc3RhdGUyLmxhYmVsUmVmLmN1cnJlbnQsIGlkMl0pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QzMC51c2VNZW1vKSgoKSA9PiAoe1xuICAgIG9wZW46IHN0YXRlMi5saXN0Ym94U3RhdGUgPT09IDAgLyogT3BlbiAqLyxcbiAgICBkaXNhYmxlZDogc3RhdGUyLmRpc2FibGVkLFxuICAgIHZhbHVlOiBzdGF0ZTIucHJvcHNSZWYuY3VycmVudC52YWx1ZVxuICB9KSwgW3N0YXRlMl0pO1xuICBsZXQgdGhlaXJQcm9wcyA9IHByb3BzO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgcmVmOiBidXR0b25SZWYsXG4gICAgaWQ6IGlkMixcbiAgICB0eXBlOiB1c2VSZXNvbHZlQnV0dG9uVHlwZShwcm9wcywgc3RhdGUyLmJ1dHRvblJlZiksXG4gICAgXCJhcmlhLWhhc3BvcHVwXCI6IHRydWUsXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IChfYTIgPSBzdGF0ZTIub3B0aW9uc1JlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlkLFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiBzdGF0ZTIuZGlzYWJsZWQgPyB2b2lkIDAgOiBzdGF0ZTIubGlzdGJveFN0YXRlID09PSAwIC8qIE9wZW4gKi8sXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRieSxcbiAgICBkaXNhYmxlZDogc3RhdGUyLmRpc2FibGVkLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbktleVVwOiBoYW5kbGVLZXlVcCxcbiAgICBvbkNsaWNrOiBoYW5kbGVDbGlja1xuICB9O1xuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9CVVRUT05fVEFHMyxcbiAgICBuYW1lOiBcIkxpc3Rib3guQnV0dG9uXCJcbiAgfSk7XG59KTtcbnZhciBERUZBVUxUX0xBQkVMX1RBRzIgPSBcImxhYmVsXCI7XG52YXIgTGFiZWwzID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBMYWJlbDQocHJvcHMsIHJlZikge1xuICBsZXQgW3N0YXRlMl0gPSB1c2VMaXN0Ym94Q29udGV4dChcIkxpc3Rib3guTGFiZWxcIik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1saXN0Ym94LWxhYmVsLSR7dXNlSWQoKX1gO1xuICBsZXQgbGFiZWxSZWYgPSB1c2VTeW5jUmVmcyhzdGF0ZTIubGFiZWxSZWYsIHJlZik7XG4gIGxldCBoYW5kbGVDbGljayA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoX2EyID0gc3RhdGUyLmJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgfSk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDMwLnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IHN0YXRlMi5saXN0Ym94U3RhdGUgPT09IDAgLyogT3BlbiAqLywgZGlzYWJsZWQ6IHN0YXRlMi5kaXNhYmxlZCB9KSwgW3N0YXRlMl0pO1xuICBsZXQgdGhlaXJQcm9wcyA9IHByb3BzO1xuICBsZXQgb3VyUHJvcHMgPSB7IHJlZjogbGFiZWxSZWYsIGlkOiBpZDIsIG9uQ2xpY2s6IGhhbmRsZUNsaWNrIH07XG4gIHJldHVybiByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX0xBQkVMX1RBRzIsXG4gICAgbmFtZTogXCJMaXN0Ym94LkxhYmVsXCJcbiAgfSk7XG59KTtcbnZhciBERUZBVUxUX09QVElPTlNfVEFHMiA9IFwidWxcIjtcbnZhciBPcHRpb25zUmVuZGVyRmVhdHVyZXMyID0gMSAvKiBSZW5kZXJTdHJhdGVneSAqLyB8IDIgLyogU3RhdGljICovO1xudmFyIE9wdGlvbnMzID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBPcHRpb25zNChwcm9wcywgcmVmKSB7XG4gIHZhciBfYTI7XG4gIGxldCBbc3RhdGUyLCBkaXNwYXRjaF0gPSB1c2VMaXN0Ym94Q29udGV4dChcIkxpc3Rib3guT3B0aW9uc1wiKTtcbiAgbGV0IG9wdGlvbnNSZWYgPSB1c2VTeW5jUmVmcyhzdGF0ZTIub3B0aW9uc1JlZiwgcmVmKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLWxpc3Rib3gtb3B0aW9ucy0ke3VzZUlkKCl9YDtcbiAgbGV0IGQgPSB1c2VEaXNwb3NhYmxlcygpO1xuICBsZXQgc2VhcmNoRGlzcG9zYWJsZXMgPSB1c2VEaXNwb3NhYmxlcygpO1xuICBsZXQgdXNlc09wZW5DbG9zZWRTdGF0ZSA9IHVzZU9wZW5DbG9zZWQoKTtcbiAgbGV0IHZpc2libGUgPSAoKCkgPT4ge1xuICAgIGlmICh1c2VzT3BlbkNsb3NlZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdXNlc09wZW5DbG9zZWRTdGF0ZSA9PT0gMCAvKiBPcGVuICovO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUyLmxpc3Rib3hTdGF0ZSA9PT0gMCAvKiBPcGVuICovO1xuICB9KSgpO1xuICAoMCwgaW1wb3J0X3JlYWN0MzAudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgdmFyIF9hMztcbiAgICBsZXQgY29udGFpbmVyID0gc3RhdGUyLm9wdGlvbnNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNvbnRhaW5lcilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUyLmxpc3Rib3hTdGF0ZSAhPT0gMCAvKiBPcGVuICovKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjb250YWluZXIgPT09ICgoX2EzID0gZ2V0T3duZXJEb2N1bWVudChjb250YWluZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnRhaW5lci5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gIH0sIFtzdGF0ZTIubGlzdGJveFN0YXRlLCBzdGF0ZTIub3B0aW9uc1JlZl0pO1xuICBsZXQgaGFuZGxlS2V5RG93biA9IHVzZUV2ZW50KChldmVudCkgPT4ge1xuICAgIHNlYXJjaERpc3Bvc2FibGVzLmRpc3Bvc2UoKTtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIiBcIiAvKiBTcGFjZSAqLzpcbiAgICAgICAgaWYgKHN0YXRlMi5zZWFyY2hRdWVyeSAhPT0gXCJcIikge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHsgdHlwZTogNSAvKiBTZWFyY2ggKi8sIHZhbHVlOiBldmVudC5rZXkgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJFbnRlclwiIC8qIEVudGVyICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKHN0YXRlMi5hY3RpdmVPcHRpb25JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIGxldCB7IGRhdGFSZWYgfSA9IHN0YXRlMi5vcHRpb25zW3N0YXRlMi5hY3RpdmVPcHRpb25JbmRleF07XG4gICAgICAgICAgc3RhdGUyLnByb3BzUmVmLmN1cnJlbnQub25DaGFuZ2UoZGF0YVJlZi5jdXJyZW50LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUyLnByb3BzUmVmLmN1cnJlbnQubW9kZSA9PT0gMCAvKiBTaW5nbGUgKi8pIHtcbiAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IDEgLyogQ2xvc2VMaXN0Ym94ICovIH0pO1xuICAgICAgICAgIGRpc3Bvc2FibGVzKCkubmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgICByZXR1cm4gKF9hMyA9IHN0YXRlMi5idXR0b25SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG1hdGNoKHN0YXRlMi5vcmllbnRhdGlvbiwgeyB2ZXJ0aWNhbDogXCJBcnJvd0Rvd25cIiAvKiBBcnJvd0Rvd24gKi8sIGhvcml6b250YWw6IFwiQXJyb3dSaWdodFwiIC8qIEFycm93UmlnaHQgKi8gfSk6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2goeyB0eXBlOiA0IC8qIEdvVG9PcHRpb24gKi8sIGZvY3VzOiAyIC8qIE5leHQgKi8gfSk7XG4gICAgICBjYXNlIG1hdGNoKHN0YXRlMi5vcmllbnRhdGlvbiwgeyB2ZXJ0aWNhbDogXCJBcnJvd1VwXCIgLyogQXJyb3dVcCAqLywgaG9yaXpvbnRhbDogXCJBcnJvd0xlZnRcIiAvKiBBcnJvd0xlZnQgKi8gfSk6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2goeyB0eXBlOiA0IC8qIEdvVG9PcHRpb24gKi8sIGZvY3VzOiAxIC8qIFByZXZpb3VzICovIH0pO1xuICAgICAgY2FzZSBcIkhvbWVcIiAvKiBIb21lICovOlxuICAgICAgY2FzZSBcIlBhZ2VVcFwiIC8qIFBhZ2VVcCAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaCh7IHR5cGU6IDQgLyogR29Ub09wdGlvbiAqLywgZm9jdXM6IDAgLyogRmlyc3QgKi8gfSk7XG4gICAgICBjYXNlIFwiRW5kXCIgLyogRW5kICovOlxuICAgICAgY2FzZSBcIlBhZ2VEb3duXCIgLyogUGFnZURvd24gKi86XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2goeyB0eXBlOiA0IC8qIEdvVG9PcHRpb24gKi8sIGZvY3VzOiAzIC8qIExhc3QgKi8gfSk7XG4gICAgICBjYXNlIFwiRXNjYXBlXCIgLyogRXNjYXBlICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlTGlzdGJveCAqLyB9KTtcbiAgICAgICAgcmV0dXJuIGQubmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgIHJldHVybiAoX2EzID0gc3RhdGUyLmJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiVGFiXCIgLyogVGFiICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoZXZlbnQua2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpc3BhdGNoKHsgdHlwZTogNSAvKiBTZWFyY2ggKi8sIHZhbHVlOiBldmVudC5rZXkgfSk7XG4gICAgICAgICAgc2VhcmNoRGlzcG9zYWJsZXMuc2V0VGltZW91dCgoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDYgLyogQ2xlYXJTZWFyY2ggKi8gfSksIDM1MCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgbGV0IGxhYmVsbGVkYnkgPSB1c2VDb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hMywgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2EzID0gc3RhdGUyLmxhYmVsUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuaWQpICE9IG51bGwgPyBfYyA6IChfYiA9IHN0YXRlMi5idXR0b25SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmlkO1xuICB9LCBbc3RhdGUyLmxhYmVsUmVmLmN1cnJlbnQsIHN0YXRlMi5idXR0b25SZWYuY3VycmVudF0pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QzMC51c2VNZW1vKSgoKSA9PiAoeyBvcGVuOiBzdGF0ZTIubGlzdGJveFN0YXRlID09PSAwIC8qIE9wZW4gKi8gfSksIFtzdGF0ZTJdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0ge1xuICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IHN0YXRlMi5hY3RpdmVPcHRpb25JbmRleCA9PT0gbnVsbCA/IHZvaWQgMCA6IChfYTIgPSBzdGF0ZTIub3B0aW9uc1tzdGF0ZTIuYWN0aXZlT3B0aW9uSW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlkLFxuICAgIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogc3RhdGUyLnByb3BzUmVmLmN1cnJlbnQubW9kZSA9PT0gMSAvKiBNdWx0aSAqLyA/IHRydWUgOiB2b2lkIDAsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRieSxcbiAgICBcImFyaWEtb3JpZW50YXRpb25cIjogc3RhdGUyLm9yaWVudGF0aW9uLFxuICAgIGlkOiBpZDIsXG4gICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgIHJvbGU6IFwibGlzdGJveFwiLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIHJlZjogb3B0aW9uc1JlZlxuICB9O1xuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9PUFRJT05TX1RBRzIsXG4gICAgZmVhdHVyZXM6IE9wdGlvbnNSZW5kZXJGZWF0dXJlczIsXG4gICAgdmlzaWJsZSxcbiAgICBuYW1lOiBcIkxpc3Rib3guT3B0aW9uc1wiXG4gIH0pO1xufSk7XG52YXIgREVGQVVMVF9PUFRJT05fVEFHMiA9IFwibGlcIjtcbnZhciBPcHRpb24zID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBPcHRpb240KHByb3BzLCByZWYpIHtcbiAgbGV0IHsgZGlzYWJsZWQgPSBmYWxzZSwgdmFsdWUsIC4uLnRoZWlyUHJvcHMgfSA9IHByb3BzO1xuICBsZXQgW3N0YXRlMiwgZGlzcGF0Y2hdID0gdXNlTGlzdGJveENvbnRleHQoXCJMaXN0Ym94Lk9wdGlvblwiKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLWxpc3Rib3gtb3B0aW9uLSR7dXNlSWQoKX1gO1xuICBsZXQgYWN0aXZlID0gc3RhdGUyLmFjdGl2ZU9wdGlvbkluZGV4ICE9PSBudWxsID8gc3RhdGUyLm9wdGlvbnNbc3RhdGUyLmFjdGl2ZU9wdGlvbkluZGV4XS5pZCA9PT0gaWQyIDogZmFsc2U7XG4gIGxldCB7IHZhbHVlOiBvcHRpb25WYWx1ZSwgY29tcGFyZSB9ID0gc3RhdGUyLnByb3BzUmVmLmN1cnJlbnQ7XG4gIGxldCBzZWxlY3RlZCA9IG1hdGNoKHN0YXRlMi5wcm9wc1JlZi5jdXJyZW50Lm1vZGUsIHtcbiAgICBbMSAvKiBNdWx0aSAqL106ICgpID0+IG9wdGlvblZhbHVlLnNvbWUoKG9wdGlvbikgPT4gY29tcGFyZShvcHRpb24sIHZhbHVlKSksXG4gICAgWzAgLyogU2luZ2xlICovXTogKCkgPT4gY29tcGFyZShvcHRpb25WYWx1ZSwgdmFsdWUpXG4gIH0pO1xuICBsZXQgaW50ZXJuYWxPcHRpb25SZWYgPSAoMCwgaW1wb3J0X3JlYWN0MzAudXNlUmVmKShudWxsKTtcbiAgbGV0IG9wdGlvblJlZiA9IHVzZVN5bmNSZWZzKHJlZiwgaW50ZXJuYWxPcHRpb25SZWYpO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3RhdGUyLmxpc3Rib3hTdGF0ZSAhPT0gMCAvKiBPcGVuICovKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzdGF0ZTIuYWN0aXZhdGlvblRyaWdnZXIgPT09IDAgLyogUG9pbnRlciAqLylcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZCA9IGRpc3Bvc2FibGVzKCk7XG4gICAgZC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAoX2IgPSAoX2EyID0gaW50ZXJuYWxPcHRpb25SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zY3JvbGxJbnRvVmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB7IGJsb2NrOiBcIm5lYXJlc3RcIiB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZC5kaXNwb3NlO1xuICB9LCBbaW50ZXJuYWxPcHRpb25SZWYsIGFjdGl2ZSwgc3RhdGUyLmxpc3Rib3hTdGF0ZSwgc3RhdGUyLmFjdGl2YXRpb25UcmlnZ2VyLCBzdGF0ZTIuYWN0aXZlT3B0aW9uSW5kZXhdKTtcbiAgbGV0IGJhZyA9ICgwLCBpbXBvcnRfcmVhY3QzMC51c2VSZWYpKHsgZGlzYWJsZWQsIHZhbHVlLCBkb21SZWY6IGludGVybmFsT3B0aW9uUmVmIH0pO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBiYWcuY3VycmVudC5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICB9LCBbYmFnLCBkaXNhYmxlZF0pO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBiYWcuY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICB9LCBbYmFnLCB2YWx1ZV0pO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBiYWcuY3VycmVudC50ZXh0VmFsdWUgPSAoX2IgPSAoX2EyID0gaW50ZXJuYWxPcHRpb25SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50ZXh0Q29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvTG93ZXJDYXNlKCk7XG4gIH0sIFtiYWcsIGludGVybmFsT3B0aW9uUmVmXSk7XG4gIGxldCBzZWxlY3QgPSB1c2VFdmVudCgoKSA9PiBzdGF0ZTIucHJvcHNSZWYuY3VycmVudC5vbkNoYW5nZSh2YWx1ZSkpO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IDcgLyogUmVnaXN0ZXJPcHRpb24gKi8sIGlkOiBpZDIsIGRhdGFSZWY6IGJhZyB9KTtcbiAgICByZXR1cm4gKCkgPT4gZGlzcGF0Y2goeyB0eXBlOiA4IC8qIFVucmVnaXN0ZXJPcHRpb24gKi8sIGlkOiBpZDIgfSk7XG4gIH0sIFtiYWcsIGlkMl0pO1xuICBsZXQgaGFuZGxlQ2xpY2sgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpXG4gICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBzZWxlY3QoKTtcbiAgICBpZiAoc3RhdGUyLnByb3BzUmVmLmN1cnJlbnQubW9kZSA9PT0gMCAvKiBTaW5nbGUgKi8pIHtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogMSAvKiBDbG9zZUxpc3Rib3ggKi8gfSk7XG4gICAgICBkaXNwb3NhYmxlcygpLm5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gc3RhdGUyLmJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGxldCBoYW5kbGVGb2N1cyA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpXG4gICAgICByZXR1cm4gZGlzcGF0Y2goeyB0eXBlOiA0IC8qIEdvVG9PcHRpb24gKi8sIGZvY3VzOiA1IC8qIE5vdGhpbmcgKi8gfSk7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiA0IC8qIEdvVG9PcHRpb24gKi8sIGZvY3VzOiA0IC8qIFNwZWNpZmljICovLCBpZDogaWQyIH0pO1xuICB9KTtcbiAgbGV0IGhhbmRsZU1vdmUgPSB1c2VFdmVudCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChhY3RpdmUpXG4gICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogNCAvKiBHb1RvT3B0aW9uICovLFxuICAgICAgZm9jdXM6IDQgLyogU3BlY2lmaWMgKi8sXG4gICAgICBpZDogaWQyLFxuICAgICAgdHJpZ2dlcjogMCAvKiBQb2ludGVyICovXG4gICAgfSk7XG4gIH0pO1xuICBsZXQgaGFuZGxlTGVhdmUgPSB1c2VFdmVudCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogNCAvKiBHb1RvT3B0aW9uICovLCBmb2N1czogNSAvKiBOb3RoaW5nICovIH0pO1xuICB9KTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MzAudXNlTWVtbykoKCkgPT4gKHsgYWN0aXZlLCBzZWxlY3RlZCwgZGlzYWJsZWQgfSksIFthY3RpdmUsIHNlbGVjdGVkLCBkaXNhYmxlZF0pO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgaWQ6IGlkMixcbiAgICByZWY6IG9wdGlvblJlZixcbiAgICByb2xlOiBcIm9wdGlvblwiLFxuICAgIHRhYkluZGV4OiBkaXNhYmxlZCA9PT0gdHJ1ZSA/IHZvaWQgMCA6IC0xLFxuICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA9PT0gdHJ1ZSA/IHRydWUgOiB2b2lkIDAsXG4gICAgXCJhcmlhLXNlbGVjdGVkXCI6IHNlbGVjdGVkLFxuICAgIGRpc2FibGVkOiB2b2lkIDAsXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgb25Gb2N1czogaGFuZGxlRm9jdXMsXG4gICAgb25Qb2ludGVyTW92ZTogaGFuZGxlTW92ZSxcbiAgICBvbk1vdXNlTW92ZTogaGFuZGxlTW92ZSxcbiAgICBvblBvaW50ZXJMZWF2ZTogaGFuZGxlTGVhdmUsXG4gICAgb25Nb3VzZUxlYXZlOiBoYW5kbGVMZWF2ZVxuICB9O1xuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9PUFRJT05fVEFHMixcbiAgICBuYW1lOiBcIkxpc3Rib3guT3B0aW9uXCJcbiAgfSk7XG59KTtcbnZhciBMaXN0Ym94MiA9IE9iamVjdC5hc3NpZ24oTGlzdGJveFJvb3QsIHsgQnV0dG9uOiBCdXR0b241LCBMYWJlbDogTGFiZWwzLCBPcHRpb25zOiBPcHRpb25zMywgT3B0aW9uOiBPcHRpb24zIH0pO1xuXG4vLyBzcmMvY29tcG9uZW50cy9tZW51L21lbnUudHN4XG52YXIgaW1wb3J0X3JlYWN0MzEgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSwgMSk7XG5mdW5jdGlvbiBhZGp1c3RPcmRlcmVkU3RhdGUzKHN0YXRlMiwgYWRqdXN0bWVudCA9IChpKSA9PiBpKSB7XG4gIGxldCBjdXJyZW50QWN0aXZlSXRlbSA9IHN0YXRlMi5hY3RpdmVJdGVtSW5kZXggIT09IG51bGwgPyBzdGF0ZTIuaXRlbXNbc3RhdGUyLmFjdGl2ZUl0ZW1JbmRleF0gOiBudWxsO1xuICBsZXQgc29ydGVkSXRlbXMgPSBzb3J0QnlEb21Ob2RlKGFkanVzdG1lbnQoc3RhdGUyLml0ZW1zLnNsaWNlKCkpLCAoaXRlbSkgPT4gaXRlbS5kYXRhUmVmLmN1cnJlbnQuZG9tUmVmLmN1cnJlbnQpO1xuICBsZXQgYWRqdXN0ZWRBY3RpdmVJdGVtSW5kZXggPSBjdXJyZW50QWN0aXZlSXRlbSA/IHNvcnRlZEl0ZW1zLmluZGV4T2YoY3VycmVudEFjdGl2ZUl0ZW0pIDogbnVsbDtcbiAgaWYgKGFkanVzdGVkQWN0aXZlSXRlbUluZGV4ID09PSAtMSkge1xuICAgIGFkanVzdGVkQWN0aXZlSXRlbUluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGl0ZW1zOiBzb3J0ZWRJdGVtcyxcbiAgICBhY3RpdmVJdGVtSW5kZXg6IGFkanVzdGVkQWN0aXZlSXRlbUluZGV4XG4gIH07XG59XG52YXIgcmVkdWNlcnM1ID0ge1xuICBbMSAvKiBDbG9zZU1lbnUgKi9dKHN0YXRlMikge1xuICAgIGlmIChzdGF0ZTIubWVudVN0YXRlID09PSAxIC8qIENsb3NlZCAqLylcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBhY3RpdmVJdGVtSW5kZXg6IG51bGwsIG1lbnVTdGF0ZTogMSAvKiBDbG9zZWQgKi8gfTtcbiAgfSxcbiAgWzAgLyogT3Blbk1lbnUgKi9dKHN0YXRlMikge1xuICAgIGlmIChzdGF0ZTIubWVudVN0YXRlID09PSAwIC8qIE9wZW4gKi8pXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIHJldHVybiB7IC4uLnN0YXRlMiwgbWVudVN0YXRlOiAwIC8qIE9wZW4gKi8gfTtcbiAgfSxcbiAgWzIgLyogR29Ub0l0ZW0gKi9dOiAoc3RhdGUyLCBhY3Rpb24pID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGxldCBhZGp1c3RlZFN0YXRlID0gYWRqdXN0T3JkZXJlZFN0YXRlMyhzdGF0ZTIpO1xuICAgIGxldCBhY3RpdmVJdGVtSW5kZXggPSBjYWxjdWxhdGVBY3RpdmVJbmRleChhY3Rpb24sIHtcbiAgICAgIHJlc29sdmVJdGVtczogKCkgPT4gYWRqdXN0ZWRTdGF0ZS5pdGVtcyxcbiAgICAgIHJlc29sdmVBY3RpdmVJbmRleDogKCkgPT4gYWRqdXN0ZWRTdGF0ZS5hY3RpdmVJdGVtSW5kZXgsXG4gICAgICByZXNvbHZlSWQ6IChpdGVtKSA9PiBpdGVtLmlkLFxuICAgICAgcmVzb2x2ZURpc2FibGVkOiAoaXRlbSkgPT4gaXRlbS5kYXRhUmVmLmN1cnJlbnQuZGlzYWJsZWRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUyLFxuICAgICAgLi4uYWRqdXN0ZWRTdGF0ZSxcbiAgICAgIHNlYXJjaFF1ZXJ5OiBcIlwiLFxuICAgICAgYWN0aXZlSXRlbUluZGV4LFxuICAgICAgYWN0aXZhdGlvblRyaWdnZXI6IChfYTIgPSBhY3Rpb24udHJpZ2dlcikgIT0gbnVsbCA/IF9hMiA6IDEgLyogT3RoZXIgKi9cbiAgICB9O1xuICB9LFxuICBbMyAvKiBTZWFyY2ggKi9dOiAoc3RhdGUyLCBhY3Rpb24pID0+IHtcbiAgICBsZXQgd2FzQWxyZWFkeVNlYXJjaGluZyA9IHN0YXRlMi5zZWFyY2hRdWVyeSAhPT0gXCJcIjtcbiAgICBsZXQgb2Zmc2V0ID0gd2FzQWxyZWFkeVNlYXJjaGluZyA/IDAgOiAxO1xuICAgIGxldCBzZWFyY2hRdWVyeSA9IHN0YXRlMi5zZWFyY2hRdWVyeSArIGFjdGlvbi52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZU9yZGVyZWRJdGVtcyA9IHN0YXRlMi5hY3RpdmVJdGVtSW5kZXggIT09IG51bGwgPyBzdGF0ZTIuaXRlbXMuc2xpY2Uoc3RhdGUyLmFjdGl2ZUl0ZW1JbmRleCArIG9mZnNldCkuY29uY2F0KHN0YXRlMi5pdGVtcy5zbGljZSgwLCBzdGF0ZTIuYWN0aXZlSXRlbUluZGV4ICsgb2Zmc2V0KSkgOiBzdGF0ZTIuaXRlbXM7XG4gICAgbGV0IG1hdGNoaW5nSXRlbSA9IHJlT3JkZXJlZEl0ZW1zLmZpbmQoKGl0ZW0pID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKChfYTIgPSBpdGVtLmRhdGFSZWYuY3VycmVudC50ZXh0VmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc3RhcnRzV2l0aChzZWFyY2hRdWVyeSkpICYmICFpdGVtLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZDtcbiAgICB9KTtcbiAgICBsZXQgbWF0Y2hJZHggPSBtYXRjaGluZ0l0ZW0gPyBzdGF0ZTIuaXRlbXMuaW5kZXhPZihtYXRjaGluZ0l0ZW0pIDogLTE7XG4gICAgaWYgKG1hdGNoSWR4ID09PSAtMSB8fCBtYXRjaElkeCA9PT0gc3RhdGUyLmFjdGl2ZUl0ZW1JbmRleClcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlMiwgc2VhcmNoUXVlcnkgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUyLFxuICAgICAgc2VhcmNoUXVlcnksXG4gICAgICBhY3RpdmVJdGVtSW5kZXg6IG1hdGNoSWR4LFxuICAgICAgYWN0aXZhdGlvblRyaWdnZXI6IDEgLyogT3RoZXIgKi9cbiAgICB9O1xuICB9LFxuICBbNCAvKiBDbGVhclNlYXJjaCAqL10oc3RhdGUyKSB7XG4gICAgaWYgKHN0YXRlMi5zZWFyY2hRdWVyeSA9PT0gXCJcIilcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBzZWFyY2hRdWVyeTogXCJcIiwgc2VhcmNoQWN0aXZlSXRlbUluZGV4OiBudWxsIH07XG4gIH0sXG4gIFs1IC8qIFJlZ2lzdGVySXRlbSAqL106IChzdGF0ZTIsIGFjdGlvbikgPT4ge1xuICAgIGxldCBhZGp1c3RlZFN0YXRlID0gYWRqdXN0T3JkZXJlZFN0YXRlMyhzdGF0ZTIsIChpdGVtcykgPT4gW1xuICAgICAgLi4uaXRlbXMsXG4gICAgICB7IGlkOiBhY3Rpb24uaWQsIGRhdGFSZWY6IGFjdGlvbi5kYXRhUmVmIH1cbiAgICBdKTtcbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIC4uLmFkanVzdGVkU3RhdGUgfTtcbiAgfSxcbiAgWzYgLyogVW5yZWdpc3Rlckl0ZW0gKi9dOiAoc3RhdGUyLCBhY3Rpb24pID0+IHtcbiAgICBsZXQgYWRqdXN0ZWRTdGF0ZSA9IGFkanVzdE9yZGVyZWRTdGF0ZTMoc3RhdGUyLCAoaXRlbXMpID0+IHtcbiAgICAgIGxldCBpZHggPSBpdGVtcy5maW5kSW5kZXgoKGEpID0+IGEuaWQgPT09IGFjdGlvbi5pZCk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSlcbiAgICAgICAgaXRlbXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlMixcbiAgICAgIC4uLmFkanVzdGVkU3RhdGUsXG4gICAgICBhY3RpdmF0aW9uVHJpZ2dlcjogMSAvKiBPdGhlciAqL1xuICAgIH07XG4gIH1cbn07XG52YXIgTWVudUNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzEuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5NZW51Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTWVudUNvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZU1lbnVDb250ZXh0KGNvbXBvbmVudCkge1xuICBsZXQgY29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzMS51c2VDb250ZXh0KShNZW51Q29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgbGV0IGVyciA9IG5ldyBFcnJvcihgPCR7Y29tcG9uZW50fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxNZW51IC8+IGNvbXBvbmVudC5gKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHVzZU1lbnVDb250ZXh0KTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBzdGF0ZVJlZHVjZXI1KHN0YXRlMiwgYWN0aW9uKSB7XG4gIHJldHVybiBtYXRjaChhY3Rpb24udHlwZSwgcmVkdWNlcnM1LCBzdGF0ZTIsIGFjdGlvbik7XG59XG52YXIgREVGQVVMVF9NRU5VX1RBRyA9IGltcG9ydF9yZWFjdDMxLkZyYWdtZW50O1xudmFyIE1lbnVSb290ID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBNZW51KHByb3BzLCByZWYpIHtcbiAgbGV0IHJlZHVjZXJCYWcgPSAoMCwgaW1wb3J0X3JlYWN0MzEudXNlUmVkdWNlcikoc3RhdGVSZWR1Y2VyNSwge1xuICAgIG1lbnVTdGF0ZTogMSAvKiBDbG9zZWQgKi8sXG4gICAgYnV0dG9uUmVmOiAoMCwgaW1wb3J0X3JlYWN0MzEuY3JlYXRlUmVmKSgpLFxuICAgIGl0ZW1zUmVmOiAoMCwgaW1wb3J0X3JlYWN0MzEuY3JlYXRlUmVmKSgpLFxuICAgIGl0ZW1zOiBbXSxcbiAgICBzZWFyY2hRdWVyeTogXCJcIixcbiAgICBhY3RpdmVJdGVtSW5kZXg6IG51bGwsXG4gICAgYWN0aXZhdGlvblRyaWdnZXI6IDEgLyogT3RoZXIgKi9cbiAgfSk7XG4gIGxldCBbeyBtZW51U3RhdGUsIGl0ZW1zUmVmLCBidXR0b25SZWYgfSwgZGlzcGF0Y2hdID0gcmVkdWNlckJhZztcbiAgbGV0IG1lbnVSZWYgPSB1c2VTeW5jUmVmcyhyZWYpO1xuICB1c2VPdXRzaWRlQ2xpY2soW2J1dHRvblJlZiwgaXRlbXNSZWZdLCAoZXZlbnQsIHRhcmdldCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlTWVudSAqLyB9KTtcbiAgICBpZiAoIWlzRm9jdXNhYmxlRWxlbWVudCh0YXJnZXQsIDEgLyogTG9vc2UgKi8pKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgKF9hMiA9IGJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZvY3VzKCk7XG4gICAgfVxuICB9LCBtZW51U3RhdGUgPT09IDAgLyogT3BlbiAqLyk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDMxLnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IG1lbnVTdGF0ZSA9PT0gMCAvKiBPcGVuICovIH0pLCBbbWVudVN0YXRlXSk7XG4gIGxldCB0aGVpclByb3BzID0gcHJvcHM7XG4gIGxldCBvdXJQcm9wcyA9IHsgcmVmOiBtZW51UmVmIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lbnVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlZHVjZXJCYWdcbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDMxLmRlZmF1bHQuY3JlYXRlRWxlbWVudChPcGVuQ2xvc2VkUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbWF0Y2gobWVudVN0YXRlLCB7XG4gICAgICBbMCAvKiBPcGVuICovXTogMCAvKiBPcGVuICovLFxuICAgICAgWzEgLyogQ2xvc2VkICovXTogMSAvKiBDbG9zZWQgKi9cbiAgICB9KVxuICB9LCByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX01FTlVfVEFHLFxuICAgIG5hbWU6IFwiTWVudVwiXG4gIH0pKSk7XG59KTtcbnZhciBERUZBVUxUX0JVVFRPTl9UQUc0ID0gXCJidXR0b25cIjtcbnZhciBCdXR0b243ID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBCdXR0b244KHByb3BzLCByZWYpIHtcbiAgdmFyIF9hMjtcbiAgbGV0IFtzdGF0ZTIsIGRpc3BhdGNoXSA9IHVzZU1lbnVDb250ZXh0KFwiTWVudS5CdXR0b25cIik7XG4gIGxldCBidXR0b25SZWYgPSB1c2VTeW5jUmVmcyhzdGF0ZTIuYnV0dG9uUmVmLCByZWYpO1xuICBsZXQgaWQyID0gYGhlYWRsZXNzdWktbWVudS1idXR0b24tJHt1c2VJZCgpfWA7XG4gIGxldCBkID0gdXNlRGlzcG9zYWJsZXMoKTtcbiAgbGV0IGhhbmRsZUtleURvd24gPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIiBcIiAvKiBTcGFjZSAqLzpcbiAgICAgIGNhc2UgXCJFbnRlclwiIC8qIEVudGVyICovOlxuICAgICAgY2FzZSBcIkFycm93RG93blwiIC8qIEFycm93RG93biAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogMCAvKiBPcGVuTWVudSAqLyB9KTtcbiAgICAgICAgZC5uZXh0RnJhbWUoKCkgPT4gZGlzcGF0Y2goeyB0eXBlOiAyIC8qIEdvVG9JdGVtICovLCBmb2N1czogMCAvKiBGaXJzdCAqLyB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93VXBcIiAvKiBBcnJvd1VwICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAwIC8qIE9wZW5NZW51ICovIH0pO1xuICAgICAgICBkLm5leHRGcmFtZSgoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDIgLyogR29Ub0l0ZW0gKi8sIGZvY3VzOiAzIC8qIExhc3QgKi8gfSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICBsZXQgaGFuZGxlS2V5VXAgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIiBcIiAvKiBTcGFjZSAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUNsaWNrID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGlzRGlzYWJsZWRSZWFjdElzc3VlNzcxMShldmVudC5jdXJyZW50VGFyZ2V0KSlcbiAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChwcm9wcy5kaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUyLm1lbnVTdGF0ZSA9PT0gMCAvKiBPcGVuICovKSB7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IDEgLyogQ2xvc2VNZW51ICovIH0pO1xuICAgICAgZC5uZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICByZXR1cm4gKF9hMyA9IHN0YXRlMi5idXR0b25SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogMCAvKiBPcGVuTWVudSAqLyB9KTtcbiAgICB9XG4gIH0pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QzMS51c2VNZW1vKSgoKSA9PiAoeyBvcGVuOiBzdGF0ZTIubWVudVN0YXRlID09PSAwIC8qIE9wZW4gKi8gfSksIFtzdGF0ZTJdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0ge1xuICAgIHJlZjogYnV0dG9uUmVmLFxuICAgIGlkOiBpZDIsXG4gICAgdHlwZTogdXNlUmVzb2x2ZUJ1dHRvblR5cGUocHJvcHMsIHN0YXRlMi5idXR0b25SZWYpLFxuICAgIFwiYXJpYS1oYXNwb3B1cFwiOiB0cnVlLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiAoX2EyID0gc3RhdGUyLml0ZW1zUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaWQsXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6IHByb3BzLmRpc2FibGVkID8gdm9pZCAwIDogc3RhdGUyLm1lbnVTdGF0ZSA9PT0gMCAvKiBPcGVuICovLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbktleVVwOiBoYW5kbGVLZXlVcCxcbiAgICBvbkNsaWNrOiBoYW5kbGVDbGlja1xuICB9O1xuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9CVVRUT05fVEFHNCxcbiAgICBuYW1lOiBcIk1lbnUuQnV0dG9uXCJcbiAgfSk7XG59KTtcbnZhciBERUZBVUxUX0lURU1TX1RBRyA9IFwiZGl2XCI7XG52YXIgSXRlbXNSZW5kZXJGZWF0dXJlcyA9IDEgLyogUmVuZGVyU3RyYXRlZ3kgKi8gfCAyIC8qIFN0YXRpYyAqLztcbnZhciBJdGVtcyA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gSXRlbXMyKHByb3BzLCByZWYpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIGxldCBbc3RhdGUyLCBkaXNwYXRjaF0gPSB1c2VNZW51Q29udGV4dChcIk1lbnUuSXRlbXNcIik7XG4gIGxldCBpdGVtc1JlZiA9IHVzZVN5bmNSZWZzKHN0YXRlMi5pdGVtc1JlZiwgcmVmKTtcbiAgbGV0IG93bmVyRG9jdW1lbnQgPSB1c2VPd25lckRvY3VtZW50KHN0YXRlMi5pdGVtc1JlZik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1tZW51LWl0ZW1zLSR7dXNlSWQoKX1gO1xuICBsZXQgc2VhcmNoRGlzcG9zYWJsZXMgPSB1c2VEaXNwb3NhYmxlcygpO1xuICBsZXQgdXNlc09wZW5DbG9zZWRTdGF0ZSA9IHVzZU9wZW5DbG9zZWQoKTtcbiAgbGV0IHZpc2libGUgPSAoKCkgPT4ge1xuICAgIGlmICh1c2VzT3BlbkNsb3NlZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdXNlc09wZW5DbG9zZWRTdGF0ZSA9PT0gMCAvKiBPcGVuICovO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUyLm1lbnVTdGF0ZSA9PT0gMCAvKiBPcGVuICovO1xuICB9KSgpO1xuICAoMCwgaW1wb3J0X3JlYWN0MzEudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgbGV0IGNvbnRhaW5lciA9IHN0YXRlMi5pdGVtc1JlZi5jdXJyZW50O1xuICAgIGlmICghY29udGFpbmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzdGF0ZTIubWVudVN0YXRlICE9PSAwIC8qIE9wZW4gKi8pXG4gICAgICByZXR1cm47XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gKG93bmVyRG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpXG4gICAgICByZXR1cm47XG4gICAgY29udGFpbmVyLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgfSwgW3N0YXRlMi5tZW51U3RhdGUsIHN0YXRlMi5pdGVtc1JlZiwgb3duZXJEb2N1bWVudF0pO1xuICB1c2VUcmVlV2Fsa2VyKHtcbiAgICBjb250YWluZXI6IHN0YXRlMi5pdGVtc1JlZi5jdXJyZW50LFxuICAgIGVuYWJsZWQ6IHN0YXRlMi5tZW51U3RhdGUgPT09IDAgLyogT3BlbiAqLyxcbiAgICBhY2NlcHQobm9kZSkge1xuICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJtZW51aXRlbVwiKVxuICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKFwicm9sZVwiKSlcbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH0sXG4gICAgd2Fsayhub2RlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJub25lXCIpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBoYW5kbGVLZXlEb3duID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hMywgX2IyO1xuICAgIHNlYXJjaERpc3Bvc2FibGVzLmRpc3Bvc2UoKTtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIiBcIiAvKiBTcGFjZSAqLzpcbiAgICAgICAgaWYgKHN0YXRlMi5zZWFyY2hRdWVyeSAhPT0gXCJcIikge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHsgdHlwZTogMyAvKiBTZWFyY2ggKi8sIHZhbHVlOiBldmVudC5rZXkgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJFbnRlclwiIC8qIEVudGVyICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlTWVudSAqLyB9KTtcbiAgICAgICAgaWYgKHN0YXRlMi5hY3RpdmVJdGVtSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBsZXQgeyBkYXRhUmVmIH0gPSBzdGF0ZTIuaXRlbXNbc3RhdGUyLmFjdGl2ZUl0ZW1JbmRleF07XG4gICAgICAgICAgKF9iMiA9IChfYTMgPSBkYXRhUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZG9tUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXN0b3JlRm9jdXNJZk5lY2Vzc2FyeShzdGF0ZTIuYnV0dG9uUmVmLmN1cnJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIiAvKiBBcnJvd0Rvd24gKi86XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2goeyB0eXBlOiAyIC8qIEdvVG9JdGVtICovLCBmb2N1czogMiAvKiBOZXh0ICovIH0pO1xuICAgICAgY2FzZSBcIkFycm93VXBcIiAvKiBBcnJvd1VwICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHsgdHlwZTogMiAvKiBHb1RvSXRlbSAqLywgZm9jdXM6IDEgLyogUHJldmlvdXMgKi8gfSk7XG4gICAgICBjYXNlIFwiSG9tZVwiIC8qIEhvbWUgKi86XG4gICAgICBjYXNlIFwiUGFnZVVwXCIgLyogUGFnZVVwICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHsgdHlwZTogMiAvKiBHb1RvSXRlbSAqLywgZm9jdXM6IDAgLyogRmlyc3QgKi8gfSk7XG4gICAgICBjYXNlIFwiRW5kXCIgLyogRW5kICovOlxuICAgICAgY2FzZSBcIlBhZ2VEb3duXCIgLyogUGFnZURvd24gKi86XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2goeyB0eXBlOiAyIC8qIEdvVG9JdGVtICovLCBmb2N1czogMyAvKiBMYXN0ICovIH0pO1xuICAgICAgY2FzZSBcIkVzY2FwZVwiIC8qIEVzY2FwZSAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogMSAvKiBDbG9zZU1lbnUgKi8gfSk7XG4gICAgICAgIGRpc3Bvc2FibGVzKCkubmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICB2YXIgX2E0O1xuICAgICAgICAgIHJldHVybiAoX2E0ID0gc3RhdGUyLmJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2E0LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlRhYlwiIC8qIFRhYiAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogMSAvKiBDbG9zZU1lbnUgKi8gfSk7XG4gICAgICAgIGRpc3Bvc2FibGVzKCkubmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICBmb2N1c0Zyb20oc3RhdGUyLmJ1dHRvblJlZi5jdXJyZW50LCBldmVudC5zaGlmdEtleSA/IDIgLyogUHJldmlvdXMgKi8gOiA0IC8qIE5leHQgKi8pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoZXZlbnQua2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpc3BhdGNoKHsgdHlwZTogMyAvKiBTZWFyY2ggKi8sIHZhbHVlOiBldmVudC5rZXkgfSk7XG4gICAgICAgICAgc2VhcmNoRGlzcG9zYWJsZXMuc2V0VGltZW91dCgoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDQgLyogQ2xlYXJTZWFyY2ggKi8gfSksIDM1MCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUtleVVwID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCIgXCIgLyogU3BhY2UgKi86XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDMxLnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IHN0YXRlMi5tZW51U3RhdGUgPT09IDAgLyogT3BlbiAqLyB9KSwgW3N0YXRlMl0pO1xuICBsZXQgdGhlaXJQcm9wcyA9IHByb3BzO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogc3RhdGUyLmFjdGl2ZUl0ZW1JbmRleCA9PT0gbnVsbCA/IHZvaWQgMCA6IChfYTIgPSBzdGF0ZTIuaXRlbXNbc3RhdGUyLmFjdGl2ZUl0ZW1JbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaWQsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogKF9iID0gc3RhdGUyLmJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuaWQsXG4gICAgaWQ6IGlkMixcbiAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgb25LZXlVcDogaGFuZGxlS2V5VXAsXG4gICAgcm9sZTogXCJtZW51XCIsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgcmVmOiBpdGVtc1JlZlxuICB9O1xuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9JVEVNU19UQUcsXG4gICAgZmVhdHVyZXM6IEl0ZW1zUmVuZGVyRmVhdHVyZXMsXG4gICAgdmlzaWJsZSxcbiAgICBuYW1lOiBcIk1lbnUuSXRlbXNcIlxuICB9KTtcbn0pO1xudmFyIERFRkFVTFRfSVRFTV9UQUcgPSBpbXBvcnRfcmVhY3QzMS5GcmFnbWVudDtcbnZhciBJdGVtID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBJdGVtMihwcm9wcywgcmVmKSB7XG4gIGxldCB7IGRpc2FibGVkID0gZmFsc2UsIC4uLnRoZWlyUHJvcHMgfSA9IHByb3BzO1xuICBsZXQgW3N0YXRlMiwgZGlzcGF0Y2hdID0gdXNlTWVudUNvbnRleHQoXCJNZW51Lkl0ZW1cIik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1tZW51LWl0ZW0tJHt1c2VJZCgpfWA7XG4gIGxldCBhY3RpdmUgPSBzdGF0ZTIuYWN0aXZlSXRlbUluZGV4ICE9PSBudWxsID8gc3RhdGUyLml0ZW1zW3N0YXRlMi5hY3RpdmVJdGVtSW5kZXhdLmlkID09PSBpZDIgOiBmYWxzZTtcbiAgbGV0IGludGVybmFsSXRlbVJlZiA9ICgwLCBpbXBvcnRfcmVhY3QzMS51c2VSZWYpKG51bGwpO1xuICBsZXQgaXRlbVJlZiA9IHVzZVN5bmNSZWZzKHJlZiwgaW50ZXJuYWxJdGVtUmVmKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHN0YXRlMi5tZW51U3RhdGUgIT09IDAgLyogT3BlbiAqLylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIWFjdGl2ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUyLmFjdGl2YXRpb25UcmlnZ2VyID09PSAwIC8qIFBvaW50ZXIgKi8pXG4gICAgICByZXR1cm47XG4gICAgbGV0IGQgPSBkaXNwb3NhYmxlcygpO1xuICAgIGQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgKF9iID0gKF9hMiA9IGludGVybmFsSXRlbVJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNjcm9sbEludG9WaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHsgYmxvY2s6IFwibmVhcmVzdFwiIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBkLmRpc3Bvc2U7XG4gIH0sIFtpbnRlcm5hbEl0ZW1SZWYsIGFjdGl2ZSwgc3RhdGUyLm1lbnVTdGF0ZSwgc3RhdGUyLmFjdGl2YXRpb25UcmlnZ2VyLCBzdGF0ZTIuYWN0aXZlSXRlbUluZGV4XSk7XG4gIGxldCBiYWcgPSAoMCwgaW1wb3J0X3JlYWN0MzEudXNlUmVmKSh7IGRpc2FibGVkLCBkb21SZWY6IGludGVybmFsSXRlbVJlZiB9KTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgYmFnLmN1cnJlbnQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgfSwgW2JhZywgZGlzYWJsZWRdKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgYmFnLmN1cnJlbnQudGV4dFZhbHVlID0gKF9iID0gKF9hMiA9IGludGVybmFsSXRlbVJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRleHRDb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKTtcbiAgfSwgW2JhZywgaW50ZXJuYWxJdGVtUmVmXSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogNSAvKiBSZWdpc3Rlckl0ZW0gKi8sIGlkOiBpZDIsIGRhdGFSZWY6IGJhZyB9KTtcbiAgICByZXR1cm4gKCkgPT4gZGlzcGF0Y2goeyB0eXBlOiA2IC8qIFVucmVnaXN0ZXJJdGVtICovLCBpZDogaWQyIH0pO1xuICB9LCBbYmFnLCBpZDJdKTtcbiAgbGV0IGhhbmRsZUNsaWNrID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKVxuICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlTWVudSAqLyB9KTtcbiAgICByZXN0b3JlRm9jdXNJZk5lY2Vzc2FyeShzdGF0ZTIuYnV0dG9uUmVmLmN1cnJlbnQpO1xuICB9KTtcbiAgbGV0IGhhbmRsZUZvY3VzID0gdXNlRXZlbnQoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZClcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7IHR5cGU6IDIgLyogR29Ub0l0ZW0gKi8sIGZvY3VzOiA1IC8qIE5vdGhpbmcgKi8gfSk7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAyIC8qIEdvVG9JdGVtICovLCBmb2N1czogNCAvKiBTcGVjaWZpYyAqLywgaWQ6IGlkMiB9KTtcbiAgfSk7XG4gIGxldCBoYW5kbGVNb3ZlID0gdXNlRXZlbnQoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoYWN0aXZlKVxuICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IDIgLyogR29Ub0l0ZW0gKi8sXG4gICAgICBmb2N1czogNCAvKiBTcGVjaWZpYyAqLyxcbiAgICAgIGlkOiBpZDIsXG4gICAgICB0cmlnZ2VyOiAwIC8qIFBvaW50ZXIgKi9cbiAgICB9KTtcbiAgfSk7XG4gIGxldCBoYW5kbGVMZWF2ZSA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFhY3RpdmUpXG4gICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAyIC8qIEdvVG9JdGVtICovLCBmb2N1czogNSAvKiBOb3RoaW5nICovIH0pO1xuICB9KTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MzEudXNlTWVtbykoKCkgPT4gKHsgYWN0aXZlLCBkaXNhYmxlZCB9KSwgW2FjdGl2ZSwgZGlzYWJsZWRdKTtcbiAgbGV0IG91clByb3BzID0ge1xuICAgIGlkOiBpZDIsXG4gICAgcmVmOiBpdGVtUmVmLFxuICAgIHJvbGU6IFwibWVudWl0ZW1cIixcbiAgICB0YWJJbmRleDogZGlzYWJsZWQgPT09IHRydWUgPyB2b2lkIDAgOiAtMSxcbiAgICBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPT09IHRydWUgPyB0cnVlIDogdm9pZCAwLFxuICAgIGRpc2FibGVkOiB2b2lkIDAsXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgb25Gb2N1czogaGFuZGxlRm9jdXMsXG4gICAgb25Qb2ludGVyTW92ZTogaGFuZGxlTW92ZSxcbiAgICBvbk1vdXNlTW92ZTogaGFuZGxlTW92ZSxcbiAgICBvblBvaW50ZXJMZWF2ZTogaGFuZGxlTGVhdmUsXG4gICAgb25Nb3VzZUxlYXZlOiBoYW5kbGVMZWF2ZVxuICB9O1xuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9JVEVNX1RBRyxcbiAgICBuYW1lOiBcIk1lbnUuSXRlbVwiXG4gIH0pO1xufSk7XG52YXIgTWVudTIgPSBPYmplY3QuYXNzaWduKE1lbnVSb290LCB7IEJ1dHRvbjogQnV0dG9uNywgSXRlbXMsIEl0ZW0gfSk7XG5cbi8vIHNyYy9jb21wb25lbnRzL3BvcG92ZXIvcG9wb3Zlci50c3hcbnZhciBpbXBvcnRfcmVhY3QzMiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcbnZhciByZWR1Y2VyczYgPSB7XG4gIFswIC8qIFRvZ2dsZVBvcG92ZXIgKi9dOiAoc3RhdGUyKSA9PiAoe1xuICAgIC4uLnN0YXRlMixcbiAgICBwb3BvdmVyU3RhdGU6IG1hdGNoKHN0YXRlMi5wb3BvdmVyU3RhdGUsIHtcbiAgICAgIFswIC8qIE9wZW4gKi9dOiAxIC8qIENsb3NlZCAqLyxcbiAgICAgIFsxIC8qIENsb3NlZCAqL106IDAgLyogT3BlbiAqL1xuICAgIH0pXG4gIH0pLFxuICBbMSAvKiBDbG9zZVBvcG92ZXIgKi9dKHN0YXRlMikge1xuICAgIGlmIChzdGF0ZTIucG9wb3ZlclN0YXRlID09PSAxIC8qIENsb3NlZCAqLylcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBwb3BvdmVyU3RhdGU6IDEgLyogQ2xvc2VkICovIH07XG4gIH0sXG4gIFsyIC8qIFNldEJ1dHRvbiAqL10oc3RhdGUyLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RhdGUyLmJ1dHRvbiA9PT0gYWN0aW9uLmJ1dHRvbilcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBidXR0b246IGFjdGlvbi5idXR0b24gfTtcbiAgfSxcbiAgWzMgLyogU2V0QnV0dG9uSWQgKi9dKHN0YXRlMiwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlMi5idXR0b25JZCA9PT0gYWN0aW9uLmJ1dHRvbklkKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIGJ1dHRvbklkOiBhY3Rpb24uYnV0dG9uSWQgfTtcbiAgfSxcbiAgWzQgLyogU2V0UGFuZWwgKi9dKHN0YXRlMiwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlMi5wYW5lbCA9PT0gYWN0aW9uLnBhbmVsKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIHBhbmVsOiBhY3Rpb24ucGFuZWwgfTtcbiAgfSxcbiAgWzUgLyogU2V0UGFuZWxJZCAqL10oc3RhdGUyLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RhdGUyLnBhbmVsSWQgPT09IGFjdGlvbi5wYW5lbElkKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICByZXR1cm4geyAuLi5zdGF0ZTIsIHBhbmVsSWQ6IGFjdGlvbi5wYW5lbElkIH07XG4gIH1cbn07XG52YXIgUG9wb3ZlckNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzIuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5Qb3BvdmVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUG9wb3ZlckNvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZVBvcG92ZXJDb250ZXh0KGNvbXBvbmVudCkge1xuICBsZXQgY29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzMi51c2VDb250ZXh0KShQb3BvdmVyQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgbGV0IGVyciA9IG5ldyBFcnJvcihgPCR7Y29tcG9uZW50fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxQb3BvdmVyIC8+IGNvbXBvbmVudC5gKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHVzZVBvcG92ZXJDb250ZXh0KTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG52YXIgUG9wb3ZlckFQSUNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzIuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5Qb3BvdmVyQVBJQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUG9wb3ZlckFQSUNvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZVBvcG92ZXJBUElDb250ZXh0KGNvbXBvbmVudCkge1xuICBsZXQgY29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzMi51c2VDb250ZXh0KShQb3BvdmVyQVBJQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgbGV0IGVyciA9IG5ldyBFcnJvcihgPCR7Y29tcG9uZW50fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxQb3BvdmVyIC8+IGNvbXBvbmVudC5gKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHVzZVBvcG92ZXJBUElDb250ZXh0KTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG52YXIgUG9wb3Zlckdyb3VwQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzMi5jcmVhdGVDb250ZXh0KShudWxsKTtcblBvcG92ZXJHcm91cENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlBvcG92ZXJHcm91cENvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZVBvcG92ZXJHcm91cENvbnRleHQoKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X3JlYWN0MzIudXNlQ29udGV4dCkoUG9wb3Zlckdyb3VwQ29udGV4dCk7XG59XG52YXIgUG9wb3ZlclBhbmVsQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzMi5jcmVhdGVDb250ZXh0KShudWxsKTtcblBvcG92ZXJQYW5lbENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlBvcG92ZXJQYW5lbENvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZVBvcG92ZXJQYW5lbENvbnRleHQoKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X3JlYWN0MzIudXNlQ29udGV4dCkoUG9wb3ZlclBhbmVsQ29udGV4dCk7XG59XG5mdW5jdGlvbiBzdGF0ZVJlZHVjZXI2KHN0YXRlMiwgYWN0aW9uKSB7XG4gIHJldHVybiBtYXRjaChhY3Rpb24udHlwZSwgcmVkdWNlcnM2LCBzdGF0ZTIsIGFjdGlvbik7XG59XG52YXIgREVGQVVMVF9QT1BPVkVSX1RBRyA9IFwiZGl2XCI7XG52YXIgUG9wb3ZlclJvb3QgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIFBvcG92ZXIocHJvcHMsIHJlZikge1xuICB2YXIgX2EyO1xuICBsZXQgYnV0dG9uSWQgPSBgaGVhZGxlc3N1aS1wb3BvdmVyLWJ1dHRvbi0ke3VzZUlkKCl9YDtcbiAgbGV0IHBhbmVsSWQgPSBgaGVhZGxlc3N1aS1wb3BvdmVyLXBhbmVsLSR7dXNlSWQoKX1gO1xuICBsZXQgaW50ZXJuYWxQb3BvdmVyUmVmID0gKDAsIGltcG9ydF9yZWFjdDMyLnVzZVJlZikobnVsbCk7XG4gIGxldCBwb3BvdmVyUmVmID0gdXNlU3luY1JlZnMocmVmLCBvcHRpb25hbFJlZigocmVmMikgPT4ge1xuICAgIGludGVybmFsUG9wb3ZlclJlZi5jdXJyZW50ID0gcmVmMjtcbiAgfSkpO1xuICBsZXQgcmVkdWNlckJhZyA9ICgwLCBpbXBvcnRfcmVhY3QzMi51c2VSZWR1Y2VyKShzdGF0ZVJlZHVjZXI2LCB7XG4gICAgcG9wb3ZlclN0YXRlOiAxIC8qIENsb3NlZCAqLyxcbiAgICBidXR0b246IG51bGwsXG4gICAgYnV0dG9uSWQsXG4gICAgcGFuZWw6IG51bGwsXG4gICAgcGFuZWxJZCxcbiAgICBiZWZvcmVQYW5lbFNlbnRpbmVsOiAoMCwgaW1wb3J0X3JlYWN0MzIuY3JlYXRlUmVmKSgpLFxuICAgIGFmdGVyUGFuZWxTZW50aW5lbDogKDAsIGltcG9ydF9yZWFjdDMyLmNyZWF0ZVJlZikoKVxuICB9KTtcbiAgbGV0IFt7IHBvcG92ZXJTdGF0ZSwgYnV0dG9uLCBwYW5lbCwgYmVmb3JlUGFuZWxTZW50aW5lbCwgYWZ0ZXJQYW5lbFNlbnRpbmVsIH0sIGRpc3BhdGNoXSA9IHJlZHVjZXJCYWc7XG4gIGxldCBvd25lckRvY3VtZW50ID0gdXNlT3duZXJEb2N1bWVudCgoX2EyID0gaW50ZXJuYWxQb3BvdmVyUmVmLmN1cnJlbnQpICE9IG51bGwgPyBfYTIgOiBidXR0b24pO1xuICAoMCwgaW1wb3J0X3JlYWN0MzIudXNlRWZmZWN0KSgoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDMgLyogU2V0QnV0dG9uSWQgKi8sIGJ1dHRvbklkIH0pLCBbYnV0dG9uSWQsIGRpc3BhdGNoXSk7XG4gICgwLCBpbXBvcnRfcmVhY3QzMi51c2VFZmZlY3QpKCgpID0+IGRpc3BhdGNoKHsgdHlwZTogNSAvKiBTZXRQYW5lbElkICovLCBwYW5lbElkIH0pLCBbcGFuZWxJZCwgZGlzcGF0Y2hdKTtcbiAgbGV0IGlzUG9ydGFsbGVkID0gKDAsIGltcG9ydF9yZWFjdDMyLnVzZU1lbW8pKCgpID0+IHtcbiAgICBpZiAoIWJ1dHRvbilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXBhbmVsKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHJvb3Qgb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJvZHkgPiAqXCIpKSB7XG4gICAgICBpZiAoTnVtYmVyKHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuY29udGFpbnMoYnV0dG9uKSkgXiBOdW1iZXIocm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5jb250YWlucyhwYW5lbCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIFtidXR0b24sIHBhbmVsXSk7XG4gIGxldCByZWdpc3RlckJhZyA9ICgwLCBpbXBvcnRfcmVhY3QzMi51c2VNZW1vKSgoKSA9PiAoeyBidXR0b25JZCwgcGFuZWxJZCwgY2xvc2U6ICgpID0+IGRpc3BhdGNoKHsgdHlwZTogMSAvKiBDbG9zZVBvcG92ZXIgKi8gfSkgfSksIFtidXR0b25JZCwgcGFuZWxJZCwgZGlzcGF0Y2hdKTtcbiAgbGV0IGdyb3VwQ29udGV4dCA9IHVzZVBvcG92ZXJHcm91cENvbnRleHQoKTtcbiAgbGV0IHJlZ2lzdGVyUG9wb3ZlciA9IGdyb3VwQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogZ3JvdXBDb250ZXh0LnJlZ2lzdGVyUG9wb3ZlcjtcbiAgbGV0IGlzRm9jdXNXaXRoaW5Qb3BvdmVyR3JvdXAgPSB1c2VFdmVudCgoKSA9PiB7XG4gICAgdmFyIF9hMztcbiAgICByZXR1cm4gKF9hMyA9IGdyb3VwQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogZ3JvdXBDb250ZXh0LmlzRm9jdXNXaXRoaW5Qb3BvdmVyR3JvdXAoKSkgIT0gbnVsbCA/IF9hMyA6IChvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmICgoYnV0dG9uID09IG51bGwgPyB2b2lkIDAgOiBidXR0b24uY29udGFpbnMob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50KSkgfHwgKHBhbmVsID09IG51bGwgPyB2b2lkIDAgOiBwYW5lbC5jb250YWlucyhvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSk7XG4gIH0pO1xuICAoMCwgaW1wb3J0X3JlYWN0MzIudXNlRWZmZWN0KSgoKSA9PiByZWdpc3RlclBvcG92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZ2lzdGVyUG9wb3ZlcihyZWdpc3RlckJhZyksIFtyZWdpc3RlclBvcG92ZXIsIHJlZ2lzdGVyQmFnXSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIob3duZXJEb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldywgXCJmb2N1c1wiLCAoZXZlbnQpID0+IHtcbiAgICB2YXIgX2EzLCBfYiwgX2MsIF9kO1xuICAgIGlmIChwb3BvdmVyU3RhdGUgIT09IDAgLyogT3BlbiAqLylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaXNGb2N1c1dpdGhpblBvcG92ZXJHcm91cCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghYnV0dG9uKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcGFuZWwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKChfYiA9IChfYTMgPSBiZWZvcmVQYW5lbFNlbnRpbmVsLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY29udGFpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMywgZXZlbnQudGFyZ2V0KSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoKF9kID0gKF9jID0gYWZ0ZXJQYW5lbFNlbnRpbmVsLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jb250YWlucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIGV2ZW50LnRhcmdldCkpXG4gICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlUG9wb3ZlciAqLyB9KTtcbiAgfSwgdHJ1ZSk7XG4gIHVzZU91dHNpZGVDbGljayhbYnV0dG9uLCBwYW5lbF0sIChldmVudCwgdGFyZ2V0KSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlUG9wb3ZlciAqLyB9KTtcbiAgICBpZiAoIWlzRm9jdXNhYmxlRWxlbWVudCh0YXJnZXQsIDEgLyogTG9vc2UgKi8pKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYnV0dG9uID09IG51bGwgPyB2b2lkIDAgOiBidXR0b24uZm9jdXMoKTtcbiAgICB9XG4gIH0sIHBvcG92ZXJTdGF0ZSA9PT0gMCAvKiBPcGVuICovKTtcbiAgbGV0IGNsb3NlID0gdXNlRXZlbnQoKGZvY3VzYWJsZUVsZW1lbnQpID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IDEgLyogQ2xvc2VQb3BvdmVyICovIH0pO1xuICAgIGxldCByZXN0b3JlRWxlbWVudCA9ICgoKSA9PiB7XG4gICAgICBpZiAoIWZvY3VzYWJsZUVsZW1lbnQpXG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgICByZXR1cm4gZm9jdXNhYmxlRWxlbWVudDtcbiAgICAgIGlmIChcImN1cnJlbnRcIiBpbiBmb2N1c2FibGVFbGVtZW50ICYmIGZvY3VzYWJsZUVsZW1lbnQuY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgICByZXR1cm4gZm9jdXNhYmxlRWxlbWVudC5jdXJyZW50O1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9KSgpO1xuICAgIHJlc3RvcmVFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiByZXN0b3JlRWxlbWVudC5mb2N1cygpO1xuICB9KTtcbiAgbGV0IGFwaSA9ICgwLCBpbXBvcnRfcmVhY3QzMi51c2VNZW1vKSgoKSA9PiAoeyBjbG9zZSwgaXNQb3J0YWxsZWQgfSksIFtjbG9zZSwgaXNQb3J0YWxsZWRdKTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MzIudXNlTWVtbykoKCkgPT4gKHsgb3BlbjogcG9wb3ZlclN0YXRlID09PSAwIC8qIE9wZW4gKi8sIGNsb3NlIH0pLCBbcG9wb3ZlclN0YXRlLCBjbG9zZV0pO1xuICBsZXQgdGhlaXJQcm9wcyA9IHByb3BzO1xuICBsZXQgb3VyUHJvcHMgPSB7IHJlZjogcG9wb3ZlclJlZiB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDMyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChQb3BvdmVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZWR1Y2VyQmFnXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzMi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUG9wb3ZlckFQSUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYXBpXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzMi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoT3BlbkNsb3NlZFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG1hdGNoKHBvcG92ZXJTdGF0ZSwge1xuICAgICAgWzAgLyogT3BlbiAqL106IDAgLyogT3BlbiAqLyxcbiAgICAgIFsxIC8qIENsb3NlZCAqL106IDEgLyogQ2xvc2VkICovXG4gICAgfSlcbiAgfSwgcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9QT1BPVkVSX1RBRyxcbiAgICBuYW1lOiBcIlBvcG92ZXJcIlxuICB9KSkpKTtcbn0pO1xudmFyIERFRkFVTFRfQlVUVE9OX1RBRzUgPSBcImJ1dHRvblwiO1xudmFyIEJ1dHRvbjkgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIEJ1dHRvbjEwKHByb3BzLCByZWYpIHtcbiAgbGV0IFtzdGF0ZTIsIGRpc3BhdGNoXSA9IHVzZVBvcG92ZXJDb250ZXh0KFwiUG9wb3Zlci5CdXR0b25cIik7XG4gIGxldCB7IGlzUG9ydGFsbGVkIH0gPSB1c2VQb3BvdmVyQVBJQ29udGV4dChcIlBvcG92ZXIuQnV0dG9uXCIpO1xuICBsZXQgaW50ZXJuYWxCdXR0b25SZWYgPSAoMCwgaW1wb3J0X3JlYWN0MzIudXNlUmVmKShudWxsKTtcbiAgbGV0IHNlbnRpbmVsSWQgPSBgaGVhZGxlc3N1aS1mb2N1cy1zZW50aW5lbC0ke3VzZUlkKCl9YDtcbiAgbGV0IGdyb3VwQ29udGV4dCA9IHVzZVBvcG92ZXJHcm91cENvbnRleHQoKTtcbiAgbGV0IGNsb3NlT3RoZXJzID0gZ3JvdXBDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBncm91cENvbnRleHQuY2xvc2VPdGhlcnM7XG4gIGxldCBwYW5lbENvbnRleHQgPSB1c2VQb3BvdmVyUGFuZWxDb250ZXh0KCk7XG4gIGxldCBpc1dpdGhpblBhbmVsID0gcGFuZWxDb250ZXh0ID09PSBudWxsID8gZmFsc2UgOiBwYW5lbENvbnRleHQgPT09IHN0YXRlMi5wYW5lbElkO1xuICBsZXQgYnV0dG9uUmVmID0gdXNlU3luY1JlZnMoaW50ZXJuYWxCdXR0b25SZWYsIHJlZiwgaXNXaXRoaW5QYW5lbCA/IG51bGwgOiAoYnV0dG9uKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDIgLyogU2V0QnV0dG9uICovLCBidXR0b24gfSkpO1xuICBsZXQgd2l0aGluUGFuZWxCdXR0b25SZWYgPSB1c2VTeW5jUmVmcyhpbnRlcm5hbEJ1dHRvblJlZiwgcmVmKTtcbiAgbGV0IG93bmVyRG9jdW1lbnQgPSB1c2VPd25lckRvY3VtZW50KGludGVybmFsQnV0dG9uUmVmKTtcbiAgbGV0IGhhbmRsZUtleURvd24gPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgaWYgKGlzV2l0aGluUGFuZWwpIHtcbiAgICAgIGlmIChzdGF0ZTIucG9wb3ZlclN0YXRlID09PSAxIC8qIENsb3NlZCAqLylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSBcIiBcIiAvKiBTcGFjZSAqLzpcbiAgICAgICAgY2FzZSBcIkVudGVyXCIgLyogRW50ZXIgKi86XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAoX2IgPSAoX2EyID0gZXZlbnQudGFyZ2V0KS5jbGljaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyKTtcbiAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IDEgLyogQ2xvc2VQb3BvdmVyICovIH0pO1xuICAgICAgICAgIChfYyA9IHN0YXRlMi5idXR0b24pID09IG51bGwgPyB2b2lkIDAgOiBfYy5mb2N1cygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlIFwiIFwiIC8qIFNwYWNlICovOlxuICAgICAgICBjYXNlIFwiRW50ZXJcIiAvKiBFbnRlciAqLzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGlmIChzdGF0ZTIucG9wb3ZlclN0YXRlID09PSAxIC8qIENsb3NlZCAqLylcbiAgICAgICAgICAgIGNsb3NlT3RoZXJzID09IG51bGwgPyB2b2lkIDAgOiBjbG9zZU90aGVycyhzdGF0ZTIuYnV0dG9uSWQpO1xuICAgICAgICAgIGRpc3BhdGNoKHsgdHlwZTogMCAvKiBUb2dnbGVQb3BvdmVyICovIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRXNjYXBlXCIgLyogRXNjYXBlICovOlxuICAgICAgICAgIGlmIChzdGF0ZTIucG9wb3ZlclN0YXRlICE9PSAwIC8qIE9wZW4gKi8pXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VPdGhlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNsb3NlT3RoZXJzKHN0YXRlMi5idXR0b25JZCk7XG4gICAgICAgICAgaWYgKCFpbnRlcm5hbEJ1dHRvblJlZi5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmICgob3duZXJEb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogb3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50KSAmJiAhaW50ZXJuYWxCdXR0b25SZWYuY3VycmVudC5jb250YWlucyhvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlUG9wb3ZlciAqLyB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBsZXQgaGFuZGxlS2V5VXAgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBpZiAoaXNXaXRoaW5QYW5lbClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIiBcIiAvKiBTcGFjZSAqLykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xuICBsZXQgaGFuZGxlQ2xpY2sgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBpZiAoaXNEaXNhYmxlZFJlYWN0SXNzdWU3NzExKGV2ZW50LmN1cnJlbnRUYXJnZXQpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChwcm9wcy5kaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaXNXaXRoaW5QYW5lbCkge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlUG9wb3ZlciAqLyB9KTtcbiAgICAgIChfYTIgPSBzdGF0ZTIuYnV0dG9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChzdGF0ZTIucG9wb3ZlclN0YXRlID09PSAxIC8qIENsb3NlZCAqLylcbiAgICAgICAgY2xvc2VPdGhlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNsb3NlT3RoZXJzKHN0YXRlMi5idXR0b25JZCk7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IDAgLyogVG9nZ2xlUG9wb3ZlciAqLyB9KTtcbiAgICAgIChfYiA9IHN0YXRlMi5idXR0b24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5mb2N1cygpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBoYW5kbGVNb3VzZURvd24gPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbiAgbGV0IHZpc2libGUgPSBzdGF0ZTIucG9wb3ZlclN0YXRlID09PSAwIC8qIE9wZW4gKi87XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDMyLnVzZU1lbW8pKCgpID0+ICh7IG9wZW46IHZpc2libGUgfSksIFt2aXNpYmxlXSk7XG4gIGxldCB0eXBlID0gdXNlUmVzb2x2ZUJ1dHRvblR5cGUocHJvcHMsIGludGVybmFsQnV0dG9uUmVmKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0gaXNXaXRoaW5QYW5lbCA/IHtcbiAgICByZWY6IHdpdGhpblBhbmVsQnV0dG9uUmVmLFxuICAgIHR5cGUsXG4gICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrXG4gIH0gOiB7XG4gICAgcmVmOiBidXR0b25SZWYsXG4gICAgaWQ6IHN0YXRlMi5idXR0b25JZCxcbiAgICB0eXBlLFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiBwcm9wcy5kaXNhYmxlZCA/IHZvaWQgMCA6IHN0YXRlMi5wb3BvdmVyU3RhdGUgPT09IDAgLyogT3BlbiAqLyxcbiAgICBcImFyaWEtY29udHJvbHNcIjogc3RhdGUyLnBhbmVsID8gc3RhdGUyLnBhbmVsSWQgOiB2b2lkIDAsXG4gICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgIG9uS2V5VXA6IGhhbmRsZUtleVVwLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgIG9uTW91c2VEb3duOiBoYW5kbGVNb3VzZURvd25cbiAgfTtcbiAgbGV0IGRpcmVjdGlvbiA9IHVzZVRhYkRpcmVjdGlvbigpO1xuICBsZXQgaGFuZGxlRm9jdXMgPSB1c2VFdmVudCgoKSA9PiB7XG4gICAgbGV0IGVsID0gc3RhdGUyLnBhbmVsO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgbWF0Y2goZGlyZWN0aW9uLmN1cnJlbnQsIHtcbiAgICAgICAgWzAgLyogRm9yd2FyZHMgKi9dOiAoKSA9PiBmb2N1c0luKGVsLCAxIC8qIEZpcnN0ICovKSxcbiAgICAgICAgWzEgLyogQmFja3dhcmRzICovXTogKCkgPT4gZm9jdXNJbihlbCwgOCAvKiBMYXN0ICovKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmYWxzZSkge1xuICAgICAgbWljcm9UYXNrKHJ1bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bigpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGltcG9ydF9yZWFjdDMyLmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfQlVUVE9OX1RBRzUsXG4gICAgbmFtZTogXCJQb3BvdmVyLkJ1dHRvblwiXG4gIH0pLCB2aXNpYmxlICYmICFpc1dpdGhpblBhbmVsICYmIGlzUG9ydGFsbGVkICYmIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzMi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSGlkZGVuLCB7XG4gICAgaWQ6IHNlbnRpbmVsSWQsXG4gICAgZmVhdHVyZXM6IDIgLyogRm9jdXNhYmxlICovLFxuICAgIGFzOiBcImJ1dHRvblwiLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgb25Gb2N1czogaGFuZGxlRm9jdXNcbiAgfSkpO1xufSk7XG52YXIgREVGQVVMVF9PVkVSTEFZX1RBRzIgPSBcImRpdlwiO1xudmFyIE92ZXJsYXlSZW5kZXJGZWF0dXJlcyA9IDEgLyogUmVuZGVyU3RyYXRlZ3kgKi8gfCAyIC8qIFN0YXRpYyAqLztcbnZhciBPdmVybGF5MyA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gT3ZlcmxheTQocHJvcHMsIHJlZikge1xuICBsZXQgW3sgcG9wb3ZlclN0YXRlIH0sIGRpc3BhdGNoXSA9IHVzZVBvcG92ZXJDb250ZXh0KFwiUG9wb3Zlci5PdmVybGF5XCIpO1xuICBsZXQgb3ZlcmxheVJlZiA9IHVzZVN5bmNSZWZzKHJlZik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1wb3BvdmVyLW92ZXJsYXktJHt1c2VJZCgpfWA7XG4gIGxldCB1c2VzT3BlbkNsb3NlZFN0YXRlID0gdXNlT3BlbkNsb3NlZCgpO1xuICBsZXQgdmlzaWJsZSA9ICgoKSA9PiB7XG4gICAgaWYgKHVzZXNPcGVuQ2xvc2VkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1c2VzT3BlbkNsb3NlZFN0YXRlID09PSAwIC8qIE9wZW4gKi87XG4gICAgfVxuICAgIHJldHVybiBwb3BvdmVyU3RhdGUgPT09IDAgLyogT3BlbiAqLztcbiAgfSkoKTtcbiAgbGV0IGhhbmRsZUNsaWNrID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGlzRGlzYWJsZWRSZWFjdElzc3VlNzcxMShldmVudC5jdXJyZW50VGFyZ2V0KSlcbiAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogMSAvKiBDbG9zZVBvcG92ZXIgKi8gfSk7XG4gIH0pO1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QzMi51c2VNZW1vKSgoKSA9PiAoeyBvcGVuOiBwb3BvdmVyU3RhdGUgPT09IDAgLyogT3BlbiAqLyB9KSwgW3BvcG92ZXJTdGF0ZV0pO1xuICBsZXQgdGhlaXJQcm9wcyA9IHByb3BzO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgcmVmOiBvdmVybGF5UmVmLFxuICAgIGlkOiBpZDIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrXG4gIH07XG4gIHJldHVybiByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX09WRVJMQVlfVEFHMixcbiAgICBmZWF0dXJlczogT3ZlcmxheVJlbmRlckZlYXR1cmVzLFxuICAgIHZpc2libGUsXG4gICAgbmFtZTogXCJQb3BvdmVyLk92ZXJsYXlcIlxuICB9KTtcbn0pO1xudmFyIERFRkFVTFRfUEFORUxfVEFHMyA9IFwiZGl2XCI7XG52YXIgUGFuZWxSZW5kZXJGZWF0dXJlczIgPSAxIC8qIFJlbmRlclN0cmF0ZWd5ICovIHwgMiAvKiBTdGF0aWMgKi87XG52YXIgUGFuZWw1ID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBQYW5lbDYocHJvcHMsIHJlZikge1xuICBsZXQgeyBmb2N1cyA9IGZhbHNlLCAuLi50aGVpclByb3BzIH0gPSBwcm9wcztcbiAgbGV0IFtzdGF0ZTIsIGRpc3BhdGNoXSA9IHVzZVBvcG92ZXJDb250ZXh0KFwiUG9wb3Zlci5QYW5lbFwiKTtcbiAgbGV0IHsgY2xvc2UsIGlzUG9ydGFsbGVkIH0gPSB1c2VQb3BvdmVyQVBJQ29udGV4dChcIlBvcG92ZXIuUGFuZWxcIik7XG4gIGxldCBiZWZvcmVQYW5lbFNlbnRpbmVsSWQgPSBgaGVhZGxlc3N1aS1mb2N1cy1zZW50aW5lbC1iZWZvcmUtJHt1c2VJZCgpfWA7XG4gIGxldCBhZnRlclBhbmVsU2VudGluZWxJZCA9IGBoZWFkbGVzc3VpLWZvY3VzLXNlbnRpbmVsLWFmdGVyLSR7dXNlSWQoKX1gO1xuICBsZXQgaW50ZXJuYWxQYW5lbFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QzMi51c2VSZWYpKG51bGwpO1xuICBsZXQgcGFuZWxSZWYgPSB1c2VTeW5jUmVmcyhpbnRlcm5hbFBhbmVsUmVmLCByZWYsIChwYW5lbCkgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogNCAvKiBTZXRQYW5lbCAqLywgcGFuZWwgfSk7XG4gIH0pO1xuICBsZXQgb3duZXJEb2N1bWVudCA9IHVzZU93bmVyRG9jdW1lbnQoaW50ZXJuYWxQYW5lbFJlZik7XG4gIGxldCB1c2VzT3BlbkNsb3NlZFN0YXRlID0gdXNlT3BlbkNsb3NlZCgpO1xuICBsZXQgdmlzaWJsZSA9ICgoKSA9PiB7XG4gICAgaWYgKHVzZXNPcGVuQ2xvc2VkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1c2VzT3BlbkNsb3NlZFN0YXRlID09PSAwIC8qIE9wZW4gKi87XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTIucG9wb3ZlclN0YXRlID09PSAwIC8qIE9wZW4gKi87XG4gIH0pKCk7XG4gIGxldCBoYW5kbGVLZXlEb3duID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIkVzY2FwZVwiIC8qIEVzY2FwZSAqLzpcbiAgICAgICAgaWYgKHN0YXRlMi5wb3BvdmVyU3RhdGUgIT09IDAgLyogT3BlbiAqLylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghaW50ZXJuYWxQYW5lbFJlZi5jdXJyZW50KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKChvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmICFpbnRlcm5hbFBhbmVsUmVmLmN1cnJlbnQuY29udGFpbnMob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlUG9wb3ZlciAqLyB9KTtcbiAgICAgICAgKF9hMiA9IHN0YXRlMi5idXR0b24pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZm9jdXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgKDAsIGltcG9ydF9yZWFjdDMyLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHByb3BzLnN0YXRpYylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUyLnBvcG92ZXJTdGF0ZSA9PT0gMSAvKiBDbG9zZWQgKi8gJiYgKChfYTIgPSBwcm9wcy51bm1vdW50KSAhPSBudWxsID8gX2EyIDogdHJ1ZSkpIHtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogNCAvKiBTZXRQYW5lbCAqLywgcGFuZWw6IG51bGwgfSk7XG4gICAgfVxuICB9LCBbc3RhdGUyLnBvcG92ZXJTdGF0ZSwgcHJvcHMudW5tb3VudCwgcHJvcHMuc3RhdGljLCBkaXNwYXRjaF0pO1xuICAoMCwgaW1wb3J0X3JlYWN0MzIudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKCFmb2N1cylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUyLnBvcG92ZXJTdGF0ZSAhPT0gMCAvKiBPcGVuICovKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghaW50ZXJuYWxQYW5lbFJlZi5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBhY3RpdmVFbGVtZW50ID0gb3duZXJEb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogb3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChpbnRlcm5hbFBhbmVsUmVmLmN1cnJlbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpXG4gICAgICByZXR1cm47XG4gICAgZm9jdXNJbihpbnRlcm5hbFBhbmVsUmVmLmN1cnJlbnQsIDEgLyogRmlyc3QgKi8pO1xuICB9LCBbZm9jdXMsIGludGVybmFsUGFuZWxSZWYsIHN0YXRlMi5wb3BvdmVyU3RhdGVdKTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MzIudXNlTWVtbykoKCkgPT4gKHsgb3Blbjogc3RhdGUyLnBvcG92ZXJTdGF0ZSA9PT0gMCAvKiBPcGVuICovLCBjbG9zZSB9KSwgW3N0YXRlMiwgY2xvc2VdKTtcbiAgbGV0IG91clByb3BzID0ge1xuICAgIHJlZjogcGFuZWxSZWYsXG4gICAgaWQ6IHN0YXRlMi5wYW5lbElkLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbkJsdXI6IGZvY3VzICYmIHN0YXRlMi5wb3BvdmVyU3RhdGUgPT09IDAgLyogT3BlbiAqLyA/IChldmVudCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICBsZXQgZWwgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgaWYgKCFlbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFpbnRlcm5hbFBhbmVsUmVmLmN1cnJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICgoX2EyID0gaW50ZXJuYWxQYW5lbFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbnRhaW5zKGVsKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAxIC8qIENsb3NlUG9wb3ZlciAqLyB9KTtcbiAgICAgIGlmICgoKF9jID0gKF9iID0gc3RhdGUyLmJlZm9yZVBhbmVsU2VudGluZWwuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRhaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZWwpKSB8fCAoKF9lID0gKF9kID0gc3RhdGUyLmFmdGVyUGFuZWxTZW50aW5lbC5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2QuY29udGFpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWxsKF9kLCBlbCkpKSB7XG4gICAgICAgIGVsLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9IDogdm9pZCAwLFxuICAgIHRhYkluZGV4OiAtMVxuICB9O1xuICBsZXQgZGlyZWN0aW9uID0gdXNlVGFiRGlyZWN0aW9uKCk7XG4gIGxldCBoYW5kbGVCZWZvcmVGb2N1cyA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICBsZXQgZWwgPSBpbnRlcm5hbFBhbmVsUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBtYXRjaChkaXJlY3Rpb24uY3VycmVudCwge1xuICAgICAgICBbMCAvKiBGb3J3YXJkcyAqL106ICgpID0+IHtcbiAgICAgICAgICBmb2N1c0luKGVsLCAxIC8qIEZpcnN0ICovKTtcbiAgICAgICAgfSxcbiAgICAgICAgWzEgLyogQmFja3dhcmRzICovXTogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgKF9hMiA9IHN0YXRlMi5idXR0b24pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBtaWNyb1Rhc2socnVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnVuKCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUFmdGVyRm9jdXMgPSB1c2VFdmVudCgoKSA9PiB7XG4gICAgbGV0IGVsID0gaW50ZXJuYWxQYW5lbFJlZi5jdXJyZW50O1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgbWF0Y2goZGlyZWN0aW9uLmN1cnJlbnQsIHtcbiAgICAgICAgWzAgLyogRm9yd2FyZHMgKi9dOiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgICAgICAgIGlmICghc3RhdGUyLmJ1dHRvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBsZXQgZWxlbWVudHMgPSBnZXRGb2N1c2FibGVFbGVtZW50cygpO1xuICAgICAgICAgIGxldCBpZHggPSBlbGVtZW50cy5pbmRleE9mKHN0YXRlMi5idXR0b24pO1xuICAgICAgICAgIGxldCBiZWZvcmUgPSBlbGVtZW50cy5zbGljZSgwLCBpZHggKyAxKTtcbiAgICAgICAgICBsZXQgYWZ0ZXIgPSBlbGVtZW50cy5zbGljZShpZHggKyAxKTtcbiAgICAgICAgICBsZXQgY29tYmluZWQgPSBbLi4uYWZ0ZXIsIC4uLmJlZm9yZV07XG4gICAgICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBjb21iaW5lZC5zbGljZSgpKSB7XG4gICAgICAgICAgICBpZiAoKChfYiA9IChfYTIgPSBlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50LmlkKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnN0YXJ0c1dpdGgpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgXCJoZWFkbGVzc3VpLWZvY3VzLXNlbnRpbmVsLVwiKSkgfHwgKChfYyA9IHN0YXRlMi5wYW5lbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNvbnRhaW5zKGVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICBsZXQgaWR4MiA9IGNvbWJpbmVkLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgICAgICAgIGlmIChpZHgyICE9PSAtMSlcbiAgICAgICAgICAgICAgICBjb21iaW5lZC5zcGxpY2UoaWR4MiwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvY3VzSW4oY29tYmluZWQsIDEgLyogRmlyc3QgKi8sIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgWzEgLyogQmFja3dhcmRzICovXTogKCkgPT4gZm9jdXNJbihlbCwgOCAvKiBMYXN0ICovKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmYWxzZSkge1xuICAgICAgbWljcm9UYXNrKHJ1bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bigpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFBvcG92ZXJQYW5lbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RhdGUyLnBhbmVsSWRcbiAgfSwgdmlzaWJsZSAmJiBpc1BvcnRhbGxlZCAmJiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhpZGRlbiwge1xuICAgIGlkOiBiZWZvcmVQYW5lbFNlbnRpbmVsSWQsXG4gICAgcmVmOiBzdGF0ZTIuYmVmb3JlUGFuZWxTZW50aW5lbCxcbiAgICBmZWF0dXJlczogMiAvKiBGb2N1c2FibGUgKi8sXG4gICAgYXM6IFwiYnV0dG9uXCIsXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICBvbkZvY3VzOiBoYW5kbGVCZWZvcmVGb2N1c1xuICB9KSwgcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9QQU5FTF9UQUczLFxuICAgIGZlYXR1cmVzOiBQYW5lbFJlbmRlckZlYXR1cmVzMixcbiAgICB2aXNpYmxlLFxuICAgIG5hbWU6IFwiUG9wb3Zlci5QYW5lbFwiXG4gIH0pLCB2aXNpYmxlICYmIGlzUG9ydGFsbGVkICYmIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzMi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSGlkZGVuLCB7XG4gICAgaWQ6IGFmdGVyUGFuZWxTZW50aW5lbElkLFxuICAgIHJlZjogc3RhdGUyLmFmdGVyUGFuZWxTZW50aW5lbCxcbiAgICBmZWF0dXJlczogMiAvKiBGb2N1c2FibGUgKi8sXG4gICAgYXM6IFwiYnV0dG9uXCIsXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICBvbkZvY3VzOiBoYW5kbGVBZnRlckZvY3VzXG4gIH0pKTtcbn0pO1xudmFyIERFRkFVTFRfR1JPVVBfVEFHMiA9IFwiZGl2XCI7XG52YXIgR3JvdXAzID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBHcm91cDQocHJvcHMsIHJlZikge1xuICBsZXQgaW50ZXJuYWxHcm91cFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QzMi51c2VSZWYpKG51bGwpO1xuICBsZXQgZ3JvdXBSZWYgPSB1c2VTeW5jUmVmcyhpbnRlcm5hbEdyb3VwUmVmLCByZWYpO1xuICBsZXQgW3BvcG92ZXJzLCBzZXRQb3BvdmVyc10gPSAoMCwgaW1wb3J0X3JlYWN0MzIudXNlU3RhdGUpKFtdKTtcbiAgbGV0IHVucmVnaXN0ZXJQb3BvdmVyID0gdXNlRXZlbnQoKHJlZ2lzdGVyYmFnKSA9PiB7XG4gICAgc2V0UG9wb3ZlcnMoKGV4aXN0aW5nKSA9PiB7XG4gICAgICBsZXQgaWR4ID0gZXhpc3RpbmcuaW5kZXhPZihyZWdpc3RlcmJhZyk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBsZXQgY2xvbmUgPSBleGlzdGluZy5zbGljZSgpO1xuICAgICAgICBjbG9uZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0pO1xuICB9KTtcbiAgbGV0IHJlZ2lzdGVyUG9wb3ZlciA9IHVzZUV2ZW50KChyZWdpc3RlcmJhZykgPT4ge1xuICAgIHNldFBvcG92ZXJzKChleGlzdGluZykgPT4gWy4uLmV4aXN0aW5nLCByZWdpc3RlcmJhZ10pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUG9wb3ZlcihyZWdpc3RlcmJhZyk7XG4gIH0pO1xuICBsZXQgaXNGb2N1c1dpdGhpblBvcG92ZXJHcm91cCA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGxldCBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudChpbnRlcm5hbEdyb3VwUmVmKTtcbiAgICBpZiAoIW93bmVyRG9jdW1lbnQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVsZW1lbnQgPSBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKChfYTIgPSBpbnRlcm5hbEdyb3VwUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY29udGFpbnMoZWxlbWVudCkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gcG9wb3ZlcnMuc29tZSgoYmFnKSA9PiB7XG4gICAgICB2YXIgX2EzLCBfYjtcbiAgICAgIHJldHVybiAoKF9hMyA9IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYmFnLmJ1dHRvbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jb250YWlucyhlbGVtZW50KSkgfHwgKChfYiA9IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYmFnLnBhbmVsSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGFpbnMoZWxlbWVudCkpO1xuICAgIH0pO1xuICB9KTtcbiAgbGV0IGNsb3NlT3RoZXJzID0gdXNlRXZlbnQoKGJ1dHRvbklkKSA9PiB7XG4gICAgZm9yIChsZXQgcG9wb3ZlciBvZiBwb3BvdmVycykge1xuICAgICAgaWYgKHBvcG92ZXIuYnV0dG9uSWQgIT09IGJ1dHRvbklkKVxuICAgICAgICBwb3BvdmVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IGNvbnRleHRCYWcgPSAoMCwgaW1wb3J0X3JlYWN0MzIudXNlTWVtbykoKCkgPT4gKHtcbiAgICByZWdpc3RlclBvcG92ZXIsXG4gICAgdW5yZWdpc3RlclBvcG92ZXIsXG4gICAgaXNGb2N1c1dpdGhpblBvcG92ZXJHcm91cCxcbiAgICBjbG9zZU90aGVyc1xuICB9KSwgW3JlZ2lzdGVyUG9wb3ZlciwgdW5yZWdpc3RlclBvcG92ZXIsIGlzRm9jdXNXaXRoaW5Qb3BvdmVyR3JvdXAsIGNsb3NlT3RoZXJzXSk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDMyLnVzZU1lbW8pKCgpID0+ICh7fSksIFtdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0geyByZWY6IGdyb3VwUmVmIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFBvcG92ZXJHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dEJhZ1xuICB9LCByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgc2xvdCxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX0dST1VQX1RBRzIsXG4gICAgbmFtZTogXCJQb3BvdmVyLkdyb3VwXCJcbiAgfSkpO1xufSk7XG52YXIgUG9wb3ZlcjIgPSBPYmplY3QuYXNzaWduKFBvcG92ZXJSb290LCB7IEJ1dHRvbjogQnV0dG9uOSwgT3ZlcmxheTogT3ZlcmxheTMsIFBhbmVsOiBQYW5lbDUsIEdyb3VwOiBHcm91cDMgfSk7XG5cbi8vIHNyYy9jb21wb25lbnRzL3JhZGlvLWdyb3VwL3JhZGlvLWdyb3VwLnRzeFxudmFyIGltcG9ydF9yZWFjdDM1ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xuXG4vLyBzcmMvaG9va3MvdXNlLWZsYWdzLnRzXG52YXIgaW1wb3J0X3JlYWN0MzMgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VGbGFncyhpbml0aWFsRmxhZ3MgPSAwKSB7XG4gIGxldCBbZmxhZ3MsIHNldEZsYWdzXSA9ICgwLCBpbXBvcnRfcmVhY3QzMy51c2VTdGF0ZSkoaW5pdGlhbEZsYWdzKTtcbiAgbGV0IGFkZEZsYWcgPSAoMCwgaW1wb3J0X3JlYWN0MzMudXNlQ2FsbGJhY2spKChmbGFnKSA9PiBzZXRGbGFncygoZmxhZ3MyKSA9PiBmbGFnczIgfCBmbGFnKSwgW2ZsYWdzXSk7XG4gIGxldCBoYXNGbGFnID0gKDAsIGltcG9ydF9yZWFjdDMzLnVzZUNhbGxiYWNrKSgoZmxhZykgPT4gQm9vbGVhbihmbGFncyAmIGZsYWcpLCBbZmxhZ3NdKTtcbiAgbGV0IHJlbW92ZUZsYWcgPSAoMCwgaW1wb3J0X3JlYWN0MzMudXNlQ2FsbGJhY2spKChmbGFnKSA9PiBzZXRGbGFncygoZmxhZ3MyKSA9PiBmbGFnczIgJiB+ZmxhZyksIFtzZXRGbGFnc10pO1xuICBsZXQgdG9nZ2xlRmxhZyA9ICgwLCBpbXBvcnRfcmVhY3QzMy51c2VDYWxsYmFjaykoKGZsYWcpID0+IHNldEZsYWdzKChmbGFnczIpID0+IGZsYWdzMiBeIGZsYWcpLCBbc2V0RmxhZ3NdKTtcbiAgcmV0dXJuIHsgYWRkRmxhZywgaGFzRmxhZywgcmVtb3ZlRmxhZywgdG9nZ2xlRmxhZyB9O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9sYWJlbC9sYWJlbC50c3hcbnZhciBpbXBvcnRfcmVhY3QzNCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcbnZhciBMYWJlbENvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzQuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5mdW5jdGlvbiB1c2VMYWJlbENvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDM0LnVzZUNvbnRleHQpKExhYmVsQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgbGV0IGVyciA9IG5ldyBFcnJvcihcIllvdSB1c2VkIGEgPExhYmVsIC8+IGNvbXBvbmVudCwgYnV0IGl0IGlzIG5vdCBpbnNpZGUgYSByZWxldmFudCBwYXJlbnQuXCIpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdXNlTGFiZWxDb250ZXh0KTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB1c2VMYWJlbHMoKSB7XG4gIGxldCBbbGFiZWxJZHMsIHNldExhYmVsSWRzXSA9ICgwLCBpbXBvcnRfcmVhY3QzNC51c2VTdGF0ZSkoW10pO1xuICByZXR1cm4gW1xuICAgIGxhYmVsSWRzLmxlbmd0aCA+IDAgPyBsYWJlbElkcy5qb2luKFwiIFwiKSA6IHZvaWQgMCxcbiAgICAoMCwgaW1wb3J0X3JlYWN0MzQudXNlTWVtbykoKCkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIExhYmVsUHJvdmlkZXIocHJvcHMpIHtcbiAgICAgICAgbGV0IHJlZ2lzdGVyID0gdXNlRXZlbnQoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2V0TGFiZWxJZHMoKGV4aXN0aW5nKSA9PiBbLi4uZXhpc3RpbmcsIHZhbHVlXSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHNldExhYmVsSWRzKChleGlzdGluZykgPT4ge1xuICAgICAgICAgICAgbGV0IGNsb25lID0gZXhpc3Rpbmcuc2xpY2UoKTtcbiAgICAgICAgICAgIGxldCBpZHggPSBjbG9uZS5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKVxuICAgICAgICAgICAgICBjbG9uZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb250ZXh0QmFnID0gKDAsIGltcG9ydF9yZWFjdDM0LnVzZU1lbW8pKCgpID0+ICh7IHJlZ2lzdGVyLCBzbG90OiBwcm9wcy5zbG90LCBuYW1lOiBwcm9wcy5uYW1lLCBwcm9wczogcHJvcHMucHJvcHMgfSksIFtyZWdpc3RlciwgcHJvcHMuc2xvdCwgcHJvcHMubmFtZSwgcHJvcHMucHJvcHNdKTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzNC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGFiZWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgdmFsdWU6IGNvbnRleHRCYWdcbiAgICAgICAgfSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgICAgfTtcbiAgICB9LCBbc2V0TGFiZWxJZHNdKVxuICBdO1xufVxudmFyIERFRkFVTFRfTEFCRUxfVEFHMyA9IFwibGFiZWxcIjtcbnZhciBMYWJlbDUgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIExhYmVsNihwcm9wcywgcmVmKSB7XG4gIGxldCB7IHBhc3NpdmUgPSBmYWxzZSwgLi4udGhlaXJQcm9wcyB9ID0gcHJvcHM7XG4gIGxldCBjb250ZXh0ID0gdXNlTGFiZWxDb250ZXh0KCk7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1sYWJlbC0ke3VzZUlkKCl9YDtcbiAgbGV0IGxhYmVsUmVmID0gdXNlU3luY1JlZnMocmVmKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiBjb250ZXh0LnJlZ2lzdGVyKGlkMiksIFtpZDIsIGNvbnRleHQucmVnaXN0ZXJdKTtcbiAgbGV0IG91clByb3BzID0geyByZWY6IGxhYmVsUmVmLCAuLi5jb250ZXh0LnByb3BzLCBpZDogaWQyIH07XG4gIGlmIChwYXNzaXZlKSB7XG4gICAgaWYgKFwib25DbGlja1wiIGluIG91clByb3BzKSB7XG4gICAgICBkZWxldGUgb3VyUHJvcHNbXCJvbkNsaWNrXCJdO1xuICAgIH1cbiAgICBpZiAoXCJvbkNsaWNrXCIgaW4gdGhlaXJQcm9wcykge1xuICAgICAgZGVsZXRlIHRoZWlyUHJvcHNbXCJvbkNsaWNrXCJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3Q6IGNvbnRleHQuc2xvdCB8fCB7fSxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX0xBQkVMX1RBRzMsXG4gICAgbmFtZTogY29udGV4dC5uYW1lIHx8IFwiTGFiZWxcIlxuICB9KTtcbn0pO1xuXG4vLyBzcmMvY29tcG9uZW50cy9yYWRpby1ncm91cC9yYWRpby1ncm91cC50c3hcbnZhciByZWR1Y2VyczcgPSB7XG4gIFswIC8qIFJlZ2lzdGVyT3B0aW9uICovXShzdGF0ZTIsIGFjdGlvbikge1xuICAgIGxldCBuZXh0T3B0aW9ucyA9IFtcbiAgICAgIC4uLnN0YXRlMi5vcHRpb25zLFxuICAgICAgeyBpZDogYWN0aW9uLmlkLCBlbGVtZW50OiBhY3Rpb24uZWxlbWVudCwgcHJvcHNSZWY6IGFjdGlvbi5wcm9wc1JlZiB9XG4gICAgXTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUyLFxuICAgICAgb3B0aW9uczogc29ydEJ5RG9tTm9kZShuZXh0T3B0aW9ucywgKG9wdGlvbikgPT4gb3B0aW9uLmVsZW1lbnQuY3VycmVudClcbiAgICB9O1xuICB9LFxuICBbMSAvKiBVbnJlZ2lzdGVyT3B0aW9uICovXShzdGF0ZTIsIGFjdGlvbikge1xuICAgIGxldCBvcHRpb25zID0gc3RhdGUyLm9wdGlvbnMuc2xpY2UoKTtcbiAgICBsZXQgaWR4ID0gc3RhdGUyLm9wdGlvbnMuZmluZEluZGV4KChyYWRpbykgPT4gcmFkaW8uaWQgPT09IGFjdGlvbi5pZCk7XG4gICAgaWYgKGlkeCA9PT0gLTEpXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIG9wdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBvcHRpb25zIH07XG4gIH1cbn07XG52YXIgUmFkaW9Hcm91cENvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzUuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5SYWRpb0dyb3VwQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUmFkaW9Hcm91cENvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZVJhZGlvR3JvdXBDb250ZXh0KGNvbXBvbmVudCkge1xuICBsZXQgY29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzNS51c2VDb250ZXh0KShSYWRpb0dyb3VwQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgbGV0IGVyciA9IG5ldyBFcnJvcihgPCR7Y29tcG9uZW50fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxSYWRpb0dyb3VwIC8+IGNvbXBvbmVudC5gKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHVzZVJhZGlvR3JvdXBDb250ZXh0KTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBzdGF0ZVJlZHVjZXI3KHN0YXRlMiwgYWN0aW9uKSB7XG4gIHJldHVybiBtYXRjaChhY3Rpb24udHlwZSwgcmVkdWNlcnM3LCBzdGF0ZTIsIGFjdGlvbik7XG59XG52YXIgREVGQVVMVF9SQURJT19HUk9VUF9UQUcgPSBcImRpdlwiO1xudmFyIFJhZGlvR3JvdXBSb290ID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBSYWRpb0dyb3VwKHByb3BzLCByZWYpIHtcbiAgbGV0IHtcbiAgICB2YWx1ZTogY29udHJvbGxlZFZhbHVlLFxuICAgIGRlZmF1bHRWYWx1ZSxcbiAgICBuYW1lLFxuICAgIG9uQ2hhbmdlOiBjb250cm9sbGVkT25DaGFuZ2UsXG4gICAgYnkgPSAoYSwgeikgPT4gYSA9PT0geixcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIC4uLnRoZWlyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBsZXQgY29tcGFyZSA9IHVzZUV2ZW50KHR5cGVvZiBieSA9PT0gXCJzdHJpbmdcIiA/IChhLCB6KSA9PiB7XG4gICAgbGV0IHByb3BlcnR5ID0gYnk7XG4gICAgcmV0dXJuIChhID09IG51bGwgPyB2b2lkIDAgOiBhW3Byb3BlcnR5XSkgPT09ICh6ID09IG51bGwgPyB2b2lkIDAgOiB6W3Byb3BlcnR5XSk7XG4gIH0gOiBieSk7XG4gIGxldCBbc3RhdGUyLCBkaXNwYXRjaF0gPSAoMCwgaW1wb3J0X3JlYWN0MzUudXNlUmVkdWNlcikoc3RhdGVSZWR1Y2VyNywgeyBvcHRpb25zOiBbXSB9KTtcbiAgbGV0IG9wdGlvbnMgPSBzdGF0ZTIub3B0aW9ucztcbiAgbGV0IFtsYWJlbGxlZGJ5LCBMYWJlbFByb3ZpZGVyXSA9IHVzZUxhYmVscygpO1xuICBsZXQgW2Rlc2NyaWJlZGJ5LCBEZXNjcmlwdGlvblByb3ZpZGVyXSA9IHVzZURlc2NyaXB0aW9ucygpO1xuICBsZXQgaWQyID0gYGhlYWRsZXNzdWktcmFkaW9ncm91cC0ke3VzZUlkKCl9YDtcbiAgbGV0IGludGVybmFsUmFkaW9Hcm91cFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QzNS51c2VSZWYpKG51bGwpO1xuICBsZXQgcmFkaW9Hcm91cFJlZiA9IHVzZVN5bmNSZWZzKGludGVybmFsUmFkaW9Hcm91cFJlZiwgcmVmKTtcbiAgbGV0IFt2YWx1ZSwgb25DaGFuZ2VdID0gdXNlQ29udHJvbGxhYmxlKGNvbnRyb2xsZWRWYWx1ZSwgY29udHJvbGxlZE9uQ2hhbmdlLCBkZWZhdWx0VmFsdWUpO1xuICBsZXQgZmlyc3RPcHRpb24gPSAoMCwgaW1wb3J0X3JlYWN0MzUudXNlTWVtbykoKCkgPT4gb3B0aW9ucy5maW5kKChvcHRpb24pID0+IHtcbiAgICBpZiAob3B0aW9uLnByb3BzUmVmLmN1cnJlbnQuZGlzYWJsZWQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pLCBbb3B0aW9uc10pO1xuICBsZXQgY29udGFpbnNDaGVja2VkT3B0aW9uID0gKDAsIGltcG9ydF9yZWFjdDM1LnVzZU1lbW8pKCgpID0+IG9wdGlvbnMuc29tZSgob3B0aW9uKSA9PiBjb21wYXJlKG9wdGlvbi5wcm9wc1JlZi5jdXJyZW50LnZhbHVlLCB2YWx1ZSkpLCBbb3B0aW9ucywgdmFsdWVdKTtcbiAgbGV0IHRyaWdnZXJDaGFuZ2UgPSB1c2VFdmVudCgobmV4dFZhbHVlKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoZGlzYWJsZWQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNvbXBhcmUobmV4dFZhbHVlLCB2YWx1ZSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG5leHRPcHRpb24gPSAoX2EyID0gb3B0aW9ucy5maW5kKChvcHRpb24pID0+IGNvbXBhcmUob3B0aW9uLnByb3BzUmVmLmN1cnJlbnQudmFsdWUsIG5leHRWYWx1ZSkpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnByb3BzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKG5leHRPcHRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG5leHRPcHRpb24uZGlzYWJsZWQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2hhbmdlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICB1c2VUcmVlV2Fsa2VyKHtcbiAgICBjb250YWluZXI6IGludGVybmFsUmFkaW9Hcm91cFJlZi5jdXJyZW50LFxuICAgIGFjY2VwdChub2RlKSB7XG4gICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcInJhZGlvXCIpXG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJyb2xlXCIpKVxuICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgfSxcbiAgICB3YWxrKG5vZGUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm5vbmVcIik7XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUtleURvd24gPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBsZXQgY29udGFpbmVyID0gaW50ZXJuYWxSYWRpb0dyb3VwUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjb250YWluZXIpXG4gICAgICByZXR1cm47XG4gICAgbGV0IG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50KGNvbnRhaW5lcik7XG4gICAgbGV0IGFsbCA9IG9wdGlvbnMuZmlsdGVyKChvcHRpb24pID0+IG9wdGlvbi5wcm9wc1JlZi5jdXJyZW50LmRpc2FibGVkID09PSBmYWxzZSkubWFwKChyYWRpbykgPT4gcmFkaW8uZWxlbWVudC5jdXJyZW50KTtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIkVudGVyXCIgLyogRW50ZXIgKi86XG4gICAgICAgIGF0dGVtcHRTdWJtaXQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93TGVmdFwiIC8qIEFycm93TGVmdCAqLzpcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCIgLyogQXJyb3dVcCAqLzpcbiAgICAgICAge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGZvY3VzSW4oYWxsLCAyIC8qIFByZXZpb3VzICovIHwgMTYgLyogV3JhcEFyb3VuZCAqLyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gMiAvKiBTdWNjZXNzICovKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlT3B0aW9uID0gb3B0aW9ucy5maW5kKChvcHRpb24pID0+IG9wdGlvbi5lbGVtZW50LmN1cnJlbnQgPT09IChvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVPcHRpb24pXG4gICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UoYWN0aXZlT3B0aW9uLnByb3BzUmVmLmN1cnJlbnQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCIgLyogQXJyb3dSaWdodCAqLzpcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIiAvKiBBcnJvd0Rvd24gKi86XG4gICAgICAgIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBmb2N1c0luKGFsbCwgNCAvKiBOZXh0ICovIHwgMTYgLyogV3JhcEFyb3VuZCAqLyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gMiAvKiBTdWNjZXNzICovKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlT3B0aW9uID0gb3B0aW9ucy5maW5kKChvcHRpb24pID0+IG9wdGlvbi5lbGVtZW50LmN1cnJlbnQgPT09IChvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVPcHRpb24pXG4gICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UoYWN0aXZlT3B0aW9uLnByb3BzUmVmLmN1cnJlbnQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIgXCIgLyogU3BhY2UgKi86XG4gICAgICAgIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGxldCBhY3RpdmVPcHRpb24gPSBvcHRpb25zLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uLmVsZW1lbnQuY3VycmVudCA9PT0gKG93bmVyRG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpO1xuICAgICAgICAgIGlmIChhY3RpdmVPcHRpb24pXG4gICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlKGFjdGl2ZU9wdGlvbi5wcm9wc1JlZi5jdXJyZW50LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICBsZXQgcmVnaXN0ZXJPcHRpb24gPSB1c2VFdmVudCgob3B0aW9uKSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAwIC8qIFJlZ2lzdGVyT3B0aW9uICovLCAuLi5vcHRpb24gfSk7XG4gICAgcmV0dXJuICgpID0+IGRpc3BhdGNoKHsgdHlwZTogMSAvKiBVbnJlZ2lzdGVyT3B0aW9uICovLCBpZDogb3B0aW9uLmlkIH0pO1xuICB9KTtcbiAgbGV0IGFwaSA9ICgwLCBpbXBvcnRfcmVhY3QzNS51c2VNZW1vKSgoKSA9PiAoe1xuICAgIHJlZ2lzdGVyT3B0aW9uLFxuICAgIGZpcnN0T3B0aW9uLFxuICAgIGNvbnRhaW5zQ2hlY2tlZE9wdGlvbixcbiAgICBjaGFuZ2U6IHRyaWdnZXJDaGFuZ2UsXG4gICAgZGlzYWJsZWQsXG4gICAgdmFsdWUsXG4gICAgY29tcGFyZVxuICB9KSwgW3JlZ2lzdGVyT3B0aW9uLCBmaXJzdE9wdGlvbiwgY29udGFpbnNDaGVja2VkT3B0aW9uLCB0cmlnZ2VyQ2hhbmdlLCBkaXNhYmxlZCwgdmFsdWUsIGNvbXBhcmVdKTtcbiAgbGV0IG91clByb3BzID0ge1xuICAgIHJlZjogcmFkaW9Hcm91cFJlZixcbiAgICBpZDogaWQyLFxuICAgIHJvbGU6IFwicmFkaW9ncm91cFwiLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkYnksXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGRlc2NyaWJlZGJ5LFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93blxuICB9O1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QzNS51c2VNZW1vKSgoKSA9PiAoeyB2YWx1ZSB9KSwgW3ZhbHVlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KERlc2NyaXB0aW9uUHJvdmlkZXIsIHtcbiAgICBuYW1lOiBcIlJhZGlvR3JvdXAuRGVzY3JpcHRpb25cIlxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KExhYmVsUHJvdmlkZXIsIHtcbiAgICBuYW1lOiBcIlJhZGlvR3JvdXAuTGFiZWxcIlxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJhZGlvR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFwaVxuICB9LCBuYW1lICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCAmJiBvYmplY3RUb0Zvcm1FbnRyaWVzKHsgW25hbWVdOiB2YWx1ZSB9KS5tYXAoKFtuYW1lMiwgdmFsdWUyXSkgPT4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM1LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIaWRkZW4sIHtcbiAgICBmZWF0dXJlczogNCAvKiBIaWRkZW4gKi8sXG4gICAgLi4uY29tcGFjdCh7XG4gICAgICBrZXk6IG5hbWUyLFxuICAgICAgYXM6IFwiaW5wdXRcIixcbiAgICAgIHR5cGU6IFwicmFkaW9cIixcbiAgICAgIGNoZWNrZWQ6IHZhbHVlMiAhPSBudWxsLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICBuYW1lOiBuYW1lMixcbiAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICB9KVxuICB9KSksIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfUkFESU9fR1JPVVBfVEFHLFxuICAgIG5hbWU6IFwiUmFkaW9Hcm91cFwiXG4gIH0pKSkpO1xufSk7XG52YXIgREVGQVVMVF9PUFRJT05fVEFHMyA9IFwiZGl2XCI7XG52YXIgT3B0aW9uNSA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gT3B0aW9uNihwcm9wcywgcmVmKSB7XG4gIGxldCBpbnRlcm5hbE9wdGlvblJlZiA9ICgwLCBpbXBvcnRfcmVhY3QzNS51c2VSZWYpKG51bGwpO1xuICBsZXQgb3B0aW9uUmVmID0gdXNlU3luY1JlZnMoaW50ZXJuYWxPcHRpb25SZWYsIHJlZik7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS1yYWRpb2dyb3VwLW9wdGlvbi0ke3VzZUlkKCl9YDtcbiAgbGV0IFtsYWJlbGxlZGJ5LCBMYWJlbFByb3ZpZGVyXSA9IHVzZUxhYmVscygpO1xuICBsZXQgW2Rlc2NyaWJlZGJ5LCBEZXNjcmlwdGlvblByb3ZpZGVyXSA9IHVzZURlc2NyaXB0aW9ucygpO1xuICBsZXQgeyBhZGRGbGFnLCByZW1vdmVGbGFnLCBoYXNGbGFnIH0gPSB1c2VGbGFncygxIC8qIEVtcHR5ICovKTtcbiAgbGV0IHsgdmFsdWUsIGRpc2FibGVkID0gZmFsc2UsIC4uLnRoZWlyUHJvcHMgfSA9IHByb3BzO1xuICBsZXQgcHJvcHNSZWYgPSAoMCwgaW1wb3J0X3JlYWN0MzUudXNlUmVmKSh7IHZhbHVlLCBkaXNhYmxlZCB9KTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgcHJvcHNSZWYuY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICB9LCBbdmFsdWUsIHByb3BzUmVmXSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIHByb3BzUmVmLmN1cnJlbnQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgfSwgW2Rpc2FibGVkLCBwcm9wc1JlZl0pO1xuICBsZXQge1xuICAgIHJlZ2lzdGVyT3B0aW9uLFxuICAgIGRpc2FibGVkOiByYWRpb0dyb3VwRGlzYWJsZWQsXG4gICAgY2hhbmdlLFxuICAgIGZpcnN0T3B0aW9uLFxuICAgIGNvbnRhaW5zQ2hlY2tlZE9wdGlvbixcbiAgICB2YWx1ZTogcmFkaW9Hcm91cFZhbHVlLFxuICAgIGNvbXBhcmVcbiAgfSA9IHVzZVJhZGlvR3JvdXBDb250ZXh0KFwiUmFkaW9Hcm91cC5PcHRpb25cIik7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4gcmVnaXN0ZXJPcHRpb24oeyBpZDogaWQyLCBlbGVtZW50OiBpbnRlcm5hbE9wdGlvblJlZiwgcHJvcHNSZWYgfSksIFtpZDIsIHJlZ2lzdGVyT3B0aW9uLCBpbnRlcm5hbE9wdGlvblJlZiwgcHJvcHNdKTtcbiAgbGV0IGhhbmRsZUNsaWNrID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoaXNEaXNhYmxlZFJlYWN0SXNzdWU3NzExKGV2ZW50LmN1cnJlbnRUYXJnZXQpKVxuICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCFjaGFuZ2UodmFsdWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGFkZEZsYWcoMiAvKiBBY3RpdmUgKi8pO1xuICAgIChfYTIgPSBpbnRlcm5hbE9wdGlvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZvY3VzKCk7XG4gIH0pO1xuICBsZXQgaGFuZGxlRm9jdXMgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBpZiAoaXNEaXNhYmxlZFJlYWN0SXNzdWU3NzExKGV2ZW50LmN1cnJlbnRUYXJnZXQpKVxuICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgYWRkRmxhZygyIC8qIEFjdGl2ZSAqLyk7XG4gIH0pO1xuICBsZXQgaGFuZGxlQmx1ciA9IHVzZUV2ZW50KCgpID0+IHJlbW92ZUZsYWcoMiAvKiBBY3RpdmUgKi8pKTtcbiAgbGV0IGlzRmlyc3RPcHRpb24gPSAoZmlyc3RPcHRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0T3B0aW9uLmlkKSA9PT0gaWQyO1xuICBsZXQgaXNEaXNhYmxlZCA9IHJhZGlvR3JvdXBEaXNhYmxlZCB8fCBkaXNhYmxlZDtcbiAgbGV0IGNoZWNrZWQgPSBjb21wYXJlKHJhZGlvR3JvdXBWYWx1ZSwgdmFsdWUpO1xuICBsZXQgb3VyUHJvcHMgPSB7XG4gICAgcmVmOiBvcHRpb25SZWYsXG4gICAgaWQ6IGlkMixcbiAgICByb2xlOiBcInJhZGlvXCIsXG4gICAgXCJhcmlhLWNoZWNrZWRcIjogY2hlY2tlZCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkYnksXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGRlc2NyaWJlZGJ5LFxuICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBpc0Rpc2FibGVkID8gdHJ1ZSA6IHZvaWQgMCxcbiAgICB0YWJJbmRleDogKCgpID0+IHtcbiAgICAgIGlmIChpc0Rpc2FibGVkKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoY2hlY2tlZClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBpZiAoIWNvbnRhaW5zQ2hlY2tlZE9wdGlvbiAmJiBpc0ZpcnN0T3B0aW9uKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9KSgpLFxuICAgIG9uQ2xpY2s6IGlzRGlzYWJsZWQgPyB2b2lkIDAgOiBoYW5kbGVDbGljayxcbiAgICBvbkZvY3VzOiBpc0Rpc2FibGVkID8gdm9pZCAwIDogaGFuZGxlRm9jdXMsXG4gICAgb25CbHVyOiBpc0Rpc2FibGVkID8gdm9pZCAwIDogaGFuZGxlQmx1clxuICB9O1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QzNS51c2VNZW1vKSgoKSA9PiAoeyBjaGVja2VkLCBkaXNhYmxlZDogaXNEaXNhYmxlZCwgYWN0aXZlOiBoYXNGbGFnKDIgLyogQWN0aXZlICovKSB9KSwgW2NoZWNrZWQsIGlzRGlzYWJsZWQsIGhhc0ZsYWddKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzNS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGVzY3JpcHRpb25Qcm92aWRlciwge1xuICAgIG5hbWU6IFwiUmFkaW9Hcm91cC5EZXNjcmlwdGlvblwiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzNS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGFiZWxQcm92aWRlciwge1xuICAgIG5hbWU6IFwiUmFkaW9Hcm91cC5MYWJlbFwiXG4gIH0sIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfT1BUSU9OX1RBRzMsXG4gICAgbmFtZTogXCJSYWRpb0dyb3VwLk9wdGlvblwiXG4gIH0pKSk7XG59KTtcbnZhciBSYWRpb0dyb3VwMiA9IE9iamVjdC5hc3NpZ24oUmFkaW9Hcm91cFJvb3QsIHsgT3B0aW9uOiBPcHRpb241LCBMYWJlbDogTGFiZWw1LCBEZXNjcmlwdGlvbiB9KTtcblxuLy8gc3JjL2NvbXBvbmVudHMvc3dpdGNoL3N3aXRjaC50c3hcbnZhciBpbXBvcnRfcmVhY3QzNiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcbnZhciBHcm91cENvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzYuY3JlYXRlQ29udGV4dCkobnVsbCk7XG5Hcm91cENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkdyb3VwQ29udGV4dFwiO1xudmFyIERFRkFVTFRfR1JPVVBfVEFHMyA9IGltcG9ydF9yZWFjdDM2LkZyYWdtZW50O1xuZnVuY3Rpb24gR3JvdXA1KHByb3BzKSB7XG4gIGxldCBbc3dpdGNoRWxlbWVudCwgc2V0U3dpdGNoRWxlbWVudF0gPSAoMCwgaW1wb3J0X3JlYWN0MzYudXNlU3RhdGUpKG51bGwpO1xuICBsZXQgW2xhYmVsbGVkYnksIExhYmVsUHJvdmlkZXJdID0gdXNlTGFiZWxzKCk7XG4gIGxldCBbZGVzY3JpYmVkYnksIERlc2NyaXB0aW9uUHJvdmlkZXJdID0gdXNlRGVzY3JpcHRpb25zKCk7XG4gIGxldCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDM2LnVzZU1lbW8pKCgpID0+ICh7IHN3aXRjaDogc3dpdGNoRWxlbWVudCwgc2V0U3dpdGNoOiBzZXRTd2l0Y2hFbGVtZW50LCBsYWJlbGxlZGJ5LCBkZXNjcmliZWRieSB9KSwgW3N3aXRjaEVsZW1lbnQsIHNldFN3aXRjaEVsZW1lbnQsIGxhYmVsbGVkYnksIGRlc2NyaWJlZGJ5XSk7XG4gIGxldCBvdXJQcm9wcyA9IHt9O1xuICBsZXQgdGhlaXJQcm9wcyA9IHByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM2LmRlZmF1bHQuY3JlYXRlRWxlbWVudChEZXNjcmlwdGlvblByb3ZpZGVyLCB7XG4gICAgbmFtZTogXCJTd2l0Y2guRGVzY3JpcHRpb25cIlxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzYuZGVmYXVsdC5jcmVhdGVFbGVtZW50KExhYmVsUHJvdmlkZXIsIHtcbiAgICBuYW1lOiBcIlN3aXRjaC5MYWJlbFwiLFxuICAgIHByb3BzOiB7XG4gICAgICBvbkNsaWNrKCkge1xuICAgICAgICBpZiAoIXN3aXRjaEVsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzd2l0Y2hFbGVtZW50LmNsaWNrKCk7XG4gICAgICAgIHN3aXRjaEVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM2LmRlZmF1bHQuY3JlYXRlRWxlbWVudChHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCByZW5kZXIoe1xuICAgIG91clByb3BzLFxuICAgIHRoZWlyUHJvcHMsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9HUk9VUF9UQUczLFxuICAgIG5hbWU6IFwiU3dpdGNoLkdyb3VwXCJcbiAgfSkpKSk7XG59XG52YXIgREVGQVVMVF9TV0lUQ0hfVEFHID0gXCJidXR0b25cIjtcbnZhciBTd2l0Y2hSb290ID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBTd2l0Y2gocHJvcHMsIHJlZikge1xuICBsZXQge1xuICAgIGNoZWNrZWQ6IGNvbnRyb2xsZWRDaGVja2VkLFxuICAgIGRlZmF1bHRDaGVja2VkID0gZmFsc2UsXG4gICAgb25DaGFuZ2U6IGNvbnRyb2xsZWRPbkNoYW5nZSxcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIC4uLnRoZWlyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBsZXQgaWQyID0gYGhlYWRsZXNzdWktc3dpdGNoLSR7dXNlSWQoKX1gO1xuICBsZXQgZ3JvdXBDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDM2LnVzZUNvbnRleHQpKEdyb3VwQ29udGV4dCk7XG4gIGxldCBpbnRlcm5hbFN3aXRjaFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QzNi51c2VSZWYpKG51bGwpO1xuICBsZXQgc3dpdGNoUmVmID0gdXNlU3luY1JlZnMoaW50ZXJuYWxTd2l0Y2hSZWYsIHJlZiwgZ3JvdXBDb250ZXh0ID09PSBudWxsID8gbnVsbCA6IGdyb3VwQ29udGV4dC5zZXRTd2l0Y2gpO1xuICBsZXQgW2NoZWNrZWQsIG9uQ2hhbmdlXSA9IHVzZUNvbnRyb2xsYWJsZShjb250cm9sbGVkQ2hlY2tlZCwgY29udHJvbGxlZE9uQ2hhbmdlLCBkZWZhdWx0Q2hlY2tlZCk7XG4gIGxldCB0b2dnbGUgPSB1c2VFdmVudCgoKSA9PiBvbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogb25DaGFuZ2UoIWNoZWNrZWQpKTtcbiAgbGV0IGhhbmRsZUNsaWNrID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGlzRGlzYWJsZWRSZWFjdElzc3VlNzcxMShldmVudC5jdXJyZW50VGFyZ2V0KSlcbiAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdG9nZ2xlKCk7XG4gIH0pO1xuICBsZXQgaGFuZGxlS2V5VXAgPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIiBcIiAvKiBTcGFjZSAqLykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRvZ2dsZSgpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgLyogRW50ZXIgKi8pIHtcbiAgICAgIGF0dGVtcHRTdWJtaXQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IGhhbmRsZUtleVByZXNzID0gdXNlRXZlbnQoKGV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MzYudXNlTWVtbykoKCkgPT4gKHsgY2hlY2tlZCB9KSwgW2NoZWNrZWRdKTtcbiAgbGV0IG91clByb3BzID0ge1xuICAgIGlkOiBpZDIsXG4gICAgcmVmOiBzd2l0Y2hSZWYsXG4gICAgcm9sZTogXCJzd2l0Y2hcIixcbiAgICB0eXBlOiB1c2VSZXNvbHZlQnV0dG9uVHlwZShwcm9wcywgaW50ZXJuYWxTd2l0Y2hSZWYpLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIFwiYXJpYS1jaGVja2VkXCI6IGNoZWNrZWQsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogZ3JvdXBDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBncm91cENvbnRleHQubGFiZWxsZWRieSxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogZ3JvdXBDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBncm91cENvbnRleHQuZGVzY3JpYmVkYnksXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgb25LZXlVcDogaGFuZGxlS2V5VXAsXG4gICAgb25LZXlQcmVzczogaGFuZGxlS2V5UHJlc3NcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzNi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoaW1wb3J0X3JlYWN0MzYuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgbmFtZSAhPSBudWxsICYmIGNoZWNrZWQgJiYgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM2LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIaWRkZW4sIHtcbiAgICBmZWF0dXJlczogNCAvKiBIaWRkZW4gKi8sXG4gICAgLi4uY29tcGFjdCh7XG4gICAgICBhczogXCJpbnB1dFwiLFxuICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICBjaGVja2VkLFxuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlXG4gICAgfSlcbiAgfSksIHJlbmRlcih7IG91clByb3BzLCB0aGVpclByb3BzLCBzbG90LCBkZWZhdWx0VGFnOiBERUZBVUxUX1NXSVRDSF9UQUcsIG5hbWU6IFwiU3dpdGNoXCIgfSkpO1xufSk7XG52YXIgU3dpdGNoMiA9IE9iamVjdC5hc3NpZ24oU3dpdGNoUm9vdCwgeyBHcm91cDogR3JvdXA1LCBMYWJlbDogTGFiZWw1LCBEZXNjcmlwdGlvbiB9KTtcblxuLy8gc3JjL2NvbXBvbmVudHMvdGFicy90YWJzLnRzeFxudmFyIGltcG9ydF9yZWFjdDM4ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIiksIDEpO1xuXG4vLyBzcmMvaW50ZXJuYWwvZm9jdXMtc2VudGluZWwudHN4XG52YXIgaW1wb3J0X3JlYWN0MzcgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSwgMSk7XG5mdW5jdGlvbiBGb2N1c1NlbnRpbmVsKHsgb25Gb2N1cyB9KSB7XG4gIGxldCBbZW5hYmxlZCwgc2V0RW5hYmxlZF0gPSAoMCwgaW1wb3J0X3JlYWN0MzcudXNlU3RhdGUpKHRydWUpO1xuICBpZiAoIWVuYWJsZWQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzcuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhpZGRlbiwge1xuICAgIGFzOiBcImJ1dHRvblwiLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgZmVhdHVyZXM6IDIgLyogRm9jdXNhYmxlICovLFxuICAgIG9uRm9jdXM6IChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCBmcmFtZTtcbiAgICAgIGxldCB0cmllcyA9IDUwO1xuICAgICAgZnVuY3Rpb24gZm9yd2FyZEZvY3VzKCkge1xuICAgICAgICBpZiAodHJpZXMtLSA8PSAwKSB7XG4gICAgICAgICAgaWYgKGZyYW1lKVxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Gb2N1cygpKSB7XG4gICAgICAgICAgc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmb3J3YXJkRm9jdXMpO1xuICAgICAgfVxuICAgICAgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm9yd2FyZEZvY3VzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy90YWJzL3RhYnMudHN4XG52YXIgcmVkdWNlcnM4ID0ge1xuICBbMCAvKiBTZXRTZWxlY3RlZEluZGV4ICovXShzdGF0ZTIsIGFjdGlvbikge1xuICAgIGxldCBmb2N1c2FibGVUYWJzID0gc3RhdGUyLnRhYnMuZmlsdGVyKCh0YWIpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gISgoX2EyID0gdGFiLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikpO1xuICAgIH0pO1xuICAgIGlmIChhY3Rpb24uaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZTIsIHNlbGVjdGVkSW5kZXg6IHN0YXRlMi50YWJzLmluZGV4T2YoZm9jdXNhYmxlVGFic1swXSkgfTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbi5pbmRleCA+IHN0YXRlMi50YWJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUyLFxuICAgICAgICBzZWxlY3RlZEluZGV4OiBzdGF0ZTIudGFicy5pbmRleE9mKGZvY3VzYWJsZVRhYnNbZm9jdXNhYmxlVGFicy5sZW5ndGggLSAxXSlcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBiZWZvcmUgPSBzdGF0ZTIudGFicy5zbGljZSgwLCBhY3Rpb24uaW5kZXgpO1xuICAgIGxldCBhZnRlciA9IHN0YXRlMi50YWJzLnNsaWNlKGFjdGlvbi5pbmRleCk7XG4gICAgbGV0IG5leHQgPSBbLi4uYWZ0ZXIsIC4uLmJlZm9yZV0uZmluZCgodGFiKSA9PiBmb2N1c2FibGVUYWJzLmluY2x1ZGVzKHRhYikpO1xuICAgIGlmICghbmV4dClcbiAgICAgIHJldHVybiBzdGF0ZTI7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBzZWxlY3RlZEluZGV4OiBzdGF0ZTIudGFicy5pbmRleE9mKG5leHQpIH07XG4gIH0sXG4gIFsxIC8qIFJlZ2lzdGVyVGFiICovXShzdGF0ZTIsIGFjdGlvbikge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHN0YXRlMi50YWJzLmluY2x1ZGVzKGFjdGlvbi50YWIpKVxuICAgICAgcmV0dXJuIHN0YXRlMjtcbiAgICBsZXQgYWN0aXZlVGFiID0gc3RhdGUyLnRhYnNbc3RhdGUyLnNlbGVjdGVkSW5kZXhdO1xuICAgIGxldCBhZGp1c3RlZFRhYnMgPSBzb3J0QnlEb21Ob2RlKFsuLi5zdGF0ZTIudGFicywgYWN0aW9uLnRhYl0sICh0YWIpID0+IHRhYi5jdXJyZW50KTtcbiAgICBsZXQgc2VsZWN0ZWRJbmRleCA9IChfYTIgPSBhZGp1c3RlZFRhYnMuaW5kZXhPZihhY3RpdmVUYWIpKSAhPSBudWxsID8gX2EyIDogc3RhdGUyLnNlbGVjdGVkSW5kZXg7XG4gICAgaWYgKHNlbGVjdGVkSW5kZXggPT09IC0xKVxuICAgICAgc2VsZWN0ZWRJbmRleCA9IHN0YXRlMi5zZWxlY3RlZEluZGV4O1xuICAgIHJldHVybiB7IC4uLnN0YXRlMiwgdGFiczogYWRqdXN0ZWRUYWJzLCBzZWxlY3RlZEluZGV4IH07XG4gIH0sXG4gIFsyIC8qIFVucmVnaXN0ZXJUYWIgKi9dKHN0YXRlMiwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCB0YWJzOiBzdGF0ZTIudGFicy5maWx0ZXIoKHRhYikgPT4gdGFiICE9PSBhY3Rpb24udGFiKSB9O1xuICB9LFxuICBbMyAvKiBSZWdpc3RlclBhbmVsICovXShzdGF0ZTIsIGFjdGlvbikge1xuICAgIGlmIChzdGF0ZTIucGFuZWxzLmluY2x1ZGVzKGFjdGlvbi5wYW5lbCkpXG4gICAgICByZXR1cm4gc3RhdGUyO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZTIsXG4gICAgICBwYW5lbHM6IHNvcnRCeURvbU5vZGUoWy4uLnN0YXRlMi5wYW5lbHMsIGFjdGlvbi5wYW5lbF0sIChwYW5lbCkgPT4gcGFuZWwuY3VycmVudClcbiAgICB9O1xuICB9LFxuICBbNCAvKiBVbnJlZ2lzdGVyUGFuZWwgKi9dKHN0YXRlMiwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGUyLCBwYW5lbHM6IHN0YXRlMi5wYW5lbHMuZmlsdGVyKChwYW5lbCkgPT4gcGFuZWwgIT09IGFjdGlvbi5wYW5lbCkgfTtcbiAgfVxufTtcbnZhciBUYWJzU1NSQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzOC5jcmVhdGVDb250ZXh0KShudWxsKTtcblRhYnNTU1JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJUYWJzU1NSQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlU1NSVGFic0NvdW50ZXIoY29tcG9uZW50KSB7XG4gIGxldCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDM4LnVzZUNvbnRleHQpKFRhYnNTU1JDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICBsZXQgZXJyID0gbmV3IEVycm9yKGA8JHtjb21wb25lbnR9IC8+IGlzIG1pc3NpbmcgYSBwYXJlbnQgPFRhYi5Hcm91cCAvPiBjb21wb25lbnQuYCk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB1c2VTU1JUYWJzQ291bnRlcik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIFRhYnNEYXRhQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzOC5jcmVhdGVDb250ZXh0KShudWxsKTtcblRhYnNEYXRhQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVGFic0RhdGFDb250ZXh0XCI7XG5mdW5jdGlvbiB1c2VEYXRhMihjb21wb25lbnQpIHtcbiAgbGV0IGNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzgudXNlQ29udGV4dCkoVGFic0RhdGFDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICBsZXQgZXJyID0gbmV3IEVycm9yKGA8JHtjb21wb25lbnR9IC8+IGlzIG1pc3NpbmcgYSBwYXJlbnQgPFRhYi5Hcm91cCAvPiBjb21wb25lbnQuYCk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB1c2VEYXRhMik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIFRhYnNBY3Rpb25zQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzOC5jcmVhdGVDb250ZXh0KShudWxsKTtcblRhYnNBY3Rpb25zQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVGFic0FjdGlvbnNDb250ZXh0XCI7XG5mdW5jdGlvbiB1c2VBY3Rpb25zMihjb21wb25lbnQpIHtcbiAgbGV0IGNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0MzgudXNlQ29udGV4dCkoVGFic0FjdGlvbnNDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICBsZXQgZXJyID0gbmV3IEVycm9yKGA8JHtjb21wb25lbnR9IC8+IGlzIG1pc3NpbmcgYSBwYXJlbnQgPFRhYi5Hcm91cCAvPiBjb21wb25lbnQuYCk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB1c2VBY3Rpb25zMik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gc3RhdGVSZWR1Y2VyOChzdGF0ZTIsIGFjdGlvbikge1xuICByZXR1cm4gbWF0Y2goYWN0aW9uLnR5cGUsIHJlZHVjZXJzOCwgc3RhdGUyLCBhY3Rpb24pO1xufVxudmFyIERFRkFVTFRfVEFCU19UQUcgPSBpbXBvcnRfcmVhY3QzOC5GcmFnbWVudDtcbnZhciBUYWJzID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBUYWJzMihwcm9wcywgcmVmKSB7XG4gIGxldCB7XG4gICAgZGVmYXVsdEluZGV4ID0gMCxcbiAgICB2ZXJ0aWNhbCA9IGZhbHNlLFxuICAgIG1hbnVhbCA9IGZhbHNlLFxuICAgIG9uQ2hhbmdlLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsLFxuICAgIC4uLnRoZWlyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBvcmllbnRhdGlvbiA9IHZlcnRpY2FsID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCI7XG4gIGNvbnN0IGFjdGl2YXRpb24gPSBtYW51YWwgPyBcIm1hbnVhbFwiIDogXCJhdXRvXCI7XG4gIGxldCBpc0NvbnRyb2xsZWQgPSBzZWxlY3RlZEluZGV4ICE9PSBudWxsO1xuICBsZXQgdGFic1JlZiA9IHVzZVN5bmNSZWZzKHJlZik7XG4gIGxldCBbc3RhdGUyLCBkaXNwYXRjaF0gPSAoMCwgaW1wb3J0X3JlYWN0MzgudXNlUmVkdWNlcikoc3RhdGVSZWR1Y2VyOCwge1xuICAgIHNlbGVjdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXggIT0gbnVsbCA/IHNlbGVjdGVkSW5kZXggOiBkZWZhdWx0SW5kZXgsXG4gICAgdGFiczogW10sXG4gICAgcGFuZWxzOiBbXVxuICB9KTtcbiAgbGV0IHNsb3QgPSAoMCwgaW1wb3J0X3JlYWN0MzgudXNlTWVtbykoKCkgPT4gKHsgc2VsZWN0ZWRJbmRleDogc3RhdGUyLnNlbGVjdGVkSW5kZXggfSksIFtzdGF0ZTIuc2VsZWN0ZWRJbmRleF0pO1xuICBsZXQgb25DaGFuZ2VSZWYgPSB1c2VMYXRlc3RWYWx1ZShvbkNoYW5nZSB8fCAoKCkgPT4ge1xuICB9KSk7XG4gIGxldCBzdGFibGVUYWJzUmVmID0gdXNlTGF0ZXN0VmFsdWUoc3RhdGUyLnRhYnMpO1xuICBsZXQgdGFic0RhdGEgPSAoMCwgaW1wb3J0X3JlYWN0MzgudXNlTWVtbykoKCkgPT4gKHsgb3JpZW50YXRpb24sIGFjdGl2YXRpb24sIC4uLnN0YXRlMiB9KSwgW29yaWVudGF0aW9uLCBhY3RpdmF0aW9uLCBzdGF0ZTJdKTtcbiAgbGV0IHJlYWxTZWxlY3RlZEluZGV4ID0gdXNlTGF0ZXN0VmFsdWUoaXNDb250cm9sbGVkID8gcHJvcHMuc2VsZWN0ZWRJbmRleCA6IHN0YXRlMi5zZWxlY3RlZEluZGV4KTtcbiAgbGV0IHRhYnNBY3Rpb25zID0gKDAsIGltcG9ydF9yZWFjdDM4LnVzZU1lbW8pKCgpID0+ICh7XG4gICAgcmVnaXN0ZXJUYWIodGFiKSB7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IDEgLyogUmVnaXN0ZXJUYWIgKi8sIHRhYiB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IDIgLyogVW5yZWdpc3RlclRhYiAqLywgdGFiIH0pO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJQYW5lbChwYW5lbCkge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAzIC8qIFJlZ2lzdGVyUGFuZWwgKi8sIHBhbmVsIH0pO1xuICAgICAgcmV0dXJuICgpID0+IGRpc3BhdGNoKHsgdHlwZTogNCAvKiBVbnJlZ2lzdGVyUGFuZWwgKi8sIHBhbmVsIH0pO1xuICAgIH0sXG4gICAgY2hhbmdlKGluZGV4KSB7XG4gICAgICBpZiAocmVhbFNlbGVjdGVkSW5kZXguY3VycmVudCAhPT0gaW5kZXgpIHtcbiAgICAgICAgb25DaGFuZ2VSZWYuY3VycmVudChpbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQ29udHJvbGxlZCkge1xuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IDAgLyogU2V0U2VsZWN0ZWRJbmRleCAqLywgaW5kZXggfSk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgW2Rpc3BhdGNoLCBpc0NvbnRyb2xsZWRdKTtcbiAgdXNlSXNvTW9ycGhpY0VmZmVjdCgoKSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAwIC8qIFNldFNlbGVjdGVkSW5kZXggKi8sIGluZGV4OiBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogZGVmYXVsdEluZGV4IH0pO1xuICB9LCBbc2VsZWN0ZWRJbmRleF0pO1xuICBsZXQgU1NSQ291bnRlciA9ICgwLCBpbXBvcnRfcmVhY3QzOC51c2VSZWYpKHsgdGFiczogW10sIHBhbmVsczogW10gfSk7XG4gIGxldCBvdXJQcm9wcyA9IHsgcmVmOiB0YWJzUmVmIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzguZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRhYnNTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFNTUkNvdW50ZXJcbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM4LmRlZmF1bHQuY3JlYXRlRWxlbWVudChUYWJzQWN0aW9uc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdGFic0FjdGlvbnNcbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM4LmRlZmF1bHQuY3JlYXRlRWxlbWVudChUYWJzRGF0YUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdGFic0RhdGFcbiAgfSwgdGFic0RhdGEudGFicy5sZW5ndGggPD0gMCAmJiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzguZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZvY3VzU2VudGluZWwsIHtcbiAgICBvbkZvY3VzOiAoKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjtcbiAgICAgIGZvciAobGV0IHRhYiBvZiBzdGFibGVUYWJzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKCgoX2EyID0gdGFiLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudGFiSW5kZXgpID09PSAwKSB7XG4gICAgICAgICAgKF9iID0gdGFiLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mb2N1cygpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSwgcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9UQUJTX1RBRyxcbiAgICBuYW1lOiBcIlRhYnNcIlxuICB9KSkpKTtcbn0pO1xudmFyIERFRkFVTFRfTElTVF9UQUcgPSBcImRpdlwiO1xudmFyIExpc3QgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIExpc3QyKHByb3BzLCByZWYpIHtcbiAgbGV0IHsgb3JpZW50YXRpb24sIHNlbGVjdGVkSW5kZXggfSA9IHVzZURhdGEyKFwiVGFiLkxpc3RcIik7XG4gIGxldCBsaXN0UmVmID0gdXNlU3luY1JlZnMocmVmKTtcbiAgbGV0IHNsb3QgPSB7IHNlbGVjdGVkSW5kZXggfTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0ge1xuICAgIHJlZjogbGlzdFJlZixcbiAgICByb2xlOiBcInRhYmxpc3RcIixcbiAgICBcImFyaWEtb3JpZW50YXRpb25cIjogb3JpZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfTElTVF9UQUcsXG4gICAgbmFtZTogXCJUYWJzLkxpc3RcIlxuICB9KTtcbn0pO1xudmFyIERFRkFVTFRfVEFCX1RBRyA9IFwiYnV0dG9uXCI7XG52YXIgVGFiUm9vdCA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gVGFiKHByb3BzLCByZWYpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIGxldCBpZDIgPSBgaGVhZGxlc3N1aS10YWJzLXRhYi0ke3VzZUlkKCl9YDtcbiAgbGV0IHsgb3JpZW50YXRpb24sIGFjdGl2YXRpb24sIHNlbGVjdGVkSW5kZXgsIHRhYnMsIHBhbmVscyB9ID0gdXNlRGF0YTIoXCJUYWJcIik7XG4gIGxldCBhY3Rpb25zID0gdXNlQWN0aW9uczIoXCJUYWJcIik7XG4gIGxldCBTU1JDb250ZXh0ID0gdXNlU1NSVGFic0NvdW50ZXIoXCJUYWJcIik7XG4gIGxldCBpbnRlcm5hbFRhYlJlZiA9ICgwLCBpbXBvcnRfcmVhY3QzOC51c2VSZWYpKG51bGwpO1xuICBsZXQgdGFiUmVmID0gdXNlU3luY1JlZnMoaW50ZXJuYWxUYWJSZWYsIHJlZik7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4gYWN0aW9ucy5yZWdpc3RlclRhYihpbnRlcm5hbFRhYlJlZiksIFthY3Rpb25zLCBpbnRlcm5hbFRhYlJlZl0pO1xuICBsZXQgbXlTU1JJbmRleCA9IFNTUkNvbnRleHQuY3VycmVudC50YWJzLmluZGV4T2YoaWQyKTtcbiAgaWYgKG15U1NSSW5kZXggPT09IC0xKVxuICAgIG15U1NSSW5kZXggPSBTU1JDb250ZXh0LmN1cnJlbnQudGFicy5wdXNoKGlkMikgLSAxO1xuICBsZXQgbXlJbmRleCA9IHRhYnMuaW5kZXhPZihpbnRlcm5hbFRhYlJlZik7XG4gIGlmIChteUluZGV4ID09PSAtMSlcbiAgICBteUluZGV4ID0gbXlTU1JJbmRleDtcbiAgbGV0IHNlbGVjdGVkID0gbXlJbmRleCA9PT0gc2VsZWN0ZWRJbmRleDtcbiAgbGV0IGhhbmRsZUtleURvd24gPSB1c2VFdmVudCgoZXZlbnQpID0+IHtcbiAgICBsZXQgbGlzdCA9IHRhYnMubWFwKCh0YWIpID0+IHRhYi5jdXJyZW50KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIgLyogU3BhY2UgKi8gfHwgZXZlbnQua2V5ID09PSBcIkVudGVyXCIgLyogRW50ZXIgKi8pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGFjdGlvbnMuY2hhbmdlKG15SW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIkhvbWVcIiAvKiBIb21lICovOlxuICAgICAgY2FzZSBcIlBhZ2VVcFwiIC8qIFBhZ2VVcCAqLzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmb2N1c0luKGxpc3QsIDEgLyogRmlyc3QgKi8pO1xuICAgICAgY2FzZSBcIkVuZFwiIC8qIEVuZCAqLzpcbiAgICAgIGNhc2UgXCJQYWdlRG93blwiIC8qIFBhZ2VEb3duICovOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZvY3VzSW4obGlzdCwgOCAvKiBMYXN0ICovKTtcbiAgICB9XG4gICAgaWYgKG1hdGNoKG9yaWVudGF0aW9uLCB7XG4gICAgICB2ZXJ0aWNhbCgpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd1VwXCIgLyogQXJyb3dVcCAqLylcbiAgICAgICAgICByZXR1cm4gZm9jdXNJbihsaXN0LCAyIC8qIFByZXZpb3VzICovIHwgMTYgLyogV3JhcEFyb3VuZCAqLyk7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dEb3duXCIgLyogQXJyb3dEb3duICovKVxuICAgICAgICAgIHJldHVybiBmb2N1c0luKGxpc3QsIDQgLyogTmV4dCAqLyB8IDE2IC8qIFdyYXBBcm91bmQgKi8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9LFxuICAgICAgaG9yaXpvbnRhbCgpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0xlZnRcIiAvKiBBcnJvd0xlZnQgKi8pXG4gICAgICAgICAgcmV0dXJuIGZvY3VzSW4obGlzdCwgMiAvKiBQcmV2aW91cyAqLyB8IDE2IC8qIFdyYXBBcm91bmQgKi8pO1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93UmlnaHRcIiAvKiBBcnJvd1JpZ2h0ICovKVxuICAgICAgICAgIHJldHVybiBmb2N1c0luKGxpc3QsIDQgLyogTmV4dCAqLyB8IDE2IC8qIFdyYXBBcm91bmQgKi8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBoYW5kbGVGb2N1cyA9IHVzZUV2ZW50KCgpID0+IHtcbiAgICB2YXIgX2EzO1xuICAgIChfYTMgPSBpbnRlcm5hbFRhYlJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmZvY3VzKCk7XG4gIH0pO1xuICBsZXQgcmVhZHkgPSAoMCwgaW1wb3J0X3JlYWN0MzgudXNlUmVmKShmYWxzZSk7XG4gIGxldCBoYW5kbGVTZWxlY3Rpb24gPSB1c2VFdmVudCgoKSA9PiB7XG4gICAgdmFyIF9hMztcbiAgICBpZiAocmVhZHkuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICByZWFkeS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAoX2EzID0gaW50ZXJuYWxUYWJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5mb2N1cygpO1xuICAgIGFjdGlvbnMuY2hhbmdlKG15SW5kZXgpO1xuICAgIG1pY3JvVGFzaygoKSA9PiB7XG4gICAgICByZWFkeS5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xuICBsZXQgaGFuZGxlTW91c2VEb3duID0gdXNlRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDM4LnVzZU1lbW8pKCgpID0+ICh7IHNlbGVjdGVkIH0pLCBbc2VsZWN0ZWRdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSBwcm9wcztcbiAgbGV0IG91clByb3BzID0ge1xuICAgIHJlZjogdGFiUmVmLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbkZvY3VzOiBhY3RpdmF0aW9uID09PSBcIm1hbnVhbFwiID8gaGFuZGxlRm9jdXMgOiBoYW5kbGVTZWxlY3Rpb24sXG4gICAgb25Nb3VzZURvd246IGhhbmRsZU1vdXNlRG93bixcbiAgICBvbkNsaWNrOiBoYW5kbGVTZWxlY3Rpb24sXG4gICAgaWQ6IGlkMixcbiAgICByb2xlOiBcInRhYlwiLFxuICAgIHR5cGU6IHVzZVJlc29sdmVCdXR0b25UeXBlKHByb3BzLCBpbnRlcm5hbFRhYlJlZiksXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IChfYiA9IChfYTIgPSBwYW5lbHNbbXlJbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmlkLFxuICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBzZWxlY3RlZCxcbiAgICB0YWJJbmRleDogc2VsZWN0ZWQgPyAwIDogLTFcbiAgfTtcbiAgcmV0dXJuIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfVEFCX1RBRyxcbiAgICBuYW1lOiBcIlRhYnMuVGFiXCJcbiAgfSk7XG59KTtcbnZhciBERUZBVUxUX1BBTkVMU19UQUcgPSBcImRpdlwiO1xudmFyIFBhbmVscyA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gUGFuZWxzMihwcm9wcywgcmVmKSB7XG4gIGxldCB7IHNlbGVjdGVkSW5kZXggfSA9IHVzZURhdGEyKFwiVGFiLlBhbmVsc1wiKTtcbiAgbGV0IHBhbmVsc1JlZiA9IHVzZVN5bmNSZWZzKHJlZik7XG4gIGxldCBzbG90ID0gKDAsIGltcG9ydF9yZWFjdDM4LnVzZU1lbW8pKCgpID0+ICh7IHNlbGVjdGVkSW5kZXggfSksIFtzZWxlY3RlZEluZGV4XSk7XG4gIGxldCB0aGVpclByb3BzID0gcHJvcHM7XG4gIGxldCBvdXJQcm9wcyA9IHsgcmVmOiBwYW5lbHNSZWYgfTtcbiAgcmV0dXJuIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBzbG90LFxuICAgIGRlZmF1bHRUYWc6IERFRkFVTFRfUEFORUxTX1RBRyxcbiAgICBuYW1lOiBcIlRhYnMuUGFuZWxzXCJcbiAgfSk7XG59KTtcbnZhciBERUZBVUxUX1BBTkVMX1RBRzQgPSBcImRpdlwiO1xudmFyIFBhbmVsUmVuZGVyRmVhdHVyZXMzID0gMSAvKiBSZW5kZXJTdHJhdGVneSAqLyB8IDIgLyogU3RhdGljICovO1xudmFyIFBhbmVsNyA9IGZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gUGFuZWw4KHByb3BzLCByZWYpIHtcbiAgdmFyIF9hMiwgX2IsIF9jLCBfZDtcbiAgbGV0IHsgc2VsZWN0ZWRJbmRleCwgdGFicywgcGFuZWxzIH0gPSB1c2VEYXRhMihcIlRhYi5QYW5lbFwiKTtcbiAgbGV0IGFjdGlvbnMgPSB1c2VBY3Rpb25zMihcIlRhYi5QYW5lbFwiKTtcbiAgbGV0IFNTUkNvbnRleHQgPSB1c2VTU1JUYWJzQ291bnRlcihcIlRhYi5QYW5lbFwiKTtcbiAgbGV0IGlkMiA9IGBoZWFkbGVzc3VpLXRhYnMtcGFuZWwtJHt1c2VJZCgpfWA7XG4gIGxldCBpbnRlcm5hbFBhbmVsUmVmID0gKDAsIGltcG9ydF9yZWFjdDM4LnVzZVJlZikobnVsbCk7XG4gIGxldCBwYW5lbFJlZiA9IHVzZVN5bmNSZWZzKGludGVybmFsUGFuZWxSZWYsIHJlZik7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4gYWN0aW9ucy5yZWdpc3RlclBhbmVsKGludGVybmFsUGFuZWxSZWYpLCBbYWN0aW9ucywgaW50ZXJuYWxQYW5lbFJlZl0pO1xuICBsZXQgbXlTU1JJbmRleCA9IFNTUkNvbnRleHQuY3VycmVudC5wYW5lbHMuaW5kZXhPZihpZDIpO1xuICBpZiAobXlTU1JJbmRleCA9PT0gLTEpXG4gICAgbXlTU1JJbmRleCA9IFNTUkNvbnRleHQuY3VycmVudC5wYW5lbHMucHVzaChpZDIpIC0gMTtcbiAgbGV0IG15SW5kZXggPSBwYW5lbHMuaW5kZXhPZihpbnRlcm5hbFBhbmVsUmVmKTtcbiAgaWYgKG15SW5kZXggPT09IC0xKVxuICAgIG15SW5kZXggPSBteVNTUkluZGV4O1xuICBsZXQgc2VsZWN0ZWQgPSBteUluZGV4ID09PSBzZWxlY3RlZEluZGV4O1xuICBsZXQgc2xvdCA9ICgwLCBpbXBvcnRfcmVhY3QzOC51c2VNZW1vKSgoKSA9PiAoeyBzZWxlY3RlZCB9KSwgW3NlbGVjdGVkXSk7XG4gIGxldCB0aGVpclByb3BzID0gcHJvcHM7XG4gIGxldCBvdXJQcm9wcyA9IHtcbiAgICByZWY6IHBhbmVsUmVmLFxuICAgIGlkOiBpZDIsXG4gICAgcm9sZTogXCJ0YWJwYW5lbFwiLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IChfYiA9IChfYTIgPSB0YWJzW215SW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pZCxcbiAgICB0YWJJbmRleDogc2VsZWN0ZWQgPyAwIDogLTFcbiAgfTtcbiAgaWYgKCFzZWxlY3RlZCAmJiAoKF9jID0gcHJvcHMudW5tb3VudCkgIT0gbnVsbCA/IF9jIDogdHJ1ZSkgJiYgISgoX2QgPSBwcm9wcy5zdGF0aWMpICE9IG51bGwgPyBfZCA6IGZhbHNlKSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzguZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhpZGRlbiwge1xuICAgICAgYXM6IFwic3BhblwiLFxuICAgICAgLi4ub3VyUHJvcHNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVuZGVyKHtcbiAgICBvdXJQcm9wcyxcbiAgICB0aGVpclByb3BzLFxuICAgIHNsb3QsXG4gICAgZGVmYXVsdFRhZzogREVGQVVMVF9QQU5FTF9UQUc0LFxuICAgIGZlYXR1cmVzOiBQYW5lbFJlbmRlckZlYXR1cmVzMyxcbiAgICB2aXNpYmxlOiBzZWxlY3RlZCxcbiAgICBuYW1lOiBcIlRhYnMuUGFuZWxcIlxuICB9KTtcbn0pO1xudmFyIFRhYjIgPSBPYmplY3QuYXNzaWduKFRhYlJvb3QsIHsgR3JvdXA6IFRhYnMsIExpc3QsIFBhbmVscywgUGFuZWw6IFBhbmVsNyB9KTtcblxuLy8gc3JjL2NvbXBvbmVudHMvdHJhbnNpdGlvbnMvdHJhbnNpdGlvbi50c3hcbnZhciBpbXBvcnRfcmVhY3QzOSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpLCAxKTtcblxuLy8gc3JjL3V0aWxzL29uY2UudHNcbmZ1bmN0aW9uIG9uY2UoY2IpIHtcbiAgbGV0IHN0YXRlMiA9IHsgY2FsbGVkOiBmYWxzZSB9O1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoc3RhdGUyLmNhbGxlZClcbiAgICAgIHJldHVybjtcbiAgICBzdGF0ZTIuY2FsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2IoLi4uYXJncyk7XG4gIH07XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL3RyYW5zaXRpb25zL3V0aWxzL3RyYW5zaXRpb24udHNcbmZ1bmN0aW9uIGFkZENsYXNzZXMobm9kZSwgLi4uY2xhc3Nlcykge1xuICBub2RlICYmIGNsYXNzZXMubGVuZ3RoID4gMCAmJiBub2RlLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XG59XG5mdW5jdGlvbiByZW1vdmVDbGFzc2VzKG5vZGUsIC4uLmNsYXNzZXMpIHtcbiAgbm9kZSAmJiBjbGFzc2VzLmxlbmd0aCA+IDAgJiYgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXMpO1xufVxuZnVuY3Rpb24gd2FpdEZvclRyYW5zaXRpb24obm9kZSwgZG9uZSkge1xuICBsZXQgZCA9IGRpc3Bvc2FibGVzKCk7XG4gIGlmICghbm9kZSlcbiAgICByZXR1cm4gZC5kaXNwb3NlO1xuICBsZXQgeyB0cmFuc2l0aW9uRHVyYXRpb24sIHRyYW5zaXRpb25EZWxheSB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgbGV0IFtkdXJhdGlvbk1zLCBkZWxheU1zXSA9IFt0cmFuc2l0aW9uRHVyYXRpb24sIHRyYW5zaXRpb25EZWxheV0ubWFwKCh2YWx1ZSkgPT4ge1xuICAgIGxldCBbcmVzb2x2ZWRWYWx1ZSA9IDBdID0gdmFsdWUuc3BsaXQoXCIsXCIpLmZpbHRlcihCb29sZWFuKS5tYXAoKHYpID0+IHYuaW5jbHVkZXMoXCJtc1wiKSA/IHBhcnNlRmxvYXQodikgOiBwYXJzZUZsb2F0KHYpICogMWUzKS5zb3J0KChhLCB6KSA9PiB6IC0gYSk7XG4gICAgcmV0dXJuIHJlc29sdmVkVmFsdWU7XG4gIH0pO1xuICBsZXQgdG90YWxEdXJhdGlvbiA9IGR1cmF0aW9uTXMgKyBkZWxheU1zO1xuICBpZiAodG90YWxEdXJhdGlvbiAhPT0gMCkge1xuICAgIGxldCBsaXN0ZW5lcnMgPSBbXTtcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGQuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRvbmUoXCJlbmRlZFwiIC8qIEVuZGVkICovKTtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZSgwKS5mb3JFYWNoKChkaXNwb3NlKSA9PiBkaXNwb3NlKCkpO1xuICAgICAgfSwgdG90YWxEdXJhdGlvbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChkLmFkZEV2ZW50TGlzdGVuZXIobm9kZSwgXCJ0cmFuc2l0aW9ucnVuXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBldmVudC5jdXJyZW50VGFyZ2V0KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZSgwKS5mb3JFYWNoKChkaXNwb3NlKSA9PiBkaXNwb3NlKCkpO1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChkLmFkZEV2ZW50TGlzdGVuZXIobm9kZSwgXCJ0cmFuc2l0aW9uZW5kXCIsIChldmVudDIpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQyLnRhcmdldCAhPT0gZXZlbnQyLmN1cnJlbnRUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZG9uZShcImVuZGVkXCIgLyogRW5kZWQgKi8pO1xuICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoMCkuZm9yRWFjaCgoZGlzcG9zZSkgPT4gZGlzcG9zZSgpKTtcbiAgICAgICAgfSksIGQuYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBcInRyYW5zaXRpb25jYW5jZWxcIiwgKGV2ZW50MikgPT4ge1xuICAgICAgICAgIGlmIChldmVudDIudGFyZ2V0ICE9PSBldmVudDIuY3VycmVudFRhcmdldClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkb25lKFwiY2FuY2VsbGVkXCIgLyogQ2FuY2VsbGVkICovKTtcbiAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKDApLmZvckVhY2goKGRpc3Bvc2UpID0+IGRpc3Bvc2UoKSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9uZShcImVuZGVkXCIgLyogRW5kZWQgKi8pO1xuICB9XG4gIGQuYWRkKCgpID0+IGRvbmUoXCJjYW5jZWxsZWRcIiAvKiBDYW5jZWxsZWQgKi8pKTtcbiAgcmV0dXJuIGQuZGlzcG9zZTtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb24obm9kZSwgY2xhc3Nlcywgc2hvdywgZG9uZSkge1xuICBsZXQgZGlyZWN0aW9uID0gc2hvdyA/IFwiZW50ZXJcIiA6IFwibGVhdmVcIjtcbiAgbGV0IGQgPSBkaXNwb3NhYmxlcygpO1xuICBsZXQgX2RvbmUgPSBkb25lICE9PSB2b2lkIDAgPyBvbmNlKGRvbmUpIDogKCkgPT4ge1xuICB9O1xuICBpZiAoZGlyZWN0aW9uID09PSBcImVudGVyXCIpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShcImhpZGRlblwiKTtcbiAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICB9XG4gIGxldCBiYXNlID0gbWF0Y2goZGlyZWN0aW9uLCB7XG4gICAgZW50ZXI6ICgpID0+IGNsYXNzZXMuZW50ZXIsXG4gICAgbGVhdmU6ICgpID0+IGNsYXNzZXMubGVhdmVcbiAgfSk7XG4gIGxldCB0byA9IG1hdGNoKGRpcmVjdGlvbiwge1xuICAgIGVudGVyOiAoKSA9PiBjbGFzc2VzLmVudGVyVG8sXG4gICAgbGVhdmU6ICgpID0+IGNsYXNzZXMubGVhdmVUb1xuICB9KTtcbiAgbGV0IGZyb20gPSBtYXRjaChkaXJlY3Rpb24sIHtcbiAgICBlbnRlcjogKCkgPT4gY2xhc3Nlcy5lbnRlckZyb20sXG4gICAgbGVhdmU6ICgpID0+IGNsYXNzZXMubGVhdmVGcm9tXG4gIH0pO1xuICByZW1vdmVDbGFzc2VzKG5vZGUsIC4uLmNsYXNzZXMuZW50ZXIsIC4uLmNsYXNzZXMuZW50ZXJUbywgLi4uY2xhc3Nlcy5lbnRlckZyb20sIC4uLmNsYXNzZXMubGVhdmUsIC4uLmNsYXNzZXMubGVhdmVGcm9tLCAuLi5jbGFzc2VzLmxlYXZlVG8sIC4uLmNsYXNzZXMuZW50ZXJlZCk7XG4gIGFkZENsYXNzZXMobm9kZSwgLi4uYmFzZSwgLi4uZnJvbSk7XG4gIGQubmV4dEZyYW1lKCgpID0+IHtcbiAgICByZW1vdmVDbGFzc2VzKG5vZGUsIC4uLmZyb20pO1xuICAgIGFkZENsYXNzZXMobm9kZSwgLi4udG8pO1xuICAgIHdhaXRGb3JUcmFuc2l0aW9uKG5vZGUsIChyZWFzb24pID0+IHtcbiAgICAgIGlmIChyZWFzb24gPT09IFwiZW5kZWRcIiAvKiBFbmRlZCAqLykge1xuICAgICAgICByZW1vdmVDbGFzc2VzKG5vZGUsIC4uLmJhc2UpO1xuICAgICAgICBhZGRDbGFzc2VzKG5vZGUsIC4uLmNsYXNzZXMuZW50ZXJlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2RvbmUocmVhc29uKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBkLmRpc3Bvc2U7XG59XG5cbi8vIHNyYy9ob29rcy91c2UtdHJhbnNpdGlvbi50c1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbih7IGNvbnRhaW5lciwgZGlyZWN0aW9uLCBjbGFzc2VzLCBvblN0YXJ0LCBvblN0b3AgfSkge1xuICBsZXQgbW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICBsZXQgZCA9IHVzZURpc3Bvc2FibGVzKCk7XG4gIGxldCBsYXRlc3REaXJlY3Rpb24gPSB1c2VMYXRlc3RWYWx1ZShkaXJlY3Rpb24pO1xuICB1c2VJc29Nb3JwaGljRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZGQgPSBkaXNwb3NhYmxlcygpO1xuICAgIGQuYWRkKGRkLmRpc3Bvc2UpO1xuICAgIGxldCBub2RlID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChsYXRlc3REaXJlY3Rpb24uY3VycmVudCA9PT0gXCJpZGxlXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFtb3VudGVkLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgZGQuZGlzcG9zZSgpO1xuICAgIG9uU3RhcnQuY3VycmVudChsYXRlc3REaXJlY3Rpb24uY3VycmVudCk7XG4gICAgZGQuYWRkKHRyYW5zaXRpb24obm9kZSwgY2xhc3Nlcy5jdXJyZW50LCBsYXRlc3REaXJlY3Rpb24uY3VycmVudCA9PT0gXCJlbnRlclwiLCAocmVhc29uKSA9PiB7XG4gICAgICBkZC5kaXNwb3NlKCk7XG4gICAgICBtYXRjaChyZWFzb24sIHtcbiAgICAgICAgW1wiZW5kZWRcIiAvKiBFbmRlZCAqL10oKSB7XG4gICAgICAgICAgb25TdG9wLmN1cnJlbnQobGF0ZXN0RGlyZWN0aW9uLmN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBbXCJjYW5jZWxsZWRcIiAvKiBDYW5jZWxsZWQgKi9dOiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZGQuZGlzcG9zZTtcbiAgfSwgW2RpcmVjdGlvbl0pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy90cmFuc2l0aW9uLnRzeFxuZnVuY3Rpb24gc3BsaXRDbGFzc2VzKGNsYXNzZXMgPSBcIlwiKSB7XG4gIHJldHVybiBjbGFzc2VzLnNwbGl0KFwiIFwiKS5maWx0ZXIoKGNsYXNzTmFtZSkgPT4gY2xhc3NOYW1lLnRyaW0oKS5sZW5ndGggPiAxKTtcbn1cbnZhciBUcmFuc2l0aW9uQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzOS5jcmVhdGVDb250ZXh0KShudWxsKTtcblRyYW5zaXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJUcmFuc2l0aW9uQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbkNvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDM5LnVzZUNvbnRleHQpKFRyYW5zaXRpb25Db250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIDxUcmFuc2l0aW9uLkNoaWxkIC8+IGlzIHVzZWQgYnV0IGl0IGlzIG1pc3NpbmcgYSBwYXJlbnQgPFRyYW5zaXRpb24gLz4gb3IgPFRyYW5zaXRpb24uUm9vdCAvPi5cIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB1c2VQYXJlbnROZXN0aW5nKCkge1xuICBsZXQgY29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzOS51c2VDb250ZXh0KShOZXN0aW5nQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSA8VHJhbnNpdGlvbi5DaGlsZCAvPiBpcyB1c2VkIGJ1dCBpdCBpcyBtaXNzaW5nIGEgcGFyZW50IDxUcmFuc2l0aW9uIC8+IG9yIDxUcmFuc2l0aW9uLlJvb3QgLz4uXCIpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIE5lc3RpbmdDb250ZXh0ID0gKDAsIGltcG9ydF9yZWFjdDM5LmNyZWF0ZUNvbnRleHQpKG51bGwpO1xuTmVzdGluZ0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5lc3RpbmdDb250ZXh0XCI7XG5mdW5jdGlvbiBoYXNDaGlsZHJlbihiYWcpIHtcbiAgaWYgKFwiY2hpbGRyZW5cIiBpbiBiYWcpXG4gICAgcmV0dXJuIGhhc0NoaWxkcmVuKGJhZy5jaGlsZHJlbik7XG4gIHJldHVybiBiYWcuY3VycmVudC5maWx0ZXIoKHsgZWwgfSkgPT4gZWwuY3VycmVudCAhPT0gbnVsbCkuZmlsdGVyKCh7IHN0YXRlOiBzdGF0ZTIgfSkgPT4gc3RhdGUyID09PSBcInZpc2libGVcIiAvKiBWaXNpYmxlICovKS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gdXNlTmVzdGluZyhkb25lLCBwYXJlbnQpIHtcbiAgbGV0IGRvbmVSZWYgPSB1c2VMYXRlc3RWYWx1ZShkb25lKTtcbiAgbGV0IHRyYW5zaXRpb25hYmxlQ2hpbGRyZW4gPSAoMCwgaW1wb3J0X3JlYWN0MzkudXNlUmVmKShbXSk7XG4gIGxldCBtb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gIGxldCBkID0gdXNlRGlzcG9zYWJsZXMoKTtcbiAgbGV0IHVucmVnaXN0ZXIgPSB1c2VFdmVudCgoY29udGFpbmVyLCBzdHJhdGVneSA9IDEgLyogSGlkZGVuICovKSA9PiB7XG4gICAgbGV0IGlkeCA9IHRyYW5zaXRpb25hYmxlQ2hpbGRyZW4uY3VycmVudC5maW5kSW5kZXgoKHsgZWwgfSkgPT4gZWwgPT09IGNvbnRhaW5lcik7XG4gICAgaWYgKGlkeCA9PT0gLTEpXG4gICAgICByZXR1cm47XG4gICAgbWF0Y2goc3RyYXRlZ3ksIHtcbiAgICAgIFswIC8qIFVubW91bnQgKi9dKCkge1xuICAgICAgICB0cmFuc2l0aW9uYWJsZUNoaWxkcmVuLmN1cnJlbnQuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9LFxuICAgICAgWzEgLyogSGlkZGVuICovXSgpIHtcbiAgICAgICAgdHJhbnNpdGlvbmFibGVDaGlsZHJlbi5jdXJyZW50W2lkeF0uc3RhdGUgPSBcImhpZGRlblwiIC8qIEhpZGRlbiAqLztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkLm1pY3JvVGFzaygoKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKCFoYXNDaGlsZHJlbih0cmFuc2l0aW9uYWJsZUNoaWxkcmVuKSAmJiBtb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgKF9hMiA9IGRvbmVSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKGRvbmVSZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgbGV0IHJlZ2lzdGVyID0gdXNlRXZlbnQoKGNvbnRhaW5lcikgPT4ge1xuICAgIGxldCBjaGlsZCA9IHRyYW5zaXRpb25hYmxlQ2hpbGRyZW4uY3VycmVudC5maW5kKCh7IGVsIH0pID0+IGVsID09PSBjb250YWluZXIpO1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHRyYW5zaXRpb25hYmxlQ2hpbGRyZW4uY3VycmVudC5wdXNoKHsgZWw6IGNvbnRhaW5lciwgc3RhdGU6IFwidmlzaWJsZVwiIC8qIFZpc2libGUgKi8gfSk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC5zdGF0ZSAhPT0gXCJ2aXNpYmxlXCIgLyogVmlzaWJsZSAqLykge1xuICAgICAgY2hpbGQuc3RhdGUgPSBcInZpc2libGVcIiAvKiBWaXNpYmxlICovO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3Rlcihjb250YWluZXIsIDAgLyogVW5tb3VudCAqLyk7XG4gIH0pO1xuICBsZXQgdG9kb3MgPSAoMCwgaW1wb3J0X3JlYWN0MzkudXNlUmVmKShbXSk7XG4gIGxldCB3YWl0ID0gKDAsIGltcG9ydF9yZWFjdDM5LnVzZVJlZikoUHJvbWlzZS5yZXNvbHZlKCkpO1xuICBsZXQgY2hhaW5zID0gKDAsIGltcG9ydF9yZWFjdDM5LnVzZVJlZikoe1xuICAgIGVudGVyOiBbXSxcbiAgICBsZWF2ZTogW10sXG4gICAgaWRsZTogW11cbiAgfSk7XG4gIGxldCBvblN0YXJ0ID0gdXNlRXZlbnQoKGNvbnRhaW5lciwgZGlyZWN0aW9uLCBjYikgPT4ge1xuICAgIHRvZG9zLmN1cnJlbnQuc3BsaWNlKDApO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5jaGFpbnMuY3VycmVudFtkaXJlY3Rpb25dID0gcGFyZW50LmNoYWlucy5jdXJyZW50W2RpcmVjdGlvbl0uZmlsdGVyKChbY29udGFpbmVySW5QYXJlbnRdKSA9PiBjb250YWluZXJJblBhcmVudCAhPT0gY29udGFpbmVyKTtcbiAgICB9XG4gICAgcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQuY2hhaW5zLmN1cnJlbnRbZGlyZWN0aW9uXS5wdXNoKFtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRvZG9zLmN1cnJlbnQucHVzaChyZXNvbHZlKTtcbiAgICAgIH0pXG4gICAgXSk7XG4gICAgcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQuY2hhaW5zLmN1cnJlbnRbZGlyZWN0aW9uXS5wdXNoKFtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIFByb21pc2UuYWxsKGNoYWlucy5jdXJyZW50W2RpcmVjdGlvbl0ubWFwKChbX2NvbnRhaW5lciwgcHJvbWlzZV0pID0+IHByb21pc2UpKS50aGVuKCgpID0+IHJlc29sdmUoKSk7XG4gICAgICB9KVxuICAgIF0pO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiZW50ZXJcIikge1xuICAgICAgd2FpdC5jdXJyZW50ID0gd2FpdC5jdXJyZW50LnRoZW4oKCkgPT4gcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQud2FpdC5jdXJyZW50KS50aGVuKCgpID0+IGNiKGRpcmVjdGlvbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihkaXJlY3Rpb24pO1xuICAgIH1cbiAgfSk7XG4gIGxldCBvblN0b3AgPSB1c2VFdmVudCgoX2NvbnRhaW5lciwgZGlyZWN0aW9uLCBjYikgPT4ge1xuICAgIFByb21pc2UuYWxsKGNoYWlucy5jdXJyZW50W2RpcmVjdGlvbl0uc3BsaWNlKDApLm1hcCgoW19jb250YWluZXIyLCBwcm9taXNlXSkgPT4gcHJvbWlzZSkpLnRoZW4oKCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIChfYTIgPSB0b2Rvcy5jdXJyZW50LnNoaWZ0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIoKTtcbiAgICB9KS50aGVuKCgpID0+IGNiKGRpcmVjdGlvbikpO1xuICB9KTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfcmVhY3QzOS51c2VNZW1vKSgoKSA9PiAoe1xuICAgIGNoaWxkcmVuOiB0cmFuc2l0aW9uYWJsZUNoaWxkcmVuLFxuICAgIHJlZ2lzdGVyLFxuICAgIHVucmVnaXN0ZXIsXG4gICAgb25TdGFydCxcbiAgICBvblN0b3AsXG4gICAgd2FpdCxcbiAgICBjaGFpbnNcbiAgfSksIFtyZWdpc3RlciwgdW5yZWdpc3RlciwgdHJhbnNpdGlvbmFibGVDaGlsZHJlbiwgb25TdGFydCwgb25TdG9wLCBjaGFpbnMsIHdhaXRdKTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG52YXIgZXZlbnROYW1lcyA9IFtcImJlZm9yZUVudGVyXCIsIFwiYWZ0ZXJFbnRlclwiLCBcImJlZm9yZUxlYXZlXCIsIFwiYWZ0ZXJMZWF2ZVwiXTtcbmZ1bmN0aW9uIGVuc3VyZUV2ZW50SG9va3NFeGlzdChldmVudHMpIHtcbiAgdmFyIF9hMjtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGxldCBuYW1lIG9mIGV2ZW50TmFtZXMpIHtcbiAgICByZXN1bHRbbmFtZV0gPSAoX2EyID0gZXZlbnRzW25hbWVdKSAhPSBudWxsID8gX2EyIDogbm9vcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlRXZlbnRzKGV2ZW50cykge1xuICBsZXQgZXZlbnRzUmVmID0gKDAsIGltcG9ydF9yZWFjdDM5LnVzZVJlZikoZW5zdXJlRXZlbnRIb29rc0V4aXN0KGV2ZW50cykpO1xuICAoMCwgaW1wb3J0X3JlYWN0MzkudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgZXZlbnRzUmVmLmN1cnJlbnQgPSBlbnN1cmVFdmVudEhvb2tzRXhpc3QoZXZlbnRzKTtcbiAgfSwgW2V2ZW50c10pO1xuICByZXR1cm4gZXZlbnRzUmVmO1xufVxudmFyIERFRkFVTFRfVFJBTlNJVElPTl9DSElMRF9UQUcgPSBcImRpdlwiO1xudmFyIFRyYW5zaXRpb25DaGlsZFJlbmRlckZlYXR1cmVzID0gMSAvKiBSZW5kZXJTdHJhdGVneSAqLztcbnZhciBUcmFuc2l0aW9uQ2hpbGQgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIFRyYW5zaXRpb25DaGlsZDIocHJvcHMsIHJlZikge1xuICBsZXQge1xuICAgIGJlZm9yZUVudGVyLFxuICAgIGFmdGVyRW50ZXIsXG4gICAgYmVmb3JlTGVhdmUsXG4gICAgYWZ0ZXJMZWF2ZSxcbiAgICBlbnRlcixcbiAgICBlbnRlckZyb20sXG4gICAgZW50ZXJUbyxcbiAgICBlbnRlcmVkLFxuICAgIGxlYXZlLFxuICAgIGxlYXZlRnJvbSxcbiAgICBsZWF2ZVRvLFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICBsZXQgY29udGFpbmVyID0gKDAsIGltcG9ydF9yZWFjdDM5LnVzZVJlZikobnVsbCk7XG4gIGxldCB0cmFuc2l0aW9uUmVmID0gdXNlU3luY1JlZnMoY29udGFpbmVyLCByZWYpO1xuICBsZXQgc3RyYXRlZ3kgPSByZXN0LnVubW91bnQgPyAwIC8qIFVubW91bnQgKi8gOiAxIC8qIEhpZGRlbiAqLztcbiAgbGV0IHsgc2hvdywgYXBwZWFyLCBpbml0aWFsIH0gPSB1c2VUcmFuc2l0aW9uQ29udGV4dCgpO1xuICBsZXQgW3N0YXRlMiwgc2V0U3RhdGVdID0gKDAsIGltcG9ydF9yZWFjdDM5LnVzZVN0YXRlKShzaG93ID8gXCJ2aXNpYmxlXCIgLyogVmlzaWJsZSAqLyA6IFwiaGlkZGVuXCIgLyogSGlkZGVuICovKTtcbiAgbGV0IHBhcmVudE5lc3RpbmcgPSB1c2VQYXJlbnROZXN0aW5nKCk7XG4gIGxldCB7IHJlZ2lzdGVyLCB1bnJlZ2lzdGVyIH0gPSBwYXJlbnROZXN0aW5nO1xuICBsZXQgcHJldlNob3cgPSAoMCwgaW1wb3J0X3JlYWN0MzkudXNlUmVmKShudWxsKTtcbiAgKDAsIGltcG9ydF9yZWFjdDM5LnVzZUVmZmVjdCkoKCkgPT4gcmVnaXN0ZXIoY29udGFpbmVyKSwgW3JlZ2lzdGVyLCBjb250YWluZXJdKTtcbiAgKDAsIGltcG9ydF9yZWFjdDM5LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmIChzdHJhdGVneSAhPT0gMSAvKiBIaWRkZW4gKi8pXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFjb250YWluZXIuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc2hvdyAmJiBzdGF0ZTIgIT09IFwidmlzaWJsZVwiIC8qIFZpc2libGUgKi8pIHtcbiAgICAgIHNldFN0YXRlKFwidmlzaWJsZVwiIC8qIFZpc2libGUgKi8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2goc3RhdGUyLCB7XG4gICAgICBbXCJoaWRkZW5cIiAvKiBIaWRkZW4gKi9dOiAoKSA9PiB1bnJlZ2lzdGVyKGNvbnRhaW5lciksXG4gICAgICBbXCJ2aXNpYmxlXCIgLyogVmlzaWJsZSAqL106ICgpID0+IHJlZ2lzdGVyKGNvbnRhaW5lcilcbiAgICB9KTtcbiAgfSwgW3N0YXRlMiwgY29udGFpbmVyLCByZWdpc3RlciwgdW5yZWdpc3Rlciwgc2hvdywgc3RyYXRlZ3ldKTtcbiAgbGV0IGNsYXNzZXMgPSB1c2VMYXRlc3RWYWx1ZSh7XG4gICAgZW50ZXI6IHNwbGl0Q2xhc3NlcyhlbnRlciksXG4gICAgZW50ZXJGcm9tOiBzcGxpdENsYXNzZXMoZW50ZXJGcm9tKSxcbiAgICBlbnRlclRvOiBzcGxpdENsYXNzZXMoZW50ZXJUbyksXG4gICAgZW50ZXJlZDogc3BsaXRDbGFzc2VzKGVudGVyZWQpLFxuICAgIGxlYXZlOiBzcGxpdENsYXNzZXMobGVhdmUpLFxuICAgIGxlYXZlRnJvbTogc3BsaXRDbGFzc2VzKGxlYXZlRnJvbSksXG4gICAgbGVhdmVUbzogc3BsaXRDbGFzc2VzKGxlYXZlVG8pXG4gIH0pO1xuICBsZXQgZXZlbnRzID0gdXNlRXZlbnRzKHtcbiAgICBiZWZvcmVFbnRlcixcbiAgICBhZnRlckVudGVyLFxuICAgIGJlZm9yZUxlYXZlLFxuICAgIGFmdGVyTGVhdmVcbiAgfSk7XG4gIGxldCByZWFkeSA9IHVzZVNlcnZlckhhbmRvZmZDb21wbGV0ZSgpO1xuICAoMCwgaW1wb3J0X3JlYWN0MzkudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKHJlYWR5ICYmIHN0YXRlMiA9PT0gXCJ2aXNpYmxlXCIgLyogVmlzaWJsZSAqLyAmJiBjb250YWluZXIuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIHlvdSBmb3JnZXQgdG8gcGFzc3Rocm91Z2ggdGhlIGByZWZgIHRvIHRoZSBhY3R1YWwgRE9NIG5vZGU/XCIpO1xuICAgIH1cbiAgfSwgW2NvbnRhaW5lciwgc3RhdGUyLCByZWFkeV0pO1xuICBsZXQgc2tpcCA9IGluaXRpYWwgJiYgIWFwcGVhcjtcbiAgbGV0IHRyYW5zaXRpb25EaXJlY3Rpb24gPSAoKCkgPT4ge1xuICAgIGlmICghcmVhZHkpXG4gICAgICByZXR1cm4gXCJpZGxlXCI7XG4gICAgaWYgKHNraXApXG4gICAgICByZXR1cm4gXCJpZGxlXCI7XG4gICAgaWYgKHByZXZTaG93LmN1cnJlbnQgPT09IHNob3cpXG4gICAgICByZXR1cm4gXCJpZGxlXCI7XG4gICAgcmV0dXJuIHNob3cgPyBcImVudGVyXCIgOiBcImxlYXZlXCI7XG4gIH0pKCk7XG4gIGxldCBiZWZvcmVFdmVudCA9IHVzZUV2ZW50KChkaXJlY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2goZGlyZWN0aW9uLCB7XG4gICAgICBlbnRlcjogKCkgPT4gZXZlbnRzLmN1cnJlbnQuYmVmb3JlRW50ZXIoKSxcbiAgICAgIGxlYXZlOiAoKSA9PiBldmVudHMuY3VycmVudC5iZWZvcmVMZWF2ZSgpLFxuICAgICAgaWRsZTogKCkgPT4ge1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgbGV0IGFmdGVyRXZlbnQgPSB1c2VFdmVudCgoZGlyZWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoKGRpcmVjdGlvbiwge1xuICAgICAgZW50ZXI6ICgpID0+IGV2ZW50cy5jdXJyZW50LmFmdGVyRW50ZXIoKSxcbiAgICAgIGxlYXZlOiAoKSA9PiBldmVudHMuY3VycmVudC5hZnRlckxlYXZlKCksXG4gICAgICBpZGxlOiAoKSA9PiB7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBsZXQgbmVzdGluZyA9IHVzZU5lc3RpbmcoKCkgPT4ge1xuICAgIHNldFN0YXRlKFwiaGlkZGVuXCIgLyogSGlkZGVuICovKTtcbiAgICB1bnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gIH0sIHBhcmVudE5lc3RpbmcpO1xuICB1c2VUcmFuc2l0aW9uKHtcbiAgICBjb250YWluZXIsXG4gICAgY2xhc3NlcyxcbiAgICBkaXJlY3Rpb246IHRyYW5zaXRpb25EaXJlY3Rpb24sXG4gICAgb25TdGFydDogdXNlTGF0ZXN0VmFsdWUoKGRpcmVjdGlvbikgPT4ge1xuICAgICAgbmVzdGluZy5vblN0YXJ0KGNvbnRhaW5lciwgZGlyZWN0aW9uLCBiZWZvcmVFdmVudCk7XG4gICAgfSksXG4gICAgb25TdG9wOiB1c2VMYXRlc3RWYWx1ZSgoZGlyZWN0aW9uKSA9PiB7XG4gICAgICBuZXN0aW5nLm9uU3RvcChjb250YWluZXIsIGRpcmVjdGlvbiwgYWZ0ZXJFdmVudCk7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcImxlYXZlXCIgJiYgIWhhc0NoaWxkcmVuKG5lc3RpbmcpKSB7XG4gICAgICAgIHNldFN0YXRlKFwiaGlkZGVuXCIgLyogSGlkZGVuICovKTtcbiAgICAgICAgdW5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgfVxuICAgIH0pXG4gIH0pO1xuICAoMCwgaW1wb3J0X3JlYWN0MzkudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKCFza2lwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzdHJhdGVneSA9PT0gMSAvKiBIaWRkZW4gKi8pIHtcbiAgICAgIHByZXZTaG93LmN1cnJlbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2U2hvdy5jdXJyZW50ID0gc2hvdztcbiAgICB9XG4gIH0sIFtzaG93LCBza2lwLCBzdGF0ZTJdKTtcbiAgbGV0IHRoZWlyUHJvcHMgPSByZXN0O1xuICBsZXQgb3VyUHJvcHMgPSB7IHJlZjogdHJhbnNpdGlvblJlZiB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChOZXN0aW5nQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBuZXN0aW5nXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzOS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoT3BlbkNsb3NlZFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG1hdGNoKHN0YXRlMiwge1xuICAgICAgW1widmlzaWJsZVwiIC8qIFZpc2libGUgKi9dOiAwIC8qIE9wZW4gKi8sXG4gICAgICBbXCJoaWRkZW5cIiAvKiBIaWRkZW4gKi9dOiAxIC8qIENsb3NlZCAqL1xuICAgIH0pXG4gIH0sIHJlbmRlcih7XG4gICAgb3VyUHJvcHMsXG4gICAgdGhlaXJQcm9wcyxcbiAgICBkZWZhdWx0VGFnOiBERUZBVUxUX1RSQU5TSVRJT05fQ0hJTERfVEFHLFxuICAgIGZlYXR1cmVzOiBUcmFuc2l0aW9uQ2hpbGRSZW5kZXJGZWF0dXJlcyxcbiAgICB2aXNpYmxlOiBzdGF0ZTIgPT09IFwidmlzaWJsZVwiIC8qIFZpc2libGUgKi8sXG4gICAgbmFtZTogXCJUcmFuc2l0aW9uLkNoaWxkXCJcbiAgfSkpKTtcbn0pO1xudmFyIFRyYW5zaXRpb25Sb290ID0gZm9yd2FyZFJlZldpdGhBcyhmdW5jdGlvbiBUcmFuc2l0aW9uKHByb3BzLCByZWYpIHtcbiAgbGV0IHsgc2hvdywgYXBwZWFyID0gZmFsc2UsIHVubW91bnQsIC4uLnRoZWlyUHJvcHMgfSA9IHByb3BzO1xuICBsZXQgaW50ZXJuYWxUcmFuc2l0aW9uUmVmID0gKDAsIGltcG9ydF9yZWFjdDM5LnVzZVJlZikobnVsbCk7XG4gIGxldCB0cmFuc2l0aW9uUmVmID0gdXNlU3luY1JlZnMoaW50ZXJuYWxUcmFuc2l0aW9uUmVmLCByZWYpO1xuICB1c2VTZXJ2ZXJIYW5kb2ZmQ29tcGxldGUoKTtcbiAgbGV0IHVzZXNPcGVuQ2xvc2VkU3RhdGUgPSB1c2VPcGVuQ2xvc2VkKCk7XG4gIGlmIChzaG93ID09PSB2b2lkIDAgJiYgdXNlc09wZW5DbG9zZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgIHNob3cgPSBtYXRjaCh1c2VzT3BlbkNsb3NlZFN0YXRlLCB7XG4gICAgICBbMCAvKiBPcGVuICovXTogdHJ1ZSxcbiAgICAgIFsxIC8qIENsb3NlZCAqL106IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFbdHJ1ZSwgZmFsc2VdLmluY2x1ZGVzKHNob3cpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSA8VHJhbnNpdGlvbiAvPiBpcyB1c2VkIGJ1dCBpdCBpcyBtaXNzaW5nIGEgYHNob3c9e3RydWUgfCBmYWxzZX1gIHByb3AuXCIpO1xuICB9XG4gIGxldCBbc3RhdGUyLCBzZXRTdGF0ZV0gPSAoMCwgaW1wb3J0X3JlYWN0MzkudXNlU3RhdGUpKHNob3cgPyBcInZpc2libGVcIiAvKiBWaXNpYmxlICovIDogXCJoaWRkZW5cIiAvKiBIaWRkZW4gKi8pO1xuICBsZXQgbmVzdGluZ0JhZyA9IHVzZU5lc3RpbmcoKCkgPT4ge1xuICAgIHNldFN0YXRlKFwiaGlkZGVuXCIgLyogSGlkZGVuICovKTtcbiAgfSk7XG4gIGxldCBbaW5pdGlhbCwgc2V0SW5pdGlhbF0gPSAoMCwgaW1wb3J0X3JlYWN0MzkudXNlU3RhdGUpKHRydWUpO1xuICBsZXQgY2hhbmdlcyA9ICgwLCBpbXBvcnRfcmVhY3QzOS51c2VSZWYpKFtzaG93XSk7XG4gIHVzZUlzb01vcnBoaWNFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbml0aWFsID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlcy5jdXJyZW50W2NoYW5nZXMuY3VycmVudC5sZW5ndGggLSAxXSAhPT0gc2hvdykge1xuICAgICAgY2hhbmdlcy5jdXJyZW50LnB1c2goc2hvdyk7XG4gICAgICBzZXRJbml0aWFsKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtjaGFuZ2VzLCBzaG93XSk7XG4gIGxldCB0cmFuc2l0aW9uQmFnID0gKDAsIGltcG9ydF9yZWFjdDM5LnVzZU1lbW8pKCgpID0+ICh7IHNob3csIGFwcGVhciwgaW5pdGlhbCB9KSwgW3Nob3csIGFwcGVhciwgaW5pdGlhbF0pO1xuICAoMCwgaW1wb3J0X3JlYWN0MzkudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKHNob3cpIHtcbiAgICAgIHNldFN0YXRlKFwidmlzaWJsZVwiIC8qIFZpc2libGUgKi8pO1xuICAgIH0gZWxzZSBpZiAoIWhhc0NoaWxkcmVuKG5lc3RpbmdCYWcpKSB7XG4gICAgICBzZXRTdGF0ZShcImhpZGRlblwiIC8qIEhpZGRlbiAqLyk7XG4gICAgfSBlbHNlIGlmICh0cnVlKSB7XG4gICAgICBsZXQgbm9kZSA9IGludGVybmFsVHJhbnNpdGlvblJlZi5jdXJyZW50O1xuICAgICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAocmVjdC54ID09PSAwICYmIHJlY3QueSA9PT0gMCAmJiByZWN0LndpZHRoID09PSAwICYmIHJlY3QuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHNldFN0YXRlKFwiaGlkZGVuXCIgLyogSGlkZGVuICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzaG93LCBuZXN0aW5nQmFnXSk7XG4gIGxldCBzaGFyZWRQcm9wcyA9IHsgdW5tb3VudCB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChOZXN0aW5nQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBuZXN0aW5nQmFnXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzOS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJhbnNpdGlvbkJhZ1xuICB9LCByZW5kZXIoe1xuICAgIG91clByb3BzOiB7XG4gICAgICAuLi5zaGFyZWRQcm9wcyxcbiAgICAgIGFzOiBpbXBvcnRfcmVhY3QzOS5GcmFnbWVudCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MzkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25DaGlsZCwge1xuICAgICAgICByZWY6IHRyYW5zaXRpb25SZWYsXG4gICAgICAgIC4uLnNoYXJlZFByb3BzLFxuICAgICAgICAuLi50aGVpclByb3BzXG4gICAgICB9KVxuICAgIH0sXG4gICAgdGhlaXJQcm9wczoge30sXG4gICAgZGVmYXVsdFRhZzogaW1wb3J0X3JlYWN0MzkuRnJhZ21lbnQsXG4gICAgZmVhdHVyZXM6IFRyYW5zaXRpb25DaGlsZFJlbmRlckZlYXR1cmVzLFxuICAgIHZpc2libGU6IHN0YXRlMiA9PT0gXCJ2aXNpYmxlXCIgLyogVmlzaWJsZSAqLyxcbiAgICBuYW1lOiBcIlRyYW5zaXRpb25cIlxuICB9KSkpO1xufSk7XG52YXIgQ2hpbGQgPSBmb3J3YXJkUmVmV2l0aEFzKGZ1bmN0aW9uIENoaWxkMihwcm9wcywgcmVmKSB7XG4gIGxldCBoYXNUcmFuc2l0aW9uQ29udGV4dCA9ICgwLCBpbXBvcnRfcmVhY3QzOS51c2VDb250ZXh0KShUcmFuc2l0aW9uQ29udGV4dCkgIT09IG51bGw7XG4gIGxldCBoYXNPcGVuQ2xvc2VkQ29udGV4dCA9IHVzZU9wZW5DbG9zZWQoKSAhPT0gbnVsbDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzOS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoaW1wb3J0X3JlYWN0MzkuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgIWhhc1RyYW5zaXRpb25Db250ZXh0ICYmIGhhc09wZW5DbG9zZWRDb250ZXh0ID8gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDM5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uUm9vdCwge1xuICAgIHJlZixcbiAgICAuLi5wcm9wc1xuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QzOS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkNoaWxkLCB7XG4gICAgcmVmLFxuICAgIC4uLnByb3BzXG4gIH0pKTtcbn0pO1xudmFyIFRyYW5zaXRpb24yID0gT2JqZWN0LmFzc2lnbihUcmFuc2l0aW9uUm9vdCwgeyBDaGlsZCwgUm9vdDogVHJhbnNpdGlvblJvb3QgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@headlessui/react/dist/headlessui.dev.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@headlessui/react/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@headlessui/react/dist/index.cjs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./headlessui.dev.cjs */ \"(ssr)/./node_modules/@headlessui/react/dist/headlessui.dev.cjs\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtJQUFnRDtBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovL2d1aWxoZXJtZWZyZWl0YXMuY29tLy4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvaW5kZXguY2pzPzVkMjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9oZWFkbGVzc3VpLnByb2QuY2pzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9oZWFkbGVzc3VpLmRldi5janMnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@headlessui/react/dist/index.cjs\n");

/***/ })

};
;